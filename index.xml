<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>风行's Blog</title><link>https://lijingcheng.github.io/</link><description>Recent content on 风行's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 20 Mar 2020 18:19:12 +0800</lastBuildDate><atom:link href="https://lijingcheng.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Telegram 机器人程序开发</title><link>https://lijingcheng.github.io/posts/telegram-bot/</link><pubDate>Fri, 20 Mar 2020 18:19:12 +0800</pubDate><guid>https://lijingcheng.github.io/posts/telegram-bot/</guid><description>Telegram 是一款非常优秀的聊天软件，它非常重视用户隐私并对所有聊天信息进行加密并做永久存储，它还提供了种类丰富的群组和机器人，机器人是通过程序运作的账号，可以回复我们发送的消息，还可以提供消息的定时推送功能，例如推送新闻、天气预报、提醒事项等。
Telegram 官方为了让开发者能够参与到机器人的开发，还免费提供了功能齐全的 API，我们可以用它创建自己的机器人，下面介绍下如何创建和部署机器人程序。
准备工作 Telegram 支持多种语言来编写机器人，相对来说使用 Python 的比较多，并且有比较成熟的第三方库 python-telegram-bot 供选择使用，所以建议花点时间学习下 Python，掌握基本的开发方式和语法后就可以上手了，然后在开发过程中再去慢慢解决遇到的问题。
建议使用 PyCharm 作为 IDE 来编写程序，这样不仅可以在编写代码时有语法高亮和自动提示，而且还可以更方便的添加第三方库和包管理器，默认的包管理器是 pip，我们可以换成 pipenv，它会自动帮你管理虚拟环境和依赖文件。
下面列出几条 Python 语法中比较特别的地方
代码缩进非常重要，同一代码块中的多行代码强制使用相同数量的空格，否则程序会编译不过 定义变量用 x = 5 就可以了，不用声明是常量还是变量，并且 x 作为 int 类型时，它的长度不受限制 python 中的字符串可以直接当数组来用，例： z = &amp;lsquo;abcdefg&amp;rsquo; z[0] = a, z[1:3] = bc if 语句中可使用 in 或 not in 关键字，例：if &amp;lsquo;ab&amp;rsquo; in &amp;lsquo;abcd&amp;rsquo; [&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;c&amp;rsquo;] 是 Array，(&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;lsquo;c&amp;rsquo;) 是 Set 操作数组时索引可以是负数，表示从数组的后面开始按索引查找数据 创建机器人 在 Telegram 应用中通过与 @BotFather 交谈来创建自己的机器人，具体方式跟着引导来操作就可以了，需要注意的是每个机器人都会对应一个 Token，机器人的所有信息交互都会用到它，所以要保管好不要泄漏，避免其他人也能使用你的机器人做事情，创建机器人后可用链接 https://api.</description></item><item><title>2008 骑行川藏南线</title><link>https://lijingcheng.github.io/posts/biketotibet/</link><pubDate>Fri, 07 Feb 2020 10:01:23 +0800</pubDate><guid>https://lijingcheng.github.io/posts/biketotibet/</guid><description>本文内容根据2008年骑行川藏南线时的骑行日记整理，当时从成都出发沿318国道经过52天的骑行到达珠峰大本营，我们一路翻越二郎山、折多山、剪子弯山、东达山、米拉山、嘉措拉山等海拔4000到5000米的高山十几座，又先后跨越大渡河、雅砻江、金沙江、澜沧江、怒江、雅鲁藏布江等十多条河流，在领略当地人文风情和宗教文化的同时，也见识到了从未见过的美景，如果这世界真的有天堂存在，那西藏一定是最接近它的地方。
☁️ 从成都出发到达邛崃（5月2日） 邛崃 补胎 临邛古镇 奶汤面 串串香
早上不到八点我们就把行李收拾好了，然后把几十斤重的驮包放到自行车后架上，一开始骑的时候大家都不太适应，接下来我们便穿过成都市区摇摇晃晃的踏上了318国道，出发第一天大家都很兴奋，骑的也越来越快，不过没多久我的车胎就扎了，当时只觉得越骑越累，还以为是自己体力出了问题，这次补胎用了近20分钟，人生第二次补胎，时间上还算满意。中午我们在路边的一家饭馆吃饭，由于饭馆里的菜不多，所以老板没有做菜单，想吃什么就照着厨房里有的菜点，可以自己随意搭配，这是我们第一次用这种方式点菜，都觉得很新鲜，吃完饭继续上路，下午到邛崃时已经3点多了，我们找了家318国道边上的旅店住下，高原今天状态不好，进屋就休息了，12的车胎慢撒气，等他补完胎我们一起去有二千多年历史的临邛古镇转了转，现在已经很商业化了，不是很喜欢，晚饭我们吃的是奶汤面，由于他们不吃辣的后来我又自己去吃了些串串香，味道一般，在后面的路上，几乎每个县城都能看到邛崃饭馆，邛崃人民还是很能干的！
🌧 在雨中骑向雅安（5月3日） 雅安 青衣江 雅雨 雅女 雅鱼
今天计划骑到雨城雅安，雅安有三绝，雅雨、雅女、雅鱼，据说这里一年会有二百多天都在下雨，雨水冲刷掉了大地的尘埃，使雨城雅安空气清新，气候宜人，所以传说中的雅女个个都很漂亮，雅鱼产于青衣江雅安段，这种鱼肉质鲜美，据说清朝时还是贡品，不过最近少多了，我们怀着对三雅的期待便上路了，当我们骑到名山县附近时天开始下雨，大家换上雨具继续骑，今天的路几乎是一路缓上坡，虽然跟之后的山路比起来根本不算什么，但今天我的状态不好，骑的特别累，屁股也开始疼起来，中午吃饭时大家吃的都不少，我吃了六碗米饭，这也是我长这么大以来吃的最多的一次，大家把菜吃得连菜汤都没有剩，之后我们无论在哪里吃饭点几个菜，几乎都是这样，从不浪费粮食，吃完饭后我们便在围观群众的注视下离开了这里，下午大概3点多到达雅安，这个城市边上都是山，一条青衣江穿城而过，云停留在山中间，从外面看起来这个城市给人的感觉很好，进城后我们在城里转了一圈，找了家便宜而且位置不错的旅店，我们的房间在三层，大家把驮包拆下然后分二次把包和自行车都抬到楼上，都安顿完后便出去逛街，一路上看来看去也没觉得雅女有什么特别，而且也没吃到雅鱼，晚上天黑后我自己坐在青衣江边写日记，路上行人很少，路灯也很昏暗，天还在上雨，一切似乎都很美好。
🌤 沿青衣江到达天全县两路乡（5月4日） 天全县 两路乡 顶风爬坡 文家饭店
今天早上从雅安出发后便进入山路，不停的上下坡，而且一路顶风，为了减少阻力我们轮着领骑，这样能相对减少体力消耗，山里很凉快，景色也很好，山下的青衣江由灰色变成黄色最后又变成灰色，路边有很多大狗，我们路过时他们就会狂叫，很吓人，最吓人的还是那些躲在角落里的狗，总是会突然跳出来，不过好在他们都被拴着，上午在路边看到一个当地人在接山泉水，她说她们家从很久以前就一直喝这个，还说水特好，于是我也接了一瓶，虽然有点甜但是特别凉，晚上快六点时我们到达天全县的两路乡，住在“文家饭店”，文家饭店是个3层的大院，对面是公安局，隔壁是乡政府，住这放心，而且才十元一人，这家店的老板娘在天全县的厨艺比赛中还得过一等奖，晚上我们点了个砂锅豆腐，锅里除了豆腐还有好几种蘑菇，还有肥肠，丸子，肉，香肠等，味道很好，今天爬了一天山，有好几次都觉得自己不行了想下来推会，但都坚持过来了，其实很多事都是这样，一咬牙就过去了。
🌤 穿过老虎嘴和二郎山到达泸定（5月5日） 老虎嘴隧道 二郎山 雪山 泸定 大渡河</description></item><item><title>Code Review 注意事项</title><link>https://lijingcheng.github.io/posts/code-review/</link><pubDate>Mon, 13 Jan 2020 10:00:38 +0800</pubDate><guid>https://lijingcheng.github.io/posts/code-review/</guid><description>持续并有效的 Code Review 不仅可以提高代码质量，降低程序风险，还可以提高开发人员技术水平，但前提是需要开发人员能够真正认可并意识到这并不是在浪费时间，而且在实施前最好能够得到公司认可，并能够将 Code Review 时间计入工作量，下面列出几个需要注意的地方：
要有一个 CheckList，对一些代码问题进行定义，并要求开发人员以此为准
代码风格上的问题应该通过自动审查工具去做，如 OCLint/SwiftLint，代码逻辑及性能上的问题可通过 Merge Request 去做，整个团队一起互相 Review 的方式不适合频繁实行，应该以总结的性质定期来做
要在代码提交测试前做，避免测试人员返工，影响进度
审查过程中不要太关注代码细节，并且不要过度主观，例如同一功能可用多种方式实现并且它们之间没有明显好坏的情况下不用要求别人修改代码
审查要及时，打回时被审查者要尽量优先修改问题然后再次提交
审查不通过打回前，条件允许的话最好先跟代码提交者口头说明原因并达成一致，无法达成一致时可找 leader 解决
对于找谁审核代码这个问题，首先每份代码都要明确责任人，可以让同一套代码有两个人负责，这样不仅能够明确责任，还可以在其中一人休长假或有突发事件人不在的情况下，另一人能够有能力修改相关代码
要按功能提交代码，不要攒一堆然后一次提交，否则不仅会一次性大量占用审查者时间，而且会增加审查难度，还需要注意的是提交描述要根据修改内容写清楚，遵守 Git Commit 规范，这样可以促使团队形成一致的代码提交风格，在需要回溯提交历史时也方便查找
Angular 团队在开源框架 AngularJS 中的提交记录所遵守的规范被业内很多人认可和使用，格式为：type(scope):subject feat(首页):增加公告功能 fix(卡列表):默认图不正确 refactor:优化 WebView 遇到白屏时的处理 docs:为购卡功能添加注释 style:整理代码风格 chore:其它琐事&amp;hellip; 我们可以手动按规范来编写提交信息，也可以借助一些 js 库来帮我们遵守规范，首先我们需要安装 Node.js 环境下的包管理器 npm（Node.js 可以使 JavaScript 脱离浏览器的运行环境） 使用 commitizen 来辅助我们编写符合 type(scope):subject 格式的提交信息 使用 commitlint 对提交信息进行格式检查，并通过 husky 库更方便的通过 git hook 在 pre-commit 时强制要求每条提交记录都能够遵守规范 当我们开始按规范编写提交信息后，便可以使用 conventional-changelog-cli 生成提交记录 下面列出的代码审查 CheckList 可供参考，其中一部分仅适用于 Swift 开发</description></item><item><title>iOS 开发中的设计模式</title><link>https://lijingcheng.github.io/posts/design-patterns/</link><pubDate>Fri, 03 Jan 2020 14:18:55 +0800</pubDate><guid>https://lijingcheng.github.io/posts/design-patterns/</guid><description>1994 年被称为四人帮（Gang of Four）的 Erich Gamma、Richard Helm、Ralph Johnson、John Vlissides 四位作者发表了一本名为《Design Patterns: Elements of Reusable Object-Oriented Software》的书，据说是由他们首次在书里提出了设计模式的概念，书中收录了 23 种设计模式。
设计模式是对软件开发设计中一些常见问题的解决方案，为了便于沟通，又给每种方案起了名字并归类，设计模式不局限于某种开发语言，也不局限于面向对象设计思想，它同样可应用于函数式开发和面向协议开发。
设计原则 其实我们在不知不觉时已经使用到了很多模式，在分别介绍它们前需要先了解下设计模式的六大原则和一个法则，制定这些原则的目的并不是要我们刻板的去遵守它们，而是要根据实际情况去灵活运用。
开闭原则 当程序需要新增功能时，不去修改原有的代码，而是通过新增代码的方式去做扩展，这样做可以避免影响到原有功能，并且能够提高程序的稳定性和灵活性，易于维护和升级。
单一职责原则 单一职责的核心思想就是高内聚、低耦合，一个类或方法只做它该做的事情，这样做的好处是代码复杂性低、可维护性高，当代码发生变化时影响范围较小。
接口隔离原则 代码之间的依赖关系应该建立在已满足单一职责的接口上，并且不去依赖它不需要的接口，所以要避免出现庞大臃肿的接口，满足接口隔离原则可以降低代码耦合度，提高程序设计灵活性。
里氏替换原则 使用父类的地方必须能够使用其子类，但父类未必能胜任子类做的事情，如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开继承关系，改为通过依赖、聚合、组合等方式来实现代码的复用。
依赖倒置原则 程序要依赖于抽象（接口或抽象类）而不依赖于具体实现，抽象不应该关注细节，细节应该依赖于抽象，本质就是我们常说的面向接口编程。依赖倒置的好处是可以使各个类或模块彼此独立，互不影响，从而实现模块间的松耦合。在实际开发中的一个应用就是当我们在做组件化开发时，核心组件和功能组件不依赖于业务组件，不关心业务细节，业务组件可依赖于多个上层功能组件。
合成聚合复用原则 合成/聚合指在一个对象里面使用一些已有类的对象，使之成为自己的一部分来达到复用已有功能的目的，相对继承来说耦合性低一些，当只有“Is - A”才应该使用继承，“Has - A”应当使用聚合。
迪米特法则 迪米特法则又叫最少知识原则，一个对象应当对其他对象尽可能少的了解，也就是说要尽量少发布 public 的属性和方法，这样利于降低类与类之间的代码耦合度，在代码发生变更时影响范围较小，并且系统功能模块也会相对独立。
设计模式 设计模式可以根据其意图或目的分为创建型、结构型、行为型三类，分别关注创建对象、组合代码和对象间的通信问题。
创建型设计模式 创建型模式关注创建对象的机制，通过将对象的创建和使用分离来增加代码的灵活性和可复用性。包含简单工厂模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式和单例模式。
简单工厂模式（Simple Factory） 在工厂类中定义用于创建实例的静态方法，然后根据传入参数的不同返回不同实例，被创建的实例具有共同的父类或接口，调用处只关心要什么，不用关心具体创建方式。
class MapFactory { static func getMap(_ type: MapType) -&amp;gt; Map { switch type { case .baidu: return BaiduMap() case .system: return SystemMap() } } 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品（高德地图）需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。</description></item><item><title>我的 MacOS 装机必备应用</title><link>https://lijingcheng.github.io/posts/macos-init/</link><pubDate>Thu, 19 Dec 2019 11:01:18 +0800</pubDate><guid>https://lijingcheng.github.io/posts/macos-init/</guid><description>常规应用 Chrome、微信、飞书、Telegram
工具 ClashX Pro、Alfred、Unarchiver、Tencent Lemon、Agenda、有道词典
办公 网易邮箱、Pages、Keynote、Numbers、MWeb、Sublime Text、XMind、OmniPlan
开发 Xcode、Sourcetree、Charles
终端 iTerm、Homebrew、RVM、CocoaPods、Oh My ZSH、Hugo</description></item><item><title>使用 Hugo + GitHub Actions 升级博客</title><link>https://lijingcheng.github.io/posts/hugo/</link><pubDate>Wed, 11 Dec 2019 16:28:43 +0800</pubDate><guid>https://lijingcheng.github.io/posts/hugo/</guid><description>最近打算更新下博客模板并优化下内容的发布流程，于是放弃了多年不更新的 Octopress，在目前比较流行的静态博客生成工具 Hexo 和 Hugo 之间选择了后者，主要看重的是 Hugo 在发布时速度比较快，并且依赖较少。
关于发布流程，首先打算使用持续集成服务来提高内容发布效率，简化操作步骤，以达到提交 Markdown 源文件到 GitHub 后就能够自动完成博客站点的部署，在 Travis CI 和 GitHub Actions 之间选择了后者，对我来说最看重的就是它可以复用别人写好的 Action 并根据自己的需要来组合使用。
安装 Hugo 建议使用 Homebrew 安装 Hugo
brew install hugo 新建站点 hugo new site blog 新建站点后进入 blog 目录，查看生成的文件及主要目录
archetypes 目录下会有个模板文件，新生成的文章会以此为模板
config.toml 网站配置文件
content 用来存放 Markdown 文件
layouts 存放 html 模板文件，如果使用了第三方模板，可以将 themes 里 layouts 目录下的 html 复制过来，然后在这里修改，hugo 会优先使用这个目录下的该文件，以后再更新 themes 下的模板文件时也不用担心文件冲突问题
data 存储数据文件供模板使用</description></item><item><title>iOS 应用的启动任务设计</title><link>https://lijingcheng.github.io/posts/ios-task/</link><pubDate>Thu, 29 Aug 2019 15:18:55 +0800</pubDate><guid>https://lijingcheng.github.io/posts/ios-task/</guid><description>从点击 app 图标到看到首页内容就算是一次启动过程，在这个短则一两秒的过程中 app 要做的事情却有很多，本文主要介绍如何管理这些任务的执行方式和优先级问题。
下面列出 app 启动过程中会去执行的一些主要任务：
设置 app UI 样式
开启定位、埋点、网络状态监听、通知监听等服务
初始化一些第三方服务
如果是通过点击推送通知进入的 app 还会去存储相关数据用于在进入首页后跳转页面或弹框
访问一些接口并处理返回结果
上面列出的大部分任务都不需要我们主动去管理，只要在处理过程中注意不要影响启动速度就可以了，需要我们去管理的任务主要是对于一些接口返回数据的处理，像 升级检查、换肤、弹窗广告 这类接口在拿到返回数据后不能够马上处理，而是需要先保存数据然后等待首页展示出来后再做 UI 效果处理，并且这些任务通常还需要考虑优先级问题，例如当需要展示升级提示时就不应该再展示弹窗广告。
我目前的处理方案是基于 RxSwift 响应式编程框架实现，每项任务都是可以被订阅的，订阅者可以监听任务状态并作出响应，每项任务的最初状态是 unknown 未知的，也就是接口还未返回数据时的状态，当接口返回数据后，再根据情况将状态改为 need 或 noneed，也就是需要处理或不需要处理，我们可以让接口调用处只将关注点放在改变任务状态上，不同状态时该如何处理是由该任务的管理类决定，具体什么时候以及是否需要处理则是由该任务的订阅者去决定。
下面以 检查升级 任务为主线看下具体代码实现，首先在 app 启动后发起异步接口调用，并根据返回数据修改任务状态，此时不用考虑 app 是否已经进入首页，以及如果弹框提示用户等功能
NetworkService.get(&amp;#34;xxx.api&amp;#34;) { [weak self] (result, error) in if ... { Task.shared.upgrade.accept(.need) } else { Task.shared.upgrade.accept(.noneed) } } 当 app 进入首页后，会在 viewDidAppear 方法中发出 Notification 用来触发任务订阅管理功能</description></item><item><title>如何做好技术管理</title><link>https://lijingcheng.github.io/posts/manage/</link><pubDate>Wed, 12 Jun 2019 19:18:55 +0800</pubDate><guid>https://lijingcheng.github.io/posts/manage/</guid><description>好的技术管理者应该是一名情商高、会沟通并且懂业务的技术人员，如果再懂一点管理，就能够胜任大部分工作。
情商高 要能够控制情绪和心态，遇事不抱怨，懂得在适当的时候和场景下如何夸奖和批评别人，争论事情时要注意对事不对人，更重要的是要能够做到换位思考。
会沟通 沟通能力是每一个技术人员都需要具备的基本能力，技术管理者在这方面应该做的更好。在沟通环节中有两个问题很重要，聆听和表达，其中懂得聆听尤为重要，先让别人把话说完！除此之外还需要注意的是如果在 QQ 或其它工具上沟通不清楚的问题一定要当面沟通，这样效率高而且不容易造成双方误解。
懂业务 只有对业务具有较深入的了解才能综合技术和业务角度去思考问题并做出适合的架构设计。
有技术 在技术方面要具有一定的判断力和技术视野，不需要对各种技术都很精通，但必须有所了解，要能够对技术在该领域的发展趋势和应用场景有所了解，做产品技术架构的设计要有足够的弹性，既能够保证当前开发效率，又能够对未来产品技术架构的演进留出扩展的余地。除此之外还需要具要有较强的解决问题能力，当团队遇到技术困难时能够站出来解决它，否则很难在团队中建立威信。
会管理 对事管理 做事前要先明确工作目标和优先级，重要并且着急的事情要先做，重要但是不着急的其次，然后是着急不重要的，最后是不重要也不着急的，当项目时间非常紧时，要懂得适当降级。
任务分配前要先了解每个任务以及团队每个成员的情况，包括能力、性格、当前工作状态等，然后才能够将任务分配给合适的人，分配工作时要讲清楚目标和标准，否则完成效果出了问题后要先反思是不是自己的问题，leader 要勇于替下属承担责任，但是如果自己做的都没有问题，并且下属多次出现同样过错，就要看下是否是其态度出了问题
PS：过程重要但结果更重要，失败了就要把该背的锅背起来
对人管理 对上要完成给予的任务，对下要帮助解决问题并协调资源，还要帮助下属成长和提升，对于管理者来说对下管理是否能做好更重要一些。
对上要注意反馈 对上要注意信息对等，及时反应问题，不要让领导啥也不知道，出了问题后让别人告诉领导后就晚了，多沟通、多了解整体方向，好及时调整和应对，并且该争取的资源要争取，该背的锅要自己背上，少解释，多想想怎么解决，同样的错误不要犯两次。对于还没有解决的问题，要反馈出解决问题大概需要的时间及目前状态，对于已经解决的问题，要反馈出现问题的原因以及怎么避免再次发生，并且预计该问题造成的影响范围，不要一味的甩锅。
PS：尽量不去做越级沟通的事
对下要注意授权和培养 要注重对成员的培养，培养他们的学习能力，思考能力和解决问题的能力，同时要授权组员去做事情，而不是怕他们做不好就自己做了，但授权不是放任不管，而是要针对不同员工类型做不同管理动作，对于新人要有人带，对于有初级经验的人可以讲完再让他做，经验丰富的人他做的时候可以关注下，并给出建议和要求，同时关注工作成果并帮他完善，能力强积极性高的，可分配更重要的工作，并让他参与设计决策中来。
组员做的时候还要给予技术以及资源等方面的支持，并定期评估结果给予反馈，当任一环节出现 delay 时要想办法及时补救，避免积少成多造成项目进度失控。进度把控上需要时刻监督执行的效果，但不是靠天天问进度来了解，也不要完全不管不问，对不熟悉的团队要把重点放在人身上，对熟悉并靠谱的团队要把重点放在事上，当事情结束后对做的好的经予鼓励，做的不好的要指出错误，错误的指出要明确和及时，要对事不对人，这点很重要，因为当你说对方是坏人时对方就会变成坏人，当你说对方是好人时对方就会变成好人，所以即使是批评也要将话题定位在事情本身上，去强调这件事没做好，而不是对方为什么不好好做事，有些事情可能还需要小范围或单独去沟通。
PS：要保护成员不被部门间其他乱七八糟的事情干扰，团队气氛还是很重要的</description></item><item><title>了解一点互联网架构</title><link>https://lijingcheng.github.io/posts/architecture/</link><pubDate>Fri, 12 Apr 2019 17:28:16 +0800</pubDate><guid>https://lijingcheng.github.io/posts/architecture/</guid><description>早期互联网应用通常用户少、并发低、数据量也比较小，所以将应用程序、文件服务、数据库服务都集中部署在一台服务器上就能够满足需求，这种方式易于开发和部署，但它做不到高可用和高并发，当服务器出现故障或项目升级时需要停止服务。
随着时代发展，用户量及数据量快速膨胀，访问量也越来越多，于是对系统的高可用和高并发等方面都有了更高要求，互联网应用架构逐渐发展成需要集群部署以及分布式部署来满足需求。
集群部署可以简单理解成多台机器部署相同服务，它是用来解决高可用、高并发以及海量数据问题的常用手段，在使用时需要考虑负载均衡、异地多活、容灾备份、以及熔断隔离等问题。
分布式部署可以简单理解成多台机器部署不同服务，使用时需要考虑各服务间的通信等问题，如 RPC，消息队列以及分布式事务和分布式锁。
下图为58架构师沈剑画的互联网应用分层架构图（侵删），将互联网架构分为以下几层：客户端层、反向代理层、Web应用层、服务层和数据层
客户端层 客户端层的主体通常是浏览器、app 和小程序，它们的主要任务就是向用户展示数据并提供所需的数据交互功能，它会频繁的与Web应用层交换数据，在这过程中客户端会向 DNS 服务器发起域名解析请求，如果 DNS 服务器指向了某个 CDN 服务，则会将域名解析操作交给 CDN 中的 DNS 负载均衡系统处理，在识别出访问者是北京某联通用户后，会根据用户 IP 将离用户最近的联通机房中部署的反向代理服务集群中的某个服务器外网地址返回，该地址在被访问时会实施负载均衡策略并将请求转发给内网中Web应用集群中的某一台服务器。
当系统遇到性能问题时，通常会对Web服务器做集群，然后通过反向代理去做负载均衡，当系统吞吐超过反向代理的性能极限并且难以扩容时，可以在 DNS 服务器上对同一个域名配置多个反向代理服务器 IP，然后每次 DNS 解析请求时通过轮询或其他方式返回不同 IP，从而达到负载均衡目的，大型网站通常会使用 DNS 来做一级负载均衡，然后再在内部做第二级负载均衡。
一些访问量较高的网站、直播、视频平台都会利用 CDN 来解决不同地域不同网络访问静态资源的速度问题，当用户就近的缓存服务器没有相关资源时才会访问源服务器获取资源，并且根据策略决定是否更新缓存数据。
反向代理层 通常代理服务器是相对于用户来说的，它可以代替用户去获取网络信息，从而隐藏真实的客户端信息（VPN），而反向代理的目的是为了隐藏Web服务器，它以代理服务器的身份来接受网络连接请求，然后根据负载均衡策略将请求转发给内网上的某台服务器上，以解决系统面临大量用户访问时负载过高的问题，在转发过程中负载均衡技术能够提供服务器的失效检测功能，然后将用户请求转发到可用节点上，从而保证所有服务持续可用
负载均衡技术包括 DNS 负载均衡、硬件负载均衡和软件负载均衡，其中硬件负载均衡是通过网络设备硬件来抗压力，虽然性能好但是太贵，很多公司负担不起，基于软件做的负载均衡只需要在正常服务器上部署软件即可，它还分为四层协议和七层协议两种：
基于第四层传输层来做流量分发的称为四层负载均衡，例如 LVS（Linux Virtual Server），四层负载均衡服务器在接受到客户端请求后通过修改数据包的地址信息（IP + 端口号）将流量转发出去
基于第七层应用层来做流量分发的称为七层负载均衡，例如 Nginx 反向代理软件，它通过代理方式实现负载均衡
第四层的负载均衡性能相对来说要高一些，但对于一般应用来说七层就够用了，一些大型网站通常会采用 DNS + 四层 + 七层负载的方式进行多层次负载均衡
常用负载均衡策略包括：
轮询：将请求轮流发送到每个服务器上，这适合每台服务器性能差不多的场景，如果有性能差异，那么性能较差的服务器可能无法承担所分配的负载
加权轮询：在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权重，性能高的服务器分配更高的权重</description></item><item><title>学习骑摩托车〜</title><link>https://lijingcheng.github.io/posts/moto/</link><pubDate>Thu, 28 Mar 2019 15:02:12 +0800</pubDate><guid>https://lijingcheng.github.io/posts/moto/</guid><description>总结了一些骑摩托车时需要注意的事情，也许能帮助到新手， 开车文章中写的大部分内容同样适用于骑摩托车。
起步 先确认车辆是否处于空挡，然后打侧踢，通电后拉住离合再打火
捏住离合和前刹车后挂一档，然后再换脚踩后刹松开前刹（高档位停车时要注意把档位放回一档，高档位起步很容易烧离合，或者熄火）
打左转向，观察后视镜并回头确认安全后慢松离合，如果希望起步能快点，可以先加一点点油，然后再慢松离合，松的过慢对离合不好，松太快并且油门给的很大时车会前冲，甚至翘头（找到离合咬合点的位置后，可快速松到咬合点位置再慢松）
行车 姿势 用前脚掌踩脚踏，避免车辆颠簸时误踩刹车或档杆，脚要直踩不要八字，避免转弯倾角低时磨到脚而倒致摔车
用腿夹住油箱从而把自己固定在车上，手轻搭在车把上，不要把身体重量压上去
右手掌要注意姿势，不要因不小心而拧大油门，捏离合和刹车用两个指头，好处是遇到阻力时不容易脱手
加速时身体往前弯些，减速相反，刹车时腿要紧贴油箱
换档 加档操作：收油 - 捏离合 - 加档 - 补油 - 松离合 （收油是指用手将油门转回去，而不是让油门自己弹回去）
减档操作与加档几乎一样，需要注意的是高速行驶时减档会引起车辆顿挫，避免出现这种情况的方法就是减档补油，即指减档后松离合前就快速给一点点油（减档补油可避免因减档操作造成发动机转速与后轮转速有差异而产生后轮打滑问题，有滑动离合的车可省去此操作）
一档二档间的更换建议稍微用些力，避免挂入空档，万一挂了空档，那就捏住离合再挂一下
一档二档间的更换离合都建议慢放，这样顿挫感会小些，高档之间的升降可快放离合
把握好加减档时机，低档位高转速时车辆引擎会发热并产生震动，声音也会变得高亢，这时便需要加档，而高档位低转速车会有加油没力要熄火的感觉，这时便需要减档并补油，如果是连降两档，要补的油也要稍微多一点（高档位低转速通常发生在刹车减速拐弯忘了降档）
转弯 打转向灯后，除了看后视镜，最好也快速转头看一下，这样死角会少一些
一定要在进弯道前通过刹车和降档来控制好速度，进入弯道后便松开刹车，但是油门要保持住，不要突然加油或收油，否则影响车辆重心而产生危险
转弯时走路外侧，然后切进去，出弯后车回正后再加油
转弯时不要用前刹，容易抱死倒致原地倒车，用后刹的话也只能一点点踩，避免后轮锁死</description></item><item><title>iOS 应用的开发设计</title><link>https://lijingcheng.github.io/posts/ios-design/</link><pubDate>Wed, 05 Sep 2018 18:40:19 +0800</pubDate><guid>https://lijingcheng.github.io/posts/ios-design/</guid><description>一个 app 从设计到发布应用商店会经历需求设计、UI设计、架构设计、开发、优化、测试等流程，每个环节做的好与坏都会影响到整个 app 的质量，作为开发人员，不仅要对需求以及 UI 的合理性进行评审，还要保证提供给测试的代码是经过自测并且覆盖了相关测试用例，更重要的是要做好架构设计、开发以及优化这三个环节。
架构设计 架构设计可以以业务为驱动，按照最适合自己的方式去设计，设计思路和方法尽量统一，同类型问题用同样方式去解决，下面几点是我认为比较重要的：
关注分离
将系统分解为多个模块并各司其职，纵向分层，横向拆分业务。
高内聚
一个模块只完成一个功能，并合理有度的进行封装。
松耦合
依赖关系越少越好，尽量不横向依赖，不跨层访问。继承是紧耦合的一种操作，它通常与多态一起存在，如果仅仅是为了代码重用而做的继承还不如用组合。
适度设计
对业务方该限制的地方要进行限制，该灵活的地方也要给业务方创造灵活实现的条件，架构的设计要保持一定量的超前性而做到易扩展，但不要设计过度，避免多做无用功而增加框架复杂度。好的架构是随着时间而更新的，而不是一开始就设计好了一切。
技术选型
不要仅是为了体验新技术而改变现有架构，等别人把坑踩平后再根据团队及业务情况考虑是否使用，技术本身没有什么好不好，只有适合不适合。
框架是服务开发人员的，需要满足通用性和易用性两个要求，其中易用性更重要
开发 MVVM MVVM 相对 MVC 来说最大的优点是，ViewModel 是独立的，可复用到别的模块，并且更易于做单元测试，而 View 和 ViewController 仅用来做 UI 展示，它与 ViewModel 之间是相互影响的，ViewModel 处理过的数据要能够及时响应到 View，而用户在 View 中做了修改数据的操作后，ViewModel 中对应的数据也应该及时更新，响应式编程方式能够更容易的处理这个过程
响应式编程 响应式编程是一种面向数据及其变化响应的编程方式，它能够将数据、UI事件和异步操作更方便的进行序列化处理，相比传统编程方式来说，它可以使逻辑相关的代码能够紧凑的聚在一起，它通过信号机制来实现，用信号来记录值的变化，并通过信号绑定的方式来响应变化，下面这个例子很好的描述了响应式编程的作用
a = 2 // signal b = 2 // signal c = a + b // signal binding c = 4 b = 3 // c = 5 目前我们在 Swift 项目中选择使用 RxSwift + MVVM 的方式进行开发，使用 RxSwift 需要掌握以下几个概念：</description></item><item><title>iOS 组件化开发</title><link>https://lijingcheng.github.io/posts/ios-componentization/</link><pubDate>Mon, 30 Apr 2018 19:11:27 +0800</pubDate><guid>https://lijingcheng.github.io/posts/ios-componentization/</guid><description>随着 app 功能和体积的增长，也带来了如编译速度变慢、提交代码经常出现冲突、以及业务代码混在一起，开发功能类似的新项目时需要从头搭建等问题，于是很多团队都选择了利用组件化开发来解决这些问题，下面介绍下在组件化开发过程中需要注意哪些地方。
拆分组件 组件即功能组件，模块即业务模块，拆分时要把握好粒度，要考虑到维护成本
每个组件对应一个 project，身为组件的同时还能够独立运行和打测试包
大点的项目除了按框架分层拆分还可以按业务模块拆分，需要把握好拆分粒度
小项目按框架分层拆分就可以了
组件之间的依赖关系 业务模块依赖于框架
业务模块之间避免横向依赖（可适当的有些重复代码或存放重复资源）
禁止框架依赖业务模块
组件化实施 通过 CocoaPods 来实现组件化
Podfile：定义私有库地址和需要依赖的组件及版本
Podspec：定义组件的依赖库、编译设置、以及需要打包的资源及代码，资源包括 xib、国际化文件、assets 等
组件中的资源访问 访问 image、xib、storyboard 时需要指定 bundle，如果项目中使用了 R.swift，可以在各组件中通过以下角本来修改 R.generated.swift 中设置的 bundle，修改后在组件中使用 R.image.xxx()，此代码在组件中是指 main bundle，在主工程中会将其认定为 core bundle。
&amp;#34;$PODS_ROOT/R.swift/rswift&amp;#34; generate &amp;#34;$SRCROOT/R.generated.swift&amp;#34; --hostingBundle MyBundleName 还需要在各组件中正确使用 open、public、private
组件之间的路由跳转 网上有很多关于这方面的文章，我们使用的是一种较简单比较适合我们的方式：Router.open 跳转方法需要传入几个比较重要的参数：name、storyboard、bundle，如果要打开的 ViewController 是通过代码或 xib 实现的，需要在这里指定 name，然后会通过 viewControllerWithClassName 方法得到 VC 对象，如果 ViewController 是定义在 storyboard 里的，那么在跳转时需要指定 storyboard，如果要打开的是别的组件中的 ViewController，还需要指定对应 bundle。</description></item><item><title>开车需要注意的事情〜</title><link>https://lijingcheng.github.io/posts/car/</link><pubDate>Thu, 19 Oct 2017 20:04:50 +0800</pubDate><guid>https://lijingcheng.github.io/posts/car/</guid><description>总结了一些开车时需要注意的事情，希望能帮助到刚拿到驾照的新司机。
起步 不要酒后/疲劳/生气时开车
确认车周围是否有障碍物或人，并系安全带
打左转向灯提醒后方来车，并通过后视镜确认安全后再起步
行车 频繁看后视镜，就象打王者荣耀时看小地图一样
让速不让路，除非前后是能夹死你的大车
变道打转向灯，确认安全后变道不要犹豫，并且小心目标车道左边或右边车道的车也要并进来
不要跟其他车并排行驶
走车道中间，否则会被挤，也不安全
转弯让直行，右转让左转，过路口让行人
遇到紧急情况先踩刹车，在看后视镜
在不确定要踩油门加速的情况下，把脚悬在刹车上
油门和刹车要慢踩慢抬，特别是车上有晕车的人时
不要开太快，十次出事九次快
离路边停的车远点，他们随时可能打开车门，也可能从车前后出来人
经过路口有意识地放开油门或者轻踩刹车，以防有路人或车冲出来
视线被挡时必须慢，例如右面有公交车时，要小心有人从车前跑出来
跟车 保持车距眼光要放远，有车并进来后，及时刹车拉开车距，避免它突然刹车
不跟大车，大车档视线、货车掉东西
不跟出租车，因为它随时会踩刹车
前车刹车你也刹，前车突然变道，最好踩下刹车并同时考虑变道，有可能前方有事故
雨雪天气以及车上满员时要提前踩刹车</description></item><item><title>从 Objective-C 过渡到 Swift</title><link>https://lijingcheng.github.io/posts/swift/</link><pubDate>Fri, 17 Mar 2017 19:10:37 +0800</pubDate><guid>https://lijingcheng.github.io/posts/swift/</guid><description>Swift 不仅支持面向对象和面向协议开发，同时还支持函数式开发，在使用封装继承多态的同时，也可以用协议去组合代码，还可以利用高阶函数去简化代码、组织程序。面向协议开发不仅可以间接实现多继承，还可以使代码编写过程更加灵活，也能够解决面向对象开发带来的冗杂父类问题，在 Swift 中只有引用类型可以使用面向对象开发的继承功能，而引用类型的实例变量会在程序执行过程中因无意修改导致数据异常，此时可用协议替代继承，并且将引用类型改为值类型，便可以大大提高数据的安全性。
Swift 还是一个强类型语言，类型在运行时和编译期间是一致的，这样编译器可以得到足够的信息在生成中间码和机器码时进行优化，并在编译期间完成方法的绑定，可以直接获取方法地址并进行调用。
Hello World print(&amp;#34;Hello world!&amp;#34;) //打印并换行 数据类型 整数 通常使用 Int 来声明整数就可以了，当为了优化内存占用或要处理接口返回的长度明确的数据等情况时可使用显式指定长度的类型，这样可以及时发现值溢出并增强代码可读性。
let age: Int = 4 //常量age在32-bit平台下为Int32,在64-bit下为Int64 var twoThousand = 2_000 //变量twoThousand会被编译器自动推断为Int类型，并且用_增强可读性 浮点数 32/64 位浮点数分别用 Float 和 Double 表示，精度分别为 6/15+ 位数字。
let pi = 3.14159 //浮点数值总是会被推断为Double let a = Int(pi) //自动截断，值为3 let b = Int(exactly: pi) //要求更为精确的转换，当精度有损失，认为转换失败，值为nil 布尔值 let isChild: Bool = true //orfalse 字符 Character 类型通常由编码无关的 Unicode 字符组成
var c: Character = &amp;#34;e&amp;#34; //如果不指定类型，双引号会被推断为字符串类型 Character 可以由一个或多个 Unicode 标量（Scalar）组成</description></item><item><title>使用 Carthage 做依赖管理</title><link>https://lijingcheng.github.io/posts/carthage/</link><pubDate>Fri, 23 Dec 2016 19:18:47 +0800</pubDate><guid>https://lijingcheng.github.io/posts/carthage/</guid><description>Carthage 会在帮你下载完第三方依赖库后，通过 xcodebuild 将其编译成动态库，但它不会像 CocoaPods 那样去修改你的项目文件和编译设置，这些都需要你自己去完成。
Carthage VS CocoaPods CocoaPods 需要我们在本地维护第三方库依赖的 podspec 文件，大部分 pod 命令执行时都会去读取此文件，Carthage 则是去中心化的管理方式，不需要维护这种说明文件，它会去直接下载项目并编译成动态库使用，所以对使用 Carthage 的项目来说，最低系统适配要求 iOS8+
CocoaPods 在执行 pod install 后会帮我们做好所有配置工作，我们只需要用它提供的 workspace 文件打开项目即可，使用 Carthage 的话需要我们自己到项目中进行动态库以及打包资源的配置，但是好处是项目配置信息相对 CocoaPods 来说较干净
Carthage 使用的是动态库方式，所以无法进行调试，看不到源码，但带来的好处是编译速度的提高
Carthage 的下载源目前仅支持 GitHub（GitHub.com 和 GitHub Enterprise），CocoaPods 除了 GitHub，还支持我们托管在公司的 Git 仓库，还有本地路径
目前支持 CocoaPods 的第三方库比 Carthage 要多一些
我们可以在一个项目里同时使用 CocoaPods 和 Carthage，可以用 Carthage 管理比较成熟并且不需要调试的第三方库，用来提高编译速度，再用 CocoaPods 管理其它有可能需要进行代码调试的第三方库，还可以用来在组件化开发中做依赖设置。
安装 Carthage 建议通过 HomeBrew 安装</description></item><item><title>使用 xcodebuild 打包 IPA 并上传蒲公英和 TestFlight</title><link>https://lijingcheng.github.io/posts/xcodebuild/</link><pubDate>Mon, 05 Dec 2016 18:49:45 +0800</pubDate><guid>https://lijingcheng.github.io/posts/xcodebuild/</guid><description>xcodebuild 是苹果提供的项目自动构建工具，包含在 Command Line Tools 中，可以完成 iOS 项目的编译、打包和签名等工作。
shell script 是一种命令语言，有点像 Windows 下的批处理，但更强大，它可以跑在 Linux/Unix 系统的 shell 程序中。
为什么要用 xcodebuild 通过 Xcode 对项目进行编译打包，并将 IPA 分发给测试人员这一过程操作步骤多并繁琐，而在 shell 脚本中使用 xcodebuild 命令执行这一过程便会非常方便快捷，特别是当项目进入测试阶段，每天都会打一个或多个测试包时，使用脚本进行自动化打包能够大大提高我们的工作效率。
以前的作法 AFNetworking 的作者 mattt 曾经提供了一个名为 shenzhen 的打包服务，使用起来非常简单方便，并且能够在打包后上传到很多分发平台上，可惜已经有两年多没有再维护了。
造个轮子 因为打包脚本写起来比较简单，并且它也会随着 Xcode 的发展而改变，所以在这里我们还是选择自己写一个脚本使用并维护，下面的介绍不会太详细，如果有更多需求可以使用以下命令来查看帮助，并修改脚本。
xcodebuild --help 完成打包并分发这一过程通常分为四个步骤： &amp;ldquo;build 工程 -&amp;gt; 生成 xcarchive 文件 -&amp;gt; 生成 ipa 文件 -&amp;gt; 上传到分发平台&amp;rdquo;
完整脚本 新建 xxx.sh 文件，然后将下面脚本复制过去，如果你也在用 CocoaPods，并且只需要打 Release 包，那么只需要用蒲公英提供给你的 userKey 和 apiKey 替换掉脚本里的就可以了。
#!/bin/sh ########################################################################## ###### 1.执行 chmod +x .</description></item><item><title>iOS 开发 Tips</title><link>https://lijingcheng.github.io/posts/ios-tips/</link><pubDate>Thu, 09 Jun 2016 10:58:59 +0800</pubDate><guid>https://lijingcheng.github.io/posts/ios-tips/</guid><description>用模拟器调试动画功能时，让动画执行的慢一些
模拟器菜单：Debug -&amp;gt; Show Animations 取两位整数，不够补 0
NSLog(@&amp;quot;%@&amp;quot;, [NSString stringWithFormat:@&amp;quot;%02d月&amp;quot;, 3]); 解码 cms 加密后的授权文件
终端：security cms -D -i example.mobileprovision 查找代码中的中文字符串，做国际化适配时会用到
Xcode左侧导航处：Find -&amp;gt; Regular Expression，然后输入 @&amp;quot;[^&amp;quot;]*[\u4E00-\u9FA5]+[^&amp;quot;\n]*?&amp;quot; 忽略第三方 SDK 文档中的警告
build settings -&amp;gt; Other Warning Flags -&amp;gt; -Wno-documentation 自定义 leftBarButtonItem 后，左滑返回手势失效
self.navigationController.interactivePopGestureRecognizer.delegate = self; 在 xib 中给 UILabel 或 UITextView 设置多行文字
输入文字后，用 control + enter 来插入换行符，相当于在代码中添加 \n 禁用 UIButton 并且颜色不变灰
button.userInteractionEnabled = NO; 修改约束后，用动画展示效果
[UIView animateWithDuration:0.3f animations:^{ [myView layoutIfNeeded]; }]; 快速定位视图约束警告
po [[UIWindow keyWindow] _autolayoutTrace] 给 UIView 设置透明度后不影响 subviews</description></item><item><title>代码重构</title><link>https://lijingcheng.github.io/posts/refactor/</link><pubDate>Mon, 09 May 2016 10:50:10 +0800</pubDate><guid>https://lijingcheng.github.io/posts/refactor/</guid><description>代码重构 就是在不改变软件系统外部行为的前提下，改善它的内部结构。Martin Flower 在《重构》中有一句经典的话：&amp;ldquo;任何一个傻瓜都能写出计算机可以理解的程序，只有写出人类容易理解的程序才是优秀的程序员。&amp;rdquo;
重构原则 随着时间推移，需求的频繁变化等原因都会导致代码质量逐步下降，所以持续重构就变得越来越重要，并且重构对开发人员技术水平及经验的要求会更高一些，下面列出几条重构原则：
要充分理解旧代码后再进行修改，模块之间过度耦合导致牵一发而动全身，不易控制影响范围，有时代码摆放顺序的修改都会造成问题
优先重构经常修改的部分，如果代码一两年都没有修改过，那么说明改动的收益很小
重构可能需要很长时间，并且不是非要一次做完，主要取决于团队对于风险的容忍程度
删除无用代码是提高代码可维护性最有效的方式
小范围重构，当重构后会导致大量测试工作时，需要谨慎决定是否有必要重构
要构建可扩展系统，我们需要认同错误的不可避免性，有时候避免这些错误会带来高昂的成本，因此我们不妨将注意力集中在对问题的快速检测以及出现后的应对措施上
哪种代码需要重构 臃肿的类：一个类应该只做一件事，可通过一些设计模式去拆分
长方法：方法应尽量短小，专注一个功能点，并且要放在合适的类里
重复代码：往往由于开发人员对框架不熟悉，也有个别不讲究的情况
方法有多个参数：可通过提取成类对象或字典解决，个别情况也可拆分方法
魔鬼数字：尽量用常量去定义数字，或在使用处添加注释说明用意
模糊的命名：要做到见名知意
if/else 嵌套过多：尽量不超过3层，如果不能简化逻辑，可通过拆分方法或添加注释方式解决
Xcode 提供的重构功能 跟别的开发工具相比 Xcode 提供的重构功能简直弱暴了，不过有总比没有好，Xcode 提供了以下几个重构功能，从菜单栏中进入：Edit -&amp;gt; Refactor，或在代码上右键，然后选择 Refactor
Rename：重命名类、方法、变量
Extract：将方法中的一段代码抽取为一个独立的方法
Create Superclass：给当前选中的类创建父类</description></item><item><title>了解 Block</title><link>https://lijingcheng.github.io/posts/block/</link><pubDate>Thu, 03 Dec 2015 15:09:29 +0800</pubDate><guid>https://lijingcheng.github.io/posts/block/</guid><description>Block 是 Objective-C 语言创建闭包的方式，从 iOS4 开始 block 便在很多场景下替代了 delegate，相对来说 block 的最大优点就是可以使代码集中在一起，提高可读性，但也提高了代码调试的复杂度，并增加了循环引用产生的场景。
一些概念 Block 会使 app 运行成本增高，因为 delegate 只是保存了一个对象指针，而 block 本身实际上就是对象，它会被编译成 struct 并为其内容分配空间，struct 内容主要包括 isa 指针、block 对应实现函数的地址以及 block 复制过来的变量，这些内容也会随着需要从栈内存复制到堆内存。
isa：指向 block 对应的 Class
_NSConcreteGlobalBlock：定义在全局区的 block 会作为代码片段存在 _NSConcreteStackBlock：定义在方法中的 block 会保存在栈中，当函数返回时被销毁 _NSConcreteMallocBlock：为了增加 block 的生命周期，可以用 copy 方法将其复制到堆中，如果 block 已经在堆里了，再次进行 copy 只会增加引用计数 IMP：block 块中的代码会作为方法形式存在，IMP 指向方法地址
复制的变量：block 能够读取它所在函数的内部变量，该变量会被复制到 struct 中，默认是值复制，不能修改，加上 __block 修饰的是引用复制，可以修改
简单例子 __block NSInteger mutiplier = 7; // 用 __block 修饰后，在 block 里就可以修改 mutiplier 的值 // 定义名为 myBlock 的代码块，返回值类型为 NSInteger，并有一个名为 num 的 NSInteger 型参数 NSInteger (^myBlock)(NSInteger) = ^(NSInteger num){ mutiplier = 3; return num * mutiplier; }; NSLog(@&amp;#34;%ld&amp;#34;, myBlock(3)); // 像调用函数一样使用 block 循环引用 对象之间相互持有便会造成循环引用问题，下面用一个经典例子看一下解决方式</description></item><item><title>Objective-C Runtime 开发</title><link>https://lijingcheng.github.io/posts/runtime/</link><pubDate>Mon, 21 Sep 2015 14:30:27 +0800</pubDate><guid>https://lijingcheng.github.io/posts/runtime/</guid><description>Runtime 是使用 C 和汇编实现的运行时代码库，Objective-C 中有很多语言特性都是通过它来实现。了解 Runtime 开发可以帮助我们更灵活的使用 Objective-C 这门语言，我们可以将程序功能推迟到运行时再去决定怎么做，还可以利用 Runtime 来解决项目开发中的一些设计和技术问题，使开发过程更加具有灵活性。
一些关键字 self：类的隐藏参数变量，指向当前调用方法的对象
super：是编译器的标示符，通过 super 调用方法会被翻译成 objc_msgSendSuper(self, _cmd,&amp;hellip;)
SEL：以方法名为内容的 C 字符串
IMP：指向方法实现的函数指针
id：指向类对象或实例对象的指针
isa：为 id 对象所属类型 (objc_class)，Objc 中的继承就是通过 isa 指针找到 objc_class，然后再通过 super_class 去找对应的父类
metaclass：在 Objc 中，类本身也是对象，实例对象的 isa 指向它所属的类，而类对象的 isa 指向元类 (metaclass)，元类的 isa 直接指向根元类，根元类的isa指向它自己，它们之间的关系如下图所示。
消息传递 (Messaging) Objective-C 对于调用对象的某个方法这种行为叫做给对象发送消息，实际上就是沿着它的 isa 指针去查找真正的函数地址。下面我们来了解一下这个过程：
我们写一个给对象发送消息的代码
[array insertObject:obj atIndex:5]; 编译器首先会将上面代码翻译成这种样子</description></item><item><title>iOS 内存管理</title><link>https://lijingcheng.github.io/posts/ios-memory/</link><pubDate>Sun, 12 Jul 2015 15:07:54 +0800</pubDate><guid>https://lijingcheng.github.io/posts/ios-memory/</guid><description>内存管理 指程序在运行时申请内存，并在使用完后释放内存的过程，内存管理不当造成的主要问题便是内存泄漏和过度释放，虽然 ARC 使我们可以不去关注内存管理上的一些细节问题，但掌握一些相关知识还是很有必要的。
一些概念 MRC：manual reference counting，自己编写内存管理代码（retain、release、autorelease&amp;hellip;）
ARC：automatic reference counting，编译器会在编译阶段为代码加上优化过的内存管理代码，这样就可以让我们不必花费大量时间在内存管理上面，可以将更多的精力放在业务代码上。
内存泄漏：不再使用的对象内存没有释放掉，将导致内存占用无限增长，即便是使用 ARC，也会因为循环引用问题而造成内存泄露，并且还要注意与 CoreFoundation 对象进行桥接时要手动释放内存。
内存过度释放：释放了仍需要使用中的对象，将有可能导致应用崩溃
内存管理规则 内存管理是建立在对象的拥有关系上的，当拥有对象后就要负责释放它，并且不要释放非自己持有的对象，具体规则如下：
拥有对象所有权
通过 alloc/new/copy/mutableCopy 创建对象 在某些场景里避免一个对象被移除，可以对它进行 retain Student * stu1 = [[Student alloc] init]; Student * stu2 = [stu1 retain]; 放弃对象拥有权
立即释放：给对象发送一个 release 消息 延迟释放：给对象发送一个 autorelease 消息 + (Student *)studentWithName:(NSString *)name { Student *stu = [[Student alloc] initWithName:name]; return [stu autorelease]; } 实现 dealloc 方法来释放对象自身内存与它所持有的资源，此方法由系统在该对象被销毁时自动调用</description></item><item><title>iOS 多线程开发</title><link>https://lijingcheng.github.io/posts/ios-thread/</link><pubDate>Wed, 03 Jun 2015 15:07:00 +0800</pubDate><guid>https://lijingcheng.github.io/posts/ios-thread/</guid><description>合理的线程分配能够提高程序的执行效率和资源利用率，在 iOS 开发中通常使用 GCD 或 Operation Queue 来操作线程，GCD 基于 C API，Operation Queue 是在 GCD 基础上实现的，效率上较 GCD 会差一点点，但代码可读性和易用性较高，简单的任务可用 GCD 去实现，复杂一些的还是推荐使用 Operation Queue 来处理。微小的性能提升远不如写出可维护性高的代码来的实在。
一些概念 进程和线程
进程是一个可执行程序，它拥有自己的地址空间，至少有一个线程，也可以包含多个线程，进程内的线程对于其他进程不可见 线程是执行程序最基本的单元，在进程中负责执行任务并使用进程的地址空间，每个进程至少有一个线程（主线程） 主线程和子线程
主线程是随着进程的创建而创建的，主线程结束，其他线程也会结束 子线程由其他线程创建，一般子线程退出不会影响主线程 同步和异步
同步任务在执行过程中会阻塞当前线程，直到任务执行完毕 异步任务在执行过程中不会阻塞当前线程 串行队列和并行队列
串行队列中装载的线程是按进队列顺序一个一个执行 并行队列中装载的线程可以一起执行，可以通过设置最大并发数，限制同时最多执行几个线程 并发和并行
并发在多核设备上是真正意义上的多任务同时运行，而在单核设备上是以分时共享的方式同时执行多个任务，需要先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程，因为这个过程很快所以会给我们并发执行的错觉 并行是真正意义上的多任务同时运行 优先级和优先级反转
正常情况下优先级高的任务会比优先级低的先执行 优先级反转指程序在运行时，低优先级的任务由于某种原因不能释放掉锁，所以阻塞了高优先级的任务，而其他不需要该共享资源的低优先级任务会在高优先级任务之前执行，从而反转了任务的优先级。设置任务的优先级会让本来就复杂的并行编程变得更加复杂和不可预见，所以建议只使用默认优先级。 生产者和消费者模式：是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。我们还可以使用多个线程来生产数据，同样可以使用多个消费线程来消费数据。而更复杂的情况是，消费者消费的数据，有可能需要继续处理，于是消费者处理完数据之后，它又要作为生产者把数据放在新的队列里，交给其他消费者继续处理。
为了防止多个线程抢夺同一个资源造成数据安全问题可采取以下措施</description></item><item><title>iOS 应用的生命周期</title><link>https://lijingcheng.github.io/posts/ios-life/</link><pubDate>Sat, 28 Mar 2015 11:23:29 +0800</pubDate><guid>https://lijingcheng.github.io/posts/ios-life/</guid><description>程序的生命周期是指应用程序从启动到结束整个阶段的全过程，点击应用图标打开程序，系统会首先通过 main 函数进行相关设置，然后通过 RunLoop 保持程序能够始终运行并监听处理分发事件，当没有事件发生时 RunLoop 便处于睡眠状态，节省资源。当发生事件后，RunLoop 将事件对象分发给相应视图处理。当用户按下 Home 键，应用会在进入后台后短暂运行，直到被系统挂起。
main 函数 main 函数是 app 的入口函数
int main(int argc, char * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } } 在进入 main 函数之前，系统会由 dyld（the dynamic link editor）加载相关动态链接库，然后再初始化 runtime 环境，并由 runtime 触发 + load 方法，所以不要在 load 方法里执行耗时任务，否则会影响启动时间。
@autoreleasepool 用来管理主线程中标记为自动释放的对象。
UIApplicationMain 根据传入参数以及 info.plist 文件来初始化 app
argc 和 argv 参数在 iOS 应用中用不到 第三个参数为 app 的首要类名，用来监听并管理应用的生命周期，默认使用 UIApplication 最后一个参数为 app 首要类的代理类，它负责实际处理 UIApplication 监听到的应用程序生命周期事件，具体参考 UIApplicationDelegate main 函数会在初始化 app 后启动主线程及 RunLoop RunLoop RunLoop 能够保持程序始终运行并监听处理分发事件，当没有事件发生时进入休眠状态，有事件发生时系统会将接收到的事件放在一个队列里，然后唤醒 RunLoop 依次处理事件，使用队列不仅可以解决线程同步问题也促使我们要把更新 UI 的代码放在主线程中运行，以免由于多个线程抢占资源产生奇怪的问题。RunLoop 可以接收的事件来自两种不同的来源，分别是输入源和定时源，输入源传递异步事件，事件通常来自于其他线程或程序，如一些 UI 事件等。定时源则传递同步事件，发生在特定时间或者重复的时间间隔，如 NSTimer。</description></item><item><title>在 Git 环境下维护多个 SSH Keys</title><link>https://lijingcheng.github.io/posts/sshkeys/</link><pubDate>Sun, 01 Mar 2015 18:11:42 +0800</pubDate><guid>https://lijingcheng.github.io/posts/sshkeys/</guid><description>SSH Key 登录方式可以避免密码在网络中传输，也就保证了登录过程的安全，也不会因此受到中间人攻击，如果在 SSH 密钥登录基础上再加上密码短语 （passphrase）的使用，安全性便会再次提高。
作为一个程序猿，我们经常会往公司的 Git 服务器上提交代码，还有很多猿在 GitHub 上也有自己的开源项目，不管是公司的服务器还是 GitHub 服务器都会在你提交代码时通过维护在服务器上的公钥进行验证，如果你希望能够以不同身份向不同服务器提交代码，那么你需要在机器上维护多个 SSH Key，并且将不同的公钥添加到不同的服务器中。
下面介绍下在已经拥有一个用于公司服务器的 SSH Key 后，如何再添加一个用于 GitHub 的 SSH Key。
首先进入 .ssh 目录
cd ~/.ssh 创建用于 GitHub 的 SSH Key，根据提示将名字设置为 id_rsa_github
ssh-keygen -t rsa -C &amp;quot;注册 GitHub 时用的 Email&amp;quot; 因为 Git 默认只读取 id_rsa，为了让 SSH 识别新的私钥，需将 id_rsa_github 添加到 SSH Agent 中
ssh-add id_rsa_github 将 id_rsa_github.pub 中的公钥复制到 GitHub 帐户中，并为 GitHub 项目指定提交代码时使用哪个用户，简单的方式是打开 SourceTree 中的项目，然后在“设置 -&amp;gt; 高级”中直接修改用户名和邮箱，也可以打开 ~/.ssh 目录下的 config 文件，修改 [user] 部分，指明服务器及所使用的密钥</description></item><item><title>使用 CocoaPods 做依赖管理</title><link>https://lijingcheng.github.io/posts/cocoapods/</link><pubDate>Wed, 11 Feb 2015 15:10:58 +0800</pubDate><guid>https://lijingcheng.github.io/posts/cocoapods/</guid><description>CocoaPods 可以为 iOS 项目使用的第三方类库和我们自己的私有类库提供依赖管理，我们只需要告诉它要使用的类库名称和版本号，然后再执行一条命令，它就会自动将这个类库的源码下载到本地，并且为工程设置好相应的系统依赖和编译项。
准备工作 由于 CocoaPods 是用 ruby 写的，所以需要有 ruby 环境和 git 环境，尽量使用 rvm 来管理 ruby，可避免因权限导致的 gem install 失败问题。
sudo gem update –system 为了提高下载速度，还需要将 ruby 源更改为国内地址
gem sources -a https://gems.ruby-china.com/ -r https://rubygems.org/ gem sources -l 安装并使用 CocoaPods 安装 CocoaPods
sudo gem install cocoapods (更新也用这个) 下载 CocoaPods 维护的所有 podspec 文件到&amp;quot;~/.cocoapods/repos/master/Specs&amp;rdquo;，podspec 文件主要用来描述依赖库的名称、版本、作者、下载地址等信息。通过 CocoaPods 下载第三方类库，其实就是根据我们指定的类库名称找到相关的 podspec，然后再根据 podspec 文件中指定的地址去下载。
pod setup 查看 CocoaPods 管理的依赖库信息
pod search 依赖库的名字 新建 Podfile 文件，此文件用于配置项目所需要使用的依赖库
cd &amp;quot;项目根目录&amp;quot; pod init 打开 Podfile 文件，按下面内容配置依赖关系，Podfile 的更详细配置方法可参照官方文档</description></item><item><title>GitHub Pages + Octopress 搭博客</title><link>https://lijingcheng.github.io/posts/create-blog/</link><pubDate>Sun, 04 Jan 2015 14:51:02 +0800</pubDate><guid>https://lijingcheng.github.io/posts/create-blog/</guid><description>Github Pages 可用来搭建静态网站，它提供了免费域名、空间、无限流量，并且在世界各地都有较好的访问速度。
Octopress 是开源的静态博客系统，可用来为静态网站提供所需的 HTML。
准备工作 在 GitHub 上新建名为 yourname.github.io 的版本库，之后可通过 yourname.github.io 域名来访问博客，还需要有 git 和 ruby 环境，尽量使用 rvm 管理 ruby，可避免因权限导致的 gem install 失败问题，记得要设置某个版本为当前使用版本，最后还需要更改 ruby 源，可提高下载速度
gem sources -a https://gems.ruby-china.com/ -r https://rubygems.org/ gem sources -l Octopress 环境搭建 安装 Octopress
git clone git://github.com/imathis/octopress.git octopress 安装所需依赖
cd octopress sudo gem install bundler bundle install 安装默认模板
rake install 关联 GitHub Pages
rake setup_github_pages git@github.com:yourname/yourname.github.io.git 配置 Octopress 时建议删除 HTML 和 CSS 中用不到的东西，可提高访问速度
写博客并发布 新建文章（博客存储为 markdown 文件，位于 \octopress\source\_posts 目录下）</description></item><item><title/><link>https://lijingcheng.github.io/posts/ios-request/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lijingcheng.github.io/posts/ios-request/</guid><description>接口请求过程
一次接口请求的生命周期 从购卡接口的调用来看一下一次接口请求设及到的知识点
HTTPS tcp 三次握手 重要数据 AES 加密 请求参数的 MD5 验签 request/response 数据加密 RequestAdapter 的设计模式应用 https 中 tcp 和数字证书的知识（三次握手，四次挥手） 数据返回时对于枚举字段在 Swift 中有坑的解决 tcp 四次挥手 （写的时候可以参考在浏览器打开网页经历了什么，也可以是以万达项目的角度讲，还可以细到讲网络库）
MD5 MD5 是一种生成信息摘要的算法，可以从任意长度的明文字符串生成128位的哈希值。常用于对接口传输数据做验签，以保证数据传输安全，验签过程：
1.发送方和请求方约定相同的字符串拼接规则，约定相同的密钥。 2.第三方平台接到支付请求，按规则拼接业务参数和密钥，利用MD5算法生成Sign。 3.用第三方平台自己生成的Sign和请求发送过来的Sign做对比，如果两个Sign值一模一样，则签名无误，如果两个Sign值不同，则信息做了篡改。这个过程叫做验签。
MD5 是可以破解的
破解方式并不是将 MD5 后的数据摘要还原成明文，因为128位的摘要是有穷的，而原文数量是无穷的，每一个摘要都可以由若干个原文通过Hash得到。所以对于 MD5 的破解都是通过碰撞的方式实现，也就是字符串生成的 MD5 摘要一样，
设MD5的哈希函数是H（X），那么： H(A) = M H(B) = M 任意一个B即为破解结果。B有可能等于A，也可能不等于A。
MD5碰撞通常用于登陆密码的破解。应用系统的数据库中存储的用户密码通常都是原密码的MD5哈希值
常用碰撞方法
暴力枚举法：通过枚举出所有原文并计算哈希，然后再看哪个哈希和给定的摘要一致，这种办法时间复杂度极度。 字典法：用现成的字典存储尽可能多的原文和哈希值，然后用指定的信息摘要去查找对应的原文，这种办法占空间大，但速度快 彩虹表：过于复杂。。。 差分攻击：过于复杂。。。 对于单机来说，暴力枚举法的时间成本很高，字典法的空间成本很高。但是利用分布式计算和分布式存储，仍然可以有效破解MD5算法。因此这两种方法同样被黑客们广泛使用。
SHA 和 MD5 相似，也是一种生成信息摘要的哈希算法，MD5 的摘要长度为 128bit，SHA-1 的摘要长度为 160bit，虽然只多出了 32bit，但不同明文的碰撞几率降低了2^32 = 324294967296倍。2005 年时人们就研究出了破解 SHA-1 的办法，目前常用的有 SHA-256 和 SHA-512，信息摘要越长，发生碰撞的几率就越低，破解的难度就越大。但同时，耗费的性能和占用的空间也就越高。所以要按需要去选择。如果只是验证数据完整性，SHA-256 就足够了。如果希望安全性更高一些还可以考虑 MD5 和 SHA256 结合起来使用，可以将明文同时生成 MD5 摘要和 SHA-256 摘要，然后按规则各取一部分进行摘要合成，例如用 MD5 摘要的前 16 位字符拼接 SHA-256 摘要的后 32 位字符。</description></item></channel></rss>