<!doctype html><html lang=zh-cn><head><title>App 接口缓存策略 // 风行's Blog</title><meta charset=utf-8><meta name=generator content="Hugo 0.61.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="风行"><meta name=description content><link rel=stylesheet href=https://lijingcheng.github.io/css/main.min.61bb32028587f24ca28522d8d197970c7ef33284e5fffb45a75fcbbb2dbc4dcb.css><meta name=twitter:card content="summary"><meta name=twitter:title content="App 接口缓存策略"><meta name=twitter:description content="目标 降低后端服务压力，减少重复请求，还能通过使用本地缓存数据来提升页面加载速度。
缓存策略 App 使用原生缓存机制（URLCache），可支持强缓存和协商缓存（ETag / Last-Modified）。由于协商缓存仍会触发请求到后端，可节省流量，但对减轻服务器压力作用有限，因此先只做强缓存。
强缓存（Strong Cache） 服务端在 API 返回的 Header 中添加 Cache-Control: max-age=60
  App 在 60 秒内对该 API 不再请求后端，直接使用本地缓存。（API 可根据情况分别设置 max-age 或者 no-cache）
  缓存过期后再次请求时才访问后端服务。
  仅缓存 GET 类型接口数据，不缓存图片或文件。
  协商缓存（ETag / Last-Modified） App 请求时在 Header 中附加 If-None-Match: <etag>
  后端若数据未变化，返回 304 Not Modified（无 body），App 使用本地缓存内容
  数据有变化时返回新数据，同时更新 etag
  协商缓存能节省流量，但仍会触发请求到服务端，对减轻服务器压力效果有限
  App 实践 设置独立缓存区 创建独立缓存实例，不使用系统提供的全局缓存对象，避免影响三方库或默认 URLSession 的缓存行为，确保缓存策略可控。（WebView 的缓存是独立的，即使使用全局缓存对象也不会影响 H5 页面）"><meta property="og:title" content="App 接口缓存策略"><meta property="og:description" content="目标 降低后端服务压力，减少重复请求，还能通过使用本地缓存数据来提升页面加载速度。
缓存策略 App 使用原生缓存机制（URLCache），可支持强缓存和协商缓存（ETag / Last-Modified）。由于协商缓存仍会触发请求到后端，可节省流量，但对减轻服务器压力作用有限，因此先只做强缓存。
强缓存（Strong Cache） 服务端在 API 返回的 Header 中添加 Cache-Control: max-age=60
  App 在 60 秒内对该 API 不再请求后端，直接使用本地缓存。（API 可根据情况分别设置 max-age 或者 no-cache）
  缓存过期后再次请求时才访问后端服务。
  仅缓存 GET 类型接口数据，不缓存图片或文件。
  协商缓存（ETag / Last-Modified） App 请求时在 Header 中附加 If-None-Match: <etag>
  后端若数据未变化，返回 304 Not Modified（无 body），App 使用本地缓存内容
  数据有变化时返回新数据，同时更新 etag
  协商缓存能节省流量，但仍会触发请求到服务端，对减轻服务器压力效果有限
  App 实践 设置独立缓存区 创建独立缓存实例，不使用系统提供的全局缓存对象，避免影响三方库或默认 URLSession 的缓存行为，确保缓存策略可控。（WebView 的缓存是独立的，即使使用全局缓存对象也不会影响 H5 页面）"><meta property="og:type" content="article"><meta property="og:url" content="https://lijingcheng.github.io/posts/api-cache/"><meta property="article:published_time" content="2025-10-22T11:23:29+08:00"><meta property="article:modified_time" content="2025-10-22T11:23:29+08:00"></head><body><header class=app-header><a href=https://lijingcheng.github.io><img class=app-header-avatar src=/images/avatar.png alt=风行></a><h1>风行's Blog</h1><p>Do not repeat yourself!</p><div class=app-header-social><a target=_blank href=https://github.com/lijingcheng rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a target=_blank href=https://www.instagram.com/bj_lijingcheng/ rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-instagram"><title>instagram</title><rect x="2" y="2" width="20" height="20" rx="5" ry="5"/><path d="M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37z"/><line x1="17.5" y1="6.5" x2="17.5" y2="6.5"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>App 接口缓存策略</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Oct 22, 2025</div></div></header><div class=post-content><h2 id=heading>目标</h2><p>降低后端服务压力，减少重复请求，还能通过使用本地缓存数据来提升页面加载速度。</p><h2 id=heading-1>缓存策略</h2><p>App 使用原生缓存机制（URLCache），可支持强缓存和协商缓存（ETag / Last-Modified）。由于协商缓存仍会触发请求到后端，可节省流量，但对减轻服务器压力作用有限，因此先只做强缓存。</p><h3 id=strong-cache>强缓存（Strong Cache）</h3><p>服务端在 API 返回的 Header 中添加 <code>Cache-Control: max-age=60</code></p><ul><li><p>App 在 60 秒内对该 API 不再请求后端，直接使用本地缓存。（API 可根据情况分别设置 max-age 或者 no-cache）</p></li><li><p>缓存过期后再次请求时才访问后端服务。</p></li><li><p>仅缓存 GET 类型接口数据，不缓存图片或文件。</p></li></ul><h3 id=etag--last-modified>协商缓存（ETag / Last-Modified）</h3><p>App 请求时在 Header 中附加 <code>If-None-Match: &lt;etag></code></p><ul><li><p>后端若数据未变化，返回 304 Not Modified（无 body），App 使用本地缓存内容</p></li><li><p>数据有变化时返回新数据，同时更新 etag</p></li><li><p>协商缓存能节省流量，但仍会触发请求到服务端，对减轻服务器压力效果有限</p></li></ul><h2 id=app->App 实践</h2><h3 id=heading-2>设置独立缓存区</h3><p>创建独立缓存实例，不使用系统提供的全局缓存对象，避免影响三方库或默认 URLSession 的缓存行为，确保缓存策略可控。（WebView 的缓存是独立的，即使使用全局缓存对象也不会影响 H5 页面）</p><h3 id=heading-3>缓存大小控制</h3><p>推荐设置：内存缓存：20 MB，磁盘缓存：100 MB</p><h3 id=heading-4>缓存清理策略</h3><p>缓存目录命名包含 App 版本号，例如： AppAPICache_v1.0.0，每次 App 冷启动后检查当前版本是否为新版本，当用户升级 App 版本时清理旧版本缓存数据，清理操作异步执行，避免阻塞其它启动任务。版本化缓存管理可防止 App 强制升级后使用旧缓存，从而避免缓存数据结构与新版本 UI 页面不匹配引发的 Crash 或 UI 异常。</p><h3 id=ios->iOS 代码样例（其它平台相似）</h3><p><strong>根据版本判断来清缓存</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CacheVersionManager</span> {

    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>let</span> lastVersionKey = <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>AppLastVersionKey</span><span style=color:#e6db74>&#34;</span>

    <span style=color:#75715e>//</span><span style=color:#75715e>/</span><span style=color:#75715e> </span><span style=color:#75715e>检</span><span style=color:#75715e>查</span><span style=color:#75715e>是</span><span style=color:#75715e>否</span><span style=color:#75715e>是</span><span style=color:#75715e> </span><span style=color:#75715e>A</span><span style=color:#75715e>p</span><span style=color:#75715e>p</span><span style=color:#75715e> </span><span style=color:#75715e>升</span><span style=color:#75715e>级</span><span style=color:#75715e>后</span><span style=color:#75715e>的</span><span style=color:#75715e>首</span><span style=color:#75715e>次</span><span style=color:#75715e>启</span><span style=color:#75715e>动</span>
    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>checkAndClearCacheIfNeeded</span>(cache: URLCache) {
        <span style=color:#66d9ef>let</span> currentVersion = Bundle.main.infoDictionary?[<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>CFBundleShortVersionString</span><span style=color:#e6db74>&#34;</span>] <span style=color:#66d9ef>as</span>? String ?? <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>0</span><span style=color:#e6db74>&#34;</span>
        <span style=color:#66d9ef>let</span> lastVersion = UserDefaults.standard.string(forKey: lastVersionKey)

        <span style=color:#66d9ef>if</span> lastVersion <span style=color:#f92672>!=</span> currentVersion {
            cache.removeAllCachedResponses()
            
            UserDefaults.standard.<span style=color:#66d9ef>set</span>(currentVersion, forKey: lastVersionKey)
        }
    }
}
</code></pre></div><p><strong>缓存规则设置</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>let</span> urlCache = URLCache(memoryCapacity: <span style=color:#ae81ff>20</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1024</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1024</span>, diskCapacity: <span style=color:#ae81ff>100</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1024</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1024</span>, diskPath: <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>AppAPICache_v</span><span style=color:#e6db74>\(</span>App.currentVersion<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)

<span style=color:#66d9ef>let</span> config = URLSessionConfiguration.<span style=color:#66d9ef>default</span>
config.requestCachePolicy = .useProtocolCachePolicy
config.urlCache = urlCache
        
CacheVersionManager.checkAndClearCacheIfNeeded(cache: urlCache)
</code></pre></div><p><strong>测试验证</strong></p><p>通过抓包观察是否频繁发出请求，或在代码中打印 <code>response.metrics?.transactionMetrics.last?.resourceFetchType</code> 看数据来源。</p><h2 id=heading-5>总结</h2><p>App 仅做强缓存机制支持，具体哪些 GET 接口需要缓存以及缓存时间由后端 API 控制，后端调整缓存策略后 App 无需发版即可生效，相比在 App 内写死指定 API 及缓存时长，更加灵活和安全。</p></div><div class=post-footer></div></article></main></body></html>