<!doctype html><html lang=zh-cn><head><title>iOS 应用的开发设计 // 风行's Blog</title><meta charset=utf-8><meta name=generator content="Hugo 0.61.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="风行"><meta name=description content><link rel=stylesheet href=https://lijingcheng.github.io/css/main.min.61bb32028587f24ca28522d8d197970c7ef33284e5fffb45a75fcbbb2dbc4dcb.css><meta name=twitter:card content="summary"><meta name=twitter:title content="iOS 应用的开发设计"><meta name=twitter:description content="一个 app 从设计到发布应用商店会经历需求设计、UI设计、架构设计、开发、优化、测试等流程，每个环节做的好与坏都会影响到整个 app 的质量，作为开发人员，不仅要对需求以及 UI 的合理性进行评审，还要保证提供给测试的代码是经过自测并且覆盖了相关测试用例，更重要的是要做好架构设计、开发以及优化这三个环节。
架构设计 架构设计可以以业务为驱动，按照最适合自己的方式去设计，设计思路和方法尽量统一，同类型问题用同样方式去解决，下面几点是我认为比较重要的：
  关注分离
将系统分解为多个模块并各司其职，纵向分层，横向拆分业务。
  高内聚
一个模块只完成一个功能，并合理有度的进行封装。
  松耦合
依赖关系越少越好，尽量不横向依赖，不跨层访问。继承是紧耦合的一种操作，它通常与多态一起存在，如果仅仅是为了代码重用而做的继承还不如用组合。
  适度设计
对业务方该限制的地方要进行限制，该灵活的地方也要给业务方创造灵活实现的条件，架构的设计要保持一定量的超前性而做到易扩展，但不要设计过度，避免多做无用功而增加框架复杂度。好的架构是随着时间而更新的，而不是一开始就设计好了一切。
  技术选型
不要仅是为了体验新技术而改变现有架构，等别人把坑踩平后再根据团队及业务情况考虑是否使用，技术本身没有什么好不好，只有适合不适合。
  框架是服务开发人员的，需要满足通用性和易用性两个要求，其中易用性更重要
开发 MVVM MVVM 相对 MVC 来说最大的优点是，ViewModel 是独立的，可复用到别的模块，并且更易于做单元测试，而 View 和 ViewController 仅用来做 UI 展示，它与 ViewModel 之间是相互影响的，ViewModel 处理过的数据要能够及时响应到 View，而用户在 View 中做了修改数据的操作后，ViewModel 中对应的数据也应该及时更新，响应式编程方式能够更容易的处理这个过程
响应式编程 响应式编程是一种面向数据及其变化响应的编程方式，它能够将数据、UI事件和异步操作更方便的进行序列化处理，相比传统编程方式来说，它可以使逻辑相关的代码能够紧凑的聚在一起，它通过信号机制来实现，用信号来记录值的变化，并通过信号绑定的方式来响应变化，下面这个例子很好的描述了响应式编程的作用
a = 2 // signal b = 2 // signal c = a + b // signal binding c = 4 b = 3 // c = 5 目前我们在 Swift 项目中选择使用 RxSwift + MVVM 的方式进行开发，使用 RxSwift 需要掌握以下几个概念："><meta property="og:title" content="iOS 应用的开发设计"><meta property="og:description" content="一个 app 从设计到发布应用商店会经历需求设计、UI设计、架构设计、开发、优化、测试等流程，每个环节做的好与坏都会影响到整个 app 的质量，作为开发人员，不仅要对需求以及 UI 的合理性进行评审，还要保证提供给测试的代码是经过自测并且覆盖了相关测试用例，更重要的是要做好架构设计、开发以及优化这三个环节。
架构设计 架构设计可以以业务为驱动，按照最适合自己的方式去设计，设计思路和方法尽量统一，同类型问题用同样方式去解决，下面几点是我认为比较重要的：
  关注分离
将系统分解为多个模块并各司其职，纵向分层，横向拆分业务。
  高内聚
一个模块只完成一个功能，并合理有度的进行封装。
  松耦合
依赖关系越少越好，尽量不横向依赖，不跨层访问。继承是紧耦合的一种操作，它通常与多态一起存在，如果仅仅是为了代码重用而做的继承还不如用组合。
  适度设计
对业务方该限制的地方要进行限制，该灵活的地方也要给业务方创造灵活实现的条件，架构的设计要保持一定量的超前性而做到易扩展，但不要设计过度，避免多做无用功而增加框架复杂度。好的架构是随着时间而更新的，而不是一开始就设计好了一切。
  技术选型
不要仅是为了体验新技术而改变现有架构，等别人把坑踩平后再根据团队及业务情况考虑是否使用，技术本身没有什么好不好，只有适合不适合。
  框架是服务开发人员的，需要满足通用性和易用性两个要求，其中易用性更重要
开发 MVVM MVVM 相对 MVC 来说最大的优点是，ViewModel 是独立的，可复用到别的模块，并且更易于做单元测试，而 View 和 ViewController 仅用来做 UI 展示，它与 ViewModel 之间是相互影响的，ViewModel 处理过的数据要能够及时响应到 View，而用户在 View 中做了修改数据的操作后，ViewModel 中对应的数据也应该及时更新，响应式编程方式能够更容易的处理这个过程
响应式编程 响应式编程是一种面向数据及其变化响应的编程方式，它能够将数据、UI事件和异步操作更方便的进行序列化处理，相比传统编程方式来说，它可以使逻辑相关的代码能够紧凑的聚在一起，它通过信号机制来实现，用信号来记录值的变化，并通过信号绑定的方式来响应变化，下面这个例子很好的描述了响应式编程的作用
a = 2 // signal b = 2 // signal c = a + b // signal binding c = 4 b = 3 // c = 5 目前我们在 Swift 项目中选择使用 RxSwift + MVVM 的方式进行开发，使用 RxSwift 需要掌握以下几个概念："><meta property="og:type" content="article"><meta property="og:url" content="https://lijingcheng.github.io/posts/ios-design/"><meta property="article:published_time" content="2018-09-05T18:40:19+08:00"><meta property="article:modified_time" content="2018-09-05T18:40:19+08:00"></head><body><header class=app-header><a href=https://lijingcheng.github.io><img class=app-header-avatar src=/images/avatar.png alt=风行></a><h1>风行's Blog</h1><p>Do not repeat yourself!</p><div class=app-header-social><a target=_blank href=https://github.com/lijingcheng rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a target=_blank href=https://www.instagram.com/bj_lijingcheng/ rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-instagram"><title>instagram</title><rect x="2" y="2" width="20" height="20" rx="5" ry="5"/><path d="M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37z"/><line x1="17.5" y1="6.5" x2="17.5" y2="6.5"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>iOS 应用的开发设计</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Sep 5, 2018</div></div></header><div class=post-content><p>一个 app 从设计到发布应用商店会经历需求设计、UI设计、架构设计、开发、优化、测试等流程，每个环节做的好与坏都会影响到整个 app 的质量，作为开发人员，不仅要对需求以及 UI 的合理性进行评审，还要保证提供给测试的代码是经过自测并且覆盖了相关测试用例，更重要的是要做好架构设计、开发以及优化这三个环节。</p><h1 id=heading>架构设计</h1><p>架构设计可以以业务为驱动，按照最适合自己的方式去设计，设计思路和方法尽量统一，同类型问题用同样方式去解决，下面几点是我认为比较重要的：</p><ul><li><p>关注分离<br>将系统分解为多个模块并各司其职，纵向分层，横向拆分业务。</p></li><li><p>高内聚<br>一个模块只完成一个功能，并合理有度的进行封装。</p></li><li><p>松耦合<br>依赖关系越少越好，尽量不横向依赖，不跨层访问。继承是紧耦合的一种操作，它通常与多态一起存在，如果仅仅是为了代码重用而做的继承还不如用组合。</p></li><li><p>适度设计<br>对业务方该限制的地方要进行限制，该灵活的地方也要给业务方创造灵活实现的条件，架构的设计要保持一定量的超前性而做到易扩展，但不要设计过度，避免多做无用功而增加框架复杂度。好的架构是随着时间而更新的，而不是一开始就设计好了一切。</p></li><li><p>技术选型<br>不要仅是为了体验新技术而改变现有架构，等别人把坑踩平后再根据团队及业务情况考虑是否使用，技术本身没有什么好不好，只有适合不适合。</p></li></ul><p>框架是服务开发人员的，需要满足通用性和易用性两个要求，其中易用性更重要</p><h1 id=heading-1>开发</h1><h2 id=mvvm>MVVM</h2><p>MVVM 相对 MVC 来说最大的优点是，ViewModel 是独立的，可复用到别的模块，并且更易于做单元测试，而 View 和 ViewController 仅用来做 UI 展示，它与 ViewModel 之间是相互影响的，ViewModel 处理过的数据要能够及时响应到 View，而用户在 View 中做了修改数据的操作后，ViewModel 中对应的数据也应该及时更新，响应式编程方式能够更容易的处理这个过程</p><h2 id=heading-2>响应式编程</h2><p>响应式编程是一种面向数据及其变化响应的编程方式，它能够将数据、UI事件和异步操作更方便的进行序列化处理，相比传统编程方式来说，它可以使逻辑相关的代码能够紧凑的聚在一起，它通过信号机制来实现，用信号来记录值的变化，并通过信号绑定的方式来响应变化，下面这个例子很好的描述了响应式编程的作用</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>a <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#75715e>// signal
</span><span style=color:#75715e></span>b <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#75715e>// signal
</span><span style=color:#75715e></span>c <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b <span style=color:#75715e>// signal binding c = 4 
</span><span style=color:#75715e></span>b <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span> <span style=color:#75715e>// c = 5
</span></code></pre></div><p>目前我们在 Swift 项目中选择使用 RxSwift + MVVM 的方式进行开发，使用 RxSwift 需要掌握以下几个概念：</p><ul><li><p>Observable（被观察者）：相当于一个事件序列，它会主动向订阅者发送新产生的事件内容，包括 onNext、onError、onCompleted()</p></li><li><p>Subscribe（订阅者）：订阅后便可以根据事件产生的数据进行操作</p></li><li><p>Scheduler（调度器）：可分别通过 subscribeOn 和 observeOn 指定 Observable 或 Subscribe 在哪个线程上执行，默认是当前线程。</p></li><li><p>Operator（<a href=https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree.html>操作符</a>）：RxSwift 提供了很多操作符，合理运用便会极大提高开发效率</p></li><li><p>Subject：既可以作为 Observable 发送事件也可以作为 Subscribe 监听事件，它包括以下几种：</p><ul><li><p>PublishSubject：订阅者只会接收到订阅操作之后的事件，也就是所说的热信号。</p></li><li><p>ReplaySubject：订阅者会接受到订阅之前的事件（可根据 bufferSize 指定数量）以及订阅之后的事件，类似于冷信号。</p></li><li><p>BehaviorSubject：订阅之后首先会接收到最近一次发送的事件，如果最近没有发送，那么发送一个初始事件。</p></li><li><p>AsyncSubject：订阅者只有在 Observable 发送 onCompleted() 时才能够收到它之前发送的最后一个事件，即使是在这之后的新订阅者也能够收到。</p></li></ul></li></ul><h2 id=heading-3>跨平台开发</h2><p>跨平台开发的方式很多，做技术选型时要根据业务及团队情况去选择</p><h3 id=hybridh5--native>Hybrid（H5 + Native）</h3><p>使用 WebView 承载 H5 页面并通过 JSBridge 实现交互，性能略差，可通过预下载资源等方式进行优化。</p><h3 id=reatct-native>Reatct Native</h3><p>RN 中虚拟 DOM 会通过 JavaScriptCore 映射为原生控件，性能比 H5 高一些，但由于渲染时需要 JS 和Native 通信，在有些场景（拖动）可能会因为通信频繁导致卡顿，可以通过延迟渲染方式解决，但更重要的问题是维护成本大。</p><h3 id=flutter>Flutter</h3><p>Flutter 使用 Skia 2D 渲染引擎来绘制 UI，采用 Dart 语言开发，Dart 是类型安全的语言，比 JS 运行速度快也更安全一些，它支持 AOT(Ahead of time 提前编译) 和 JIT(Just-in-time 即时编译) 两种运行方式，在开发阶段采用 JIT 来实现热重载，在发布时采用 AOT 来生成高效的 ARM 代码以保证应用性能，所以 Flutter 应用发布后不能像 Hybrid 和 RN 那些使用 JS 作为开发语言的框架去动态下发代码。</p><h3 id=swiftui>SwiftUI</h3><p>SwiftUI 使用 DSL 声明式 UI、跨自家平台、Xcode 通过单独编译我们当前操作的视图文件，利用 Swift dynamic repacement 特性将更新内容注入到正在运行的程序中来实现热重载。</p><p>上面几种跨平台方案中，Hybrid 比较适合我所在的团队，Flutter 我们一直在关注，SwiftUI 还不成熟，而且仅适配 iOS13+ 系统，所以我们在简单学习后就放下了，过几年再关注。</p><h2 id=heading-4>组件化开发</h2><p>随着 app 功能和体积的增长，也带来了如编译速度变慢、提交代码经常出现冲突、以及业务代码混在一起，开发功能类似的新项目时需要从头搭建等问题，于是很多团队都选择了利用组件化开发来解决这些问题，在组件化过程中需要注意下面列出的几个问题</p><ul><li>怎样合理拆分组件</li><li>组件之间的依赖关系</li><li>组件中的资源访问</li><li>组件之间的路由跳转</li><li>组件的多环境打包</li></ul><p>详细介绍可参照上一篇文章 <a href=https://lijingcheng.github.io/posts/ios-componentization/>iOS 组件化开发</a></p><h1 id=heading-5>优化</h1><h2 id=-bug>线上 Bug</h2><p>线上 Bug 可按以下优先级（由高到低）来处理：</p><ul><li><p>次数较多的 Bug 不管是否好处理都需要优先处理，并根据情况决定是否需要发版，还需要将原因及如何避免等问题分享给团队成员，避免其他人再次出现类似问题</p></li><li><p>次数较少但是容易处理的 Bug</p></li><li><p>无法复现但是有一定影响的 Bug，可根据情况添加保护性代码避免 app 崩溃，但要求能够预知是否会造成其他问题（数据异常，页面异常等）</p></li><li><p>次数少处理难度大的 Bug 放最后，有时间时再去调查原因</p></li></ul><p>修改 Bug 后要告知测试人员影响范围，避免因没覆盖测试而上线出现问题，新版本上线后需要关注修改过的问题是否还会出现。</p><h2 id=heading-6>数据安全</h2><p>我们从 AppStore 下载的 app 其实都已经由苹果加壳，要砸壳后才能有办法看到汇编形式的源代码，如果我们要自己再加一层壳，可以对关键代码的方法名做一些混淆，以增加别人分析代码的复杂度，不过这对于大多数 app 来说不太值得去做，我们可以把精力放在其他更易做并且更有效率的地方，例如：</p><ul><li><p>使用 Https 保证数据传输安全</p></li><li><p>不将敏感数据直接存储在沙盒里</p></li><li><p>调用接口时 app 要做验签，并且对传输的敏感数据进行加密</p></li><li><p>不要将对称加密用到的 Key 存储在客户端</p></li></ul><h2 id=heading-7>启动时间</h2><p>可以通过 Instruments 的 Time Profiler 工具来查看耗费时间，也可以通过在 Xcode 中修改项目的 scheme，在 Run -> Auguments 增加环境变量 DYLD_PRINT_STATISTICS 并设置为 1，然后观察控制台打出的 log 来查看</p><ul><li><p>pre-main 阶段系统会由 dyld（the dynamic link editor）加载相关动态链接库，然后再初始化 runtime 环境，并由 runtime 触发 + load 方法，所以不要在 load 方法里执行耗时任务，否则会影响启动时间，并且用不到的代码文件要及时删除。</p></li><li><p>检查 didFinishLaunchingWithOptions 及启动相关的方法，将部分操作改为异步执行或延迟处理</p></li><li><p>首页相关 ViewController 尽量使用代码实现</p></li></ul><h2 id=app->App 瘦身</h2><ul><li><p>将部分资源文件从工程中移除，改为从接口获取，并且可以通过给数据加版本号，避免每次重复下载。</p></li><li><p>清理无用的代码文件和资源，不要 @1x 图片，如果用到了 ProtoBuf，可以将 .proto 文件从 Compile Sources 中移除。</p></li><li><p>压缩图片 <a href=tinypng.com>tinypng.com</a> 。</p></li><li><p>小图标可以使用 iconfont 替代，大图可以用 pdf 替代</p></li><li><p>启动图界面用 LaunchScreen.storyboard，不要用多张 Default 图。</p></li><li><p>用 .xcassets 来管理图片，Xcode 能够把里边的所有 png 图片压缩成 .car 文件。并且 iOS9 之后，如果是用 .xcassets 管理图片，AppStore 会根据不同设备准备不同的安装包，每个包内只有对应尺寸的图片，例如 iPhone6 下载 app 时，包里就只有 @2x 图。</p></li><li><p>放弃 iPhone5s 之前发布的 32 位手机，仅支持 arm64</p></li></ul><h2 id=heading-8>流量</h2><ul><li><p>合理使用本地缓存数据并及时更新缓存</p></li><li><p>考虑用 ProtoBuf 替代 JSON，也可以仅是个别数据量大的接口改为 ProtoBuf 格式数据</p></li><li><p>轮询接口方式可以用 WebSocket 替代</p></li><li><p>请求的图片格式考虑由 jpg 改为 webp，减少图片下载时间，再想办法提高图片转码时间</p></li><li><p>按 UIImageView 大小取合适大小的图片，不要直接取原图，同一图片用在不同界面时，尽量要求 UI 统一视图比例，然后 app 统一获取同样大小图片，这样做的话不管对 app 还是 CDN 都能够提高缓存利用率</p></li><li><p>非关键的业务数据，可以通过合并接口的方式，减少和服务器的交互次数。</p></li><li><p>请求接口前客户端通过对 request params 做检查来减少不必要的网络请求</p></li><li><p>可以用 ETag 这种服务端加本地验证的方式处理返回数据，当数据没有更新时不返回数据，而是返回 304</p></li><li><p>数据量大时要提示用户是否在非 wifi 环境下下载</p></li><li><p>下载功能要有取消下载的逻辑</p></li></ul><h2 id=ui->UI 交互</h2><ul><li><p>延迟处理不需要马上展现的视图或操作</p></li><li><p>不要阻塞主线程，能异步去做的就不要同步。</p></li><li><p>由于 UIKit 中大部分对象都不是线程安全的，所以 UI 操作都需要放在主线程做串行处理，否则可能会导致未知行为（动画异常、页面错乱、Crash）。</p></li><li><p>优化表格滑动</p><ul><li><p>提前算 Cell 高度并缓存，如果要加载的数据也是要经过处理才展示的也提前处理好</p></li><li><p>异步绘制，滑动过程中不加载图片</p></li><li><p>当 Cell 中有很多子视图并且他们要在不同条件下展示时，考虑拆成多个 Cell</p></li><li><p>不要在 Cell 中频繁生成 NSDateFormatter 对象</p></li></ul></li><li><p>通过设置模拟器的 Debug 菜单下的几项设置来查看图层视图是否需要优化</p><ul><li><p>Color Blended layers<br>大多情况是因为视图的 backgroundColor 与父视图颜色不一致或者是透明的，它会用红色表示有问题的视图，而绿色的表示没问题</p></li><li><p>Color copied images<br>当图片的色彩格式不能被 GPU 处理时，会交由 CPU 处理，应该尽可能避免这种问题</p></li><li><p>Color misaligned images<br>图片大小与控件不一致，会用黄色表示图片被缩放了，用紫色表示像素没对齐</p></li><li><p>Color offscreen-rendered<br>用黄色标示哪些 layer 做了离屏渲染（当 GPU 无法将渲染结果直接写入 frame buffer，而是将结果暂存在其他内存后再写入 frame buffer），多数时候离屏渲染会影响性能，应该尽量避免，无法避免时可通过 shouldRasterize 来缓存渲染结果，降低影响，在开发过程中需要重点关注列表中对 View 做圆角设置和添加阴影操作。</p><ul><li><p>cornerRadius + clipsToBounds 设置圆角会触发离屏渲染，仅使用 cornerRadius 不会触发，但效果不好，可以用带圆角效果的 layer 盖住视图实现圆角效果，以避免离屏渲染</p></li><li><p>使用 shadowPath 添加阴影可以避免离屏渲染</p></li></ul></li></ul></li></ul></div><div class=post-footer></div></article></main></body></html>