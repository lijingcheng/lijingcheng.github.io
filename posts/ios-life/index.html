<!doctype html><html lang=zh-cn><head><title>iOS 应用的生命周期 // 风行's Blog</title><meta charset=utf-8><meta name=generator content="Hugo 0.61.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="风行"><meta name=description content><link rel=stylesheet href=https://lijingcheng.github.io/css/main.min.61bb32028587f24ca28522d8d197970c7ef33284e5fffb45a75fcbbb2dbc4dcb.css><meta name=twitter:card content="summary"><meta name=twitter:title content="iOS 应用的生命周期"><meta name=twitter:description content="程序的生命周期是指应用程序从启动到结束整个阶段的全过程，点击应用图标打开程序，系统会首先通过 main 函数进行相关设置，然后通过 RunLoop 保持程序能够始终运行并监听处理分发事件，当没有事件发生时 RunLoop 便处于睡眠状态，节省资源。当发生事件后，RunLoop 将事件对象分发给相应视图处理。当用户按下 Home 键，应用会在进入后台后短暂运行，直到被系统挂起。
main 函数 main 函数是 app 的入口函数
int main(int argc, char * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } }  在进入 main 函数之前，系统会由 dyld（the dynamic link editor）加载相关动态链接库，然后再初始化 runtime 环境，并由 runtime 触发 + load 方法，所以不要在 load 方法里执行耗时任务，否则会影响启动时间。 @autoreleasepool 用来管理主线程中标记为自动释放的对象。 UIApplicationMain 根据传入参数以及 info.plist 文件来初始化 app  argc 和 argv 参数在 iOS 应用中用不到 第三个参数为 app 的首要类名，用来监听并管理应用的生命周期，默认使用 UIApplication 最后一个参数为 app 首要类的代理类，它负责实际处理 UIApplication 监听到的应用程序生命周期事件，具体参考 UIApplicationDelegate main 函数会在初始化 app 后启动主线程及 RunLoop    RunLoop RunLoop 能够保持程序始终运行并监听处理分发事件，当没有事件发生时进入休眠状态，有事件发生时系统会将接收到的事件放在一个队列里，然后唤醒 RunLoop 依次处理事件，使用队列不仅可以解决线程同步问题也促使我们要把更新 UI 的代码放在主线程中运行，以免由于多个线程抢占资源产生奇怪的问题。RunLoop 可以接收的事件来自两种不同的来源，分别是输入源和定时源，输入源传递异步事件，事件通常来自于其他线程或程序，如一些 UI 事件等。定时源则传递同步事件，发生在特定时间或者重复的时间间隔，如 NSTimer。"><meta property="og:title" content="iOS 应用的生命周期"><meta property="og:description" content="程序的生命周期是指应用程序从启动到结束整个阶段的全过程，点击应用图标打开程序，系统会首先通过 main 函数进行相关设置，然后通过 RunLoop 保持程序能够始终运行并监听处理分发事件，当没有事件发生时 RunLoop 便处于睡眠状态，节省资源。当发生事件后，RunLoop 将事件对象分发给相应视图处理。当用户按下 Home 键，应用会在进入后台后短暂运行，直到被系统挂起。
main 函数 main 函数是 app 的入口函数
int main(int argc, char * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } }  在进入 main 函数之前，系统会由 dyld（the dynamic link editor）加载相关动态链接库，然后再初始化 runtime 环境，并由 runtime 触发 + load 方法，所以不要在 load 方法里执行耗时任务，否则会影响启动时间。 @autoreleasepool 用来管理主线程中标记为自动释放的对象。 UIApplicationMain 根据传入参数以及 info.plist 文件来初始化 app  argc 和 argv 参数在 iOS 应用中用不到 第三个参数为 app 的首要类名，用来监听并管理应用的生命周期，默认使用 UIApplication 最后一个参数为 app 首要类的代理类，它负责实际处理 UIApplication 监听到的应用程序生命周期事件，具体参考 UIApplicationDelegate main 函数会在初始化 app 后启动主线程及 RunLoop    RunLoop RunLoop 能够保持程序始终运行并监听处理分发事件，当没有事件发生时进入休眠状态，有事件发生时系统会将接收到的事件放在一个队列里，然后唤醒 RunLoop 依次处理事件，使用队列不仅可以解决线程同步问题也促使我们要把更新 UI 的代码放在主线程中运行，以免由于多个线程抢占资源产生奇怪的问题。RunLoop 可以接收的事件来自两种不同的来源，分别是输入源和定时源，输入源传递异步事件，事件通常来自于其他线程或程序，如一些 UI 事件等。定时源则传递同步事件，发生在特定时间或者重复的时间间隔，如 NSTimer。"><meta property="og:type" content="article"><meta property="og:url" content="https://lijingcheng.github.io/posts/ios-life/"><meta property="article:published_time" content="2015-03-28T11:23:29+08:00"><meta property="article:modified_time" content="2015-03-28T11:23:29+08:00"></head><body><header class=app-header><a href=https://lijingcheng.github.io><img class=app-header-avatar src=/images/avatar.png alt=风行></a><h1>风行's Blog</h1><p>一直在学习的大龄程序员</p><div class=app-header-social><a target=_blank href=https://github.com/lijingcheng rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a target=_blank href=https://www.instagram.com/bj_lijingcheng/ rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-instagram"><title>instagram</title><rect x="2" y="2" width="20" height="20" rx="5" ry="5"/><path d="M16 11.37A4 4 0 1112.63 8 4 4 0 0116 11.37z"/><line x1="17.5" y1="6.5" x2="17.5" y2="6.5"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>iOS 应用的生命周期</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Mar 28, 2015</div></div></header><div class=post-content><p>程序的生命周期是指应用程序从启动到结束整个阶段的全过程，点击应用图标打开程序，系统会首先通过 main 函数进行相关设置，然后通过 RunLoop 保持程序能够始终运行并监听处理分发事件，当没有事件发生时 RunLoop 便处于睡眠状态，节省资源。当发生事件后，RunLoop 将事件对象分发给相应视图处理。当用户按下 Home 键，应用会在进入后台后短暂运行，直到被系统挂起。</p><h1 id=main->main 函数</h1><p>main 函数是 app 的入口函数</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> argv[]) {
    <span style=color:#66d9ef>@autoreleasepool</span> {
        <span style=color:#66d9ef>return</span> UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate <span style=color:#66d9ef>class</span>]));
    }
}
</code></pre></div><ul><li>在进入 main 函数之前，系统会由 dyld（the dynamic link editor）加载相关动态链接库，然后再初始化 runtime 环境，并由 runtime 触发 + load 方法，所以不要在 load 方法里执行耗时任务，否则会影响启动时间。</li><li>@autoreleasepool 用来管理主线程中标记为自动释放的对象。</li><li>UIApplicationMain 根据传入参数以及 info.plist 文件来初始化 app<ul><li>argc 和 argv 参数在 iOS 应用中用不到</li><li>第三个参数为 app 的首要类名，用来监听并管理应用的生命周期，默认使用 UIApplication</li><li>最后一个参数为 app 首要类的代理类，它负责实际处理 UIApplication 监听到的应用程序生命周期事件，具体参考 UIApplicationDelegate</li><li>main 函数会在初始化 app 后启动主线程及 RunLoop</li></ul></li></ul><h1 id=runloop>RunLoop</h1><p>RunLoop 能够保持程序始终运行并监听处理分发事件，当没有事件发生时进入休眠状态，有事件发生时系统会将接收到的事件放在一个队列里，然后唤醒 RunLoop 依次处理事件，使用队列不仅可以解决线程同步问题也促使我们要把更新 UI 的代码放在主线程中运行，以免由于多个线程抢占资源产生奇怪的问题。RunLoop 可以接收的事件来自两种不同的来源，分别是输入源和定时源，输入源传递异步事件，事件通常来自于其他线程或程序，如一些 UI 事件等。定时源则传递同步事件，发生在特定时间或者重复的时间间隔，如 NSTimer。</p><p>RunLoop 的开启和退出</p><ul><li>苹果提供了 NSRunLoop 和 CFRunLoopRef 来操作 Runloop，CFRunLoopRef 是线程安全的，NSRunLoop 基于 CFRunLoopRef 并提供了面向对象的 API，API 不是线程安全的</li><li>苹果不允许我们直接创建 Runloop，只能在线程内部通过 <code>[NSRunLoop currentRunLoop]</code> 来获取，第一次调用此方法时便会创建 Runloop</li><li>主线程的 Runloop 是默认开启的，子线程需要我们自己开启，并且在开启后通过添加 port 来监听事件，否则 RunLoop 在启动后便会结束（除了 NSTimer）</li><li>可以通过给 RunLoop 设置过期时间来使 Runloop 能够退出，或者通过 CFRunLoopStop 直接退出（会在执行完正在运行的事件后退出，并且如果给 Runloop 添加了 port，那么需要 remove port）</li></ul><p>那么什么情况下需要我们在子线程中开启并使用 RunLoop 呢？</p><ul><li>创建常驻线程，可以像 AFN 那样给新线程开启 Runloop 的同时添加端口来监听事件，这样它就能一直处于等待事件的状态中，线程就不会结束了。</li><li>线程间需要持续交互，需要在开启 Runloop 时同时指定一个用于唤醒它的 NSPort 端口对象，然后使用端口对象来进行多线程间的通信。</li><li>使用 NSTimer 或 performSelector 系列方法。<ul><li>performSelecter:afterDelay: 会创建 timer 并添加到当前线程的 RunLoop 中，如果当前线程没有 RunLoop，此方法失效。</li><li>performSelector:onThread: 会创建 timer 并添加到指定线程的 RunLoop 中，如果指定线程没有 RunLoop，此方法失效。</li></ul></li></ul><p>不同的事件源会运行在 RunLoop 的不同模式中，它们只有在相匹配的情况下才会被处理。这种工作方式利于 RunLoop 更好的管理和处理事件，使它们之间不相互影响。</p><ul><li>NSTimer 运行在 NSDefaultRunLoopMode 模式下。</li><li>列表滚动事件运行在 UITrackingRunLoopMode 模式下。</li><li>NSRunLoopCommonModes 包含 NSDefaultRunLoopMode 和 UITrackingRunLoopMode。</li></ul><p>我们可以通过改变一些事件操作的 RunloopMode 来提高用户体验</p><p>在列表中加载图片时，让加载图片的操作处于 NSDefaultRunLoopMode 中，这样在列表滚动时便不会加载图片，列表的滚动速度便会有所提升</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>[self.imageView performSelector:<span style=color:#66d9ef>@selector</span>(setImage:) withObject:image afterDelay:<span style=color:#ae81ff>0</span> inModes:<span style=color:#ae81ff>@[</span>NSDefaultRunLoopMode<span style=color:#ae81ff>]</span>];
</code></pre></div><p>在列表中使用 NSTimer 时，默认情况下在滚动时 timer 会停止，这时可以将 timer 运行在 NSRunLoopCommonModes 下，便可以在表格静止以及滚动时都能够正常运行。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
</code></pre></div><p>需要注意的是 NSTimer 并不是以子线程的方式运行，它只是在 RunLoop 里注册了一下，RunLoop 会根据 timer 的设置情况去检测并触发，所以任务在执行过程中一旦出现延迟，那么会丢失执行次数，如果对精确度有要求的话，可以使用 dispatch_time，GCD 不受 RunLoop 影响。</p><p>关于 RunLoop 的具体介绍详见<a href=https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1>官方文档</a></p><h1 id=heading>事件传递&事件响应</h1><p>当发生触摸操作后，系统会将这一事件封装成 UIEvent 对象并放到由 UIApplication 管理的事件队列中，再由 RunLoop 接收事件并传递给触摸点所在的视图，该视图即为 &ldquo;hit-test视图&rdquo;，而查找这一视图的过程就叫做 &ldquo;hit-testing&rdquo;。hit-testing 过程大致如下:</p><ul><li>RunLoop 将接收到的事件分发给 UIWindow。</li><li>UIWindow 通过 hitTest:withEvent: 方法在视图树中递归查找触摸点所在的视图。</li><li>当前视图通过 hitTest 方法调用 pointInside:withEvent: 来判定触摸点是否在当前视图，如果不在 hitTest 返回 nil，在的话则从当前视图的 subViews 末尾向前遍历，依次向每个 subView 发送 hitTest 消息，以此规则一直到某个 subView 不再返回 nil 或遍历完成。</li><li>最终由最后一个遍历到并且不返回 nil 的视图作为 hit-test视图。</li></ul><p>在这过程中如果视图不具备响应事件的条件(userInteractionEnabled 或 enabled 为 NO，hidden=YES 或 alpha=0)，那么 hitTest 就不会调用 pointInside 方法，会直接返回 nil，该视图的子视图也就不会被遍历到，如果我们想改变这一点，或者有别的需求需要改变事件传递的规则，那么需要自定义父视图并重写以下方法来控制子视图。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>- (UIView <span style=color:#f92672>*</span>)<span style=color:#a6e22e>hitTest:</span>(CGPoint)point <span style=color:#a6e22e>withEvent:</span>(UIEvent <span style=color:#f92672>*</span>)event;
- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>pointInside:</span>(CGPoint)point <span style=color:#a6e22e>withEvent:</span>(UIEvent <span style=color:#f92672>*</span>)event;
</code></pre></div><p>如果想在某种情况下不响应事件，可以在适当时调用 UIApplication 的以下方法停止和恢复事件接收和分发。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>beginIgnoringInteractionEvents</span>
- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>endIgnoringInteractionEvents</span>
</code></pre></div><p>如果 hit-test 视图不处理收到的事件（没有重写 touches 方法，或者只是在 touches 方法里调用 [super touches..]），则通过响应者链机制寻找其它响应者来处理。</p><p>响应链由一系列链接在一起的响应者组成。如果一个响应者不能处理事件，则会将事件沿着响应链传到下一响应者。下一响应者有可能是它的父视图也可能是它所在的 ViewController，系统会以此类推一直传递到 UIApplication。如果整个过程都没有响应者响应事件，该事件就会被丢弃。否则事件便会停止传递交由响应者处理。</p><p>在开发过程中，有时我们不得不定义一个很小的按钮，为了避免发生用户点不到按钮的事情发生，可以利用上面的知识，扩大按钮的有效范围，只要触碰到按钮附近就使按钮响应事件。解决办法就是自定义继承 UIButton 的视图，并重写 pointInside:withEvent 方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>- (<span style=color:#66d9ef>BOOL</span>)<span style=color:#a6e22e>pointInside:</span>(CGPoint)point <span style=color:#a6e22e>withEvent:</span>(UIEvent <span style=color:#f92672>*</span>)event {
    CGRect bounds <span style=color:#f92672>=</span> self.bounds;

    CGFloat widthDelta <span style=color:#f92672>=</span> MAX(<span style=color:#ae81ff>44.0</span> <span style=color:#f92672>-</span> self.bounds.size.width, <span style=color:#ae81ff>0</span>);
    CGFloat heightDelta <span style=color:#f92672>=</span> MAX(<span style=color:#ae81ff>44.0</span> <span style=color:#f92672>-</span> self.bounds.size.height, <span style=color:#ae81ff>0</span>);

    bounds <span style=color:#f92672>=</span> CGRectInset(self.bounds, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> widthDelta, <span style=color:#f92672>-</span><span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> heightDelta);

    <span style=color:#66d9ef>return</span> CGRectContainsPoint(bounds, point);
}
</code></pre></div><p>当子视图添加到父视图后，其响应事件的范围就是父视图的 bounds，如果部分界面超出了这个范围，则超出部分无法响应事件，未超出部分仍然可以响应事件，为了使超出父视图范围的子视图也能响应事件，需要实现主视图的 <code>- hitTest:withEvent:</code> 方法。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc>- (UIView <span style=color:#f92672>*</span>)<span style=color:#a6e22e>hitTest:</span>(CGPoint)point <span style=color:#a6e22e>withEvent:</span>(UIEvent <span style=color:#f92672>*</span>)event {
    UIView <span style=color:#f92672>*</span>view <span style=color:#f92672>=</span> [super hitTest:point withEvent:event];
    
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>view) {
        <span style=color:#66d9ef>for</span> (UIView <span style=color:#f92672>*</span>subView <span style=color:#66d9ef>in</span> self.subviews) {
            CGPoint p <span style=color:#f92672>=</span> [subView convertPoint:point fromView:self];
            <span style=color:#66d9ef>if</span> (CGRectContainsPoint(subView.bounds, p)) {
                view <span style=color:#f92672>=</span> subView;
            }
        }
    }
    
    <span style=color:#66d9ef>return</span> view;
}
</code></pre></div><h1 id=heading-1>前后台切换</h1><p>在程序进入后台后仍然能够在短时间里执行一些代码，然后便进入挂起状态，程序在挂起后仍然会驻留在内存中，但是不能执行代码，直到 iOS 系统内存降低发出警告后才会把相对耗内存的挂起程序清除掉。</p><p>当程序在前后台切换时，系统会调用 UIApplicationDelegate 的相关代理方法并发送通知，我们可以在不同情况下做出不同处理，例如在进入后台时暂停某些操作或存储某些数据，当恢复到前台时再恢复之前的暂停操作或读取之前存储的数据。</p></div><div class=post-footer></div></article></main></body></html>