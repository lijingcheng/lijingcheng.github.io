---
title: "Code Review"
date: 2019-12-30T17:00:38+08:00
draft: true
---

有效并持续的 Code Review 不仅可以提高代码质量，降低程序风险，还可以提高开发人员技术水平，但前提是需要开发人员能够真正认可并意识到这并不是在浪费时间，而且在实施前最好能够得到公司认可，并能够将 Code Review 的时间计入工作量，下面列出几条需要注意的地方：



GitLab可以通过MergeRequest来Review代码，也可以做到强制CodeReview，社区版支持Develop、Reviewer两种角色，企业版支持Develop、Reviewer、Approver三种角色，可以给给项目/组分配不同的角色(Master、Developer)来控制Merge代码的权限。

Code Review建议是放在代码提交测试前，也就是开发人员完成代码开发及自测后将代码提交到测试分支时进行Code Review。毕竟，如果测试通过后再进行Code Review，如果需要代码变更，势必会增加测试的工作量，甚至影响项目进度。亦或是顶着项目上线的压力，干脆“以后再说”了

以通用的Git Workflow来说，那就是把Code Review放在Feature分支合并到Develop分支时了。

Review不通过打回前需跟Developer说明原因并达成一致

我们就可以通过细粒度高频次的方式尽可能利用工程师碎片化的时间进行Code Review，一定程度上保证Code Review的效率。

毕竟，粗粒度甚至是集中式的Code Review，时间上难以把控。发现了问题的时候，修复的成本也往往更高。


保证Code Review质量的关键
1、工程师对研发规范的认真学习
无论Code Review的工具以及流程是怎么样的，都少不了开发规范作为支撑，毕竟我们期望Code Review达到的效果之一就是，团队中的工程师可以写出像规范中描述那样的高质量代码。

工程师对研发规范的掌握程度，决定了自己编写代码的质量，也决定了被自己Review通过的代码的质量。所以，无论如何，加强对研发规范的学习和理解，都是保证Code Review质量的重中之重

2、资深工程师的认真对待
Code Review目的是帮助工程师交流和学习进步的。无论是技术能力还是编码习惯，亦或是业务知识。无论规则怎么制定，终究还是需要参与的工程师来执行，如果大家互相睁一只眼闭一只眼，互相降低要求，那么执行的效果一定会打折扣。

虽说三人行必有我师，但收益最大的一定是经验(技能/业务知识)尚浅的工程师，收益最低的一定是团队中最资深的工程师。而恰恰经验尚浅的工程师的收益大部分都要来自资深工程师的付出。

所以，一定要跟资深工程师最好沟通，让他们严格要求，不能对经验尚浅的工程师放水，以帮助他们提升编码能力以及业务知识。

这也可以减少甚至避免他们为经验尚浅的工程师的代码“善后”。



2 PR。也就是 Pull Request，是一次代码提交请求。一个 PR 可以包含一次 Commit，也可以是多个。提交请求后 GitHub 会在相关页面上显示这次提交请求的代码和原代码的所有不同之处，这就是本次 PR 的所有改动。请求提交后，其他工程师可以在 PR 的页面上提出意见和建议，也可以针对某一些代码的改动进行讨论，也可以给整体评价。代码的作者也可以回复这些意见和建议，或者按照建议进行改动，新的改动将为本次 PR 中提交新 Commit（也可以覆盖之前的 Commit）。

下面这个很重要
Code Review 的一个难点是，Reviewer 可能不了解某块代码修改的背景和目的。所以 LinkedIn 要求代码签入版本管理系统前，就对其做清晰的说明，以便复查者了解其目的，促进 Review 的进行。


找谁审核？

明确责任，以后代码就是两个人对同一个代码负责
代码Review还一个好处是，可以互相了解代码，如果有人不在，别人在有必要的情况下可以帮助修改bug，或者休长假时要接手对方代码。Code Review 才是真正的白盒测试。

好处
开发者知道自己的代码是要被人审查的，所以质量会有所提高。
审查时可以学习别人写代码的方式，被审查者也会知道自己的代码出了什么问题，技术上会有提高。

代码审查如果要做就一定要做好，并坚持下去，要不就没有意义了。


代码评审的初衷是提高代码质量，在代码进入生产环境前经过同行评审来发现缺陷，降低损失概率。如果事后才做评审就意义不大了。不仅有可能返工影响进度，而且还会影响到测试也返工，从而影响整个版本的时间安排



人工检查，就是使用类似 Phabricator 这样的 Code Review 工具平台，来分配人员审核提交代码，审核完代码后，审核人可以进行通过、打回、评论等操作。这里需要注意的是，人工检查最容易沦为形式主义，因此为了避免团队成员人工检查成为形式，在开始阶段最好能让团队中编码习惯好、喜欢交流的人来做审核人，以起到良好的示范作用，并以此作为后续的执行标准。


- 要有一个 CheckList，对一些代码问题进行定义，要求开发人员以此为准

- 对于代码规范上的问题应该通过自动 Review 工具去做，如 OCLint/SwiftLint

- 对于代码逻辑及性能上的问题可通过 Pull Request 方式去做

- 审查要及时，打回时被审查者要尽量优先修改问题然后再次提交

- Review 过程中不要太关注代码细节，并且不要过度主观，例如同一功能可用多种方式实现并且它们之间没有明显好坏的情况下不用要求别人修改代码

- 按功能提交代码，不要攒一堆然后一次提交

- 提交描述要写清楚，并且加上前辍，如 fix: fea:

# CheckList
https://github.com/raywenderlich/swift-style-guide
https://github.com/realm/SwiftLint

变量在使用之前，需要先对变量做初始化，并且初始化的地方离使用它的地方越近越好。
guard 不仅可以提前退出方法，还可以减少 if-else 嵌套


- 代码简洁不重复

- 方法短小并专注一个功能

- 删除无用的代码及资源

- 适时地使用 private 实现封装并使代码更清晰

- 避免无意义的 log，保持好的编码习惯

- 不要用魔术数字

- 框架代码及复杂代码要写注释

- 遍历数组或字典时不允许添加或删除元素

- 代码尽量不要有警告

- 相似意义的常量超过 2 个时就要考虑用枚举代替

- 命名要做到“见名知意”，UI 控件的命名要能看出来是什么控件

- 使用 xib 或 storyboard 画界面来降低代码量，UI 控件可通过纯代码实现

- 尽量避免循环引用问题

- Model 中对应接口返回 Int 类型字段如果需要定义成枚举，需要注意接口返回未定义 case 的场景

- 避免对可选类型强解包，可用 `if let foo = foo { ... }` 或可选链 `foo?.doSomething()`

- 尽早的退出方法，可提升代码的可读性，例：`guard xx else { return }`或`if xxx { return} `

- 定义 model 用 struct，值类型是线程安全的，并以栈的形式分配，速度上比 class 快

- 用于对接接口返回数据的 model 中的属性必须是 optional 的，当接口返回字段较少时，可用字典

- 不要在 ViewModel 里用到跟 UIKit 相关的东西，Controller 当 View 用，尽量不写逻辑性代码

- UI 切的图需要[压缩](https://tinypng.com)后再使用，图片命名方式：
`icon_hud_loading@2x.png`

- 项目的主色和辅色有对应常量，如果在 xib 中使用，需要先将做好的 .clr 文件复制到指定目录

- 用`// MARK:`来做代码分段，用`// TODO:`来做待办，但需要写出计划完成时间或条件

- 尽量多用常量来增强代码的不可变性，可以让代码更加安全并提高可读性

- 尽量避免混合使用 Swift 类型和 NSObject 子类，这样会造成大量的类型转换，对性能有影响

