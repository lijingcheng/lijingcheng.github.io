---
title: "接口请求过程"
date: 2020-04-01T18:39:15+08:00
draft: true
---


# 一次接口请求的生命周期
从购卡接口的调用来看一下一次接口请求设及到的知识点

- HTTPS
- tcp 三次握手
- 重要数据 AES 加密
- 请求参数的 MD5 验签
- request/response 数据加密
- RequestAdapter 的设计模式应用
- https 中 tcp 和数字证书的知识（三次握手，四次挥手）
- 数据返回时对于枚举字段在 Swift 中有坑的解决
- tcp 四次挥手

（写的时候可以参考在浏览器打开网页经历了什么，也可以是以万达项目的角度讲，还可以细到讲网络库）

# MD5
MD5 是一种生成信息摘要的算法，可以从任意长度的明文字符串生成128位的哈希值。常用于对接口传输数据做验签，以保证数据传输安全，验签过程：

1.发送方和请求方约定相同的字符串拼接规则，约定相同的密钥。
2.第三方平台接到支付请求，按规则拼接业务参数和密钥，利用MD5算法生成Sign。
3.用第三方平台自己生成的Sign和请求发送过来的Sign做对比，如果两个Sign值一模一样，则签名无误，如果两个Sign值不同，则信息做了篡改。这个过程叫做验签。

MD5 是可以破解的

破解方式并不是将 MD5 后的数据摘要还原成明文，因为128位的摘要是有穷的，而原文数量是无穷的，每一个摘要都可以由若干个原文通过Hash得到。所以对于 MD5 的破解都是通过碰撞的方式实现，也就是字符串生成的 MD5 摘要一样，

设MD5的哈希函数是H（X），那么：
H(A) = M
H(B) = M
任意一个B即为破解结果。B有可能等于A，也可能不等于A。

MD5碰撞通常用于登陆密码的破解。应用系统的数据库中存储的用户密码通常都是原密码的MD5哈希值

常用碰撞方法

- 暴力枚举法：通过枚举出所有原文并计算哈希，然后再看哪个哈希和给定的摘要一致，这种办法时间复杂度极度。
- 字典法：用现成的字典存储尽可能多的原文和哈希值，然后用指定的信息摘要去查找对应的原文，这种办法占空间大，但速度快
- 彩虹表：过于复杂。。。
- 差分攻击：过于复杂。。。

对于单机来说，暴力枚举法的时间成本很高，字典法的空间成本很高。但是利用分布式计算和分布式存储，仍然可以有效破解MD5算法。因此这两种方法同样被黑客们广泛使用。

# SHA
和 MD5 相似，也是一种生成信息摘要的哈希算法，MD5 的摘要长度为 128bit，SHA-1 的摘要长度为 160bit，虽然只多出了 32bit，但不同明文的碰撞几率降低了2^32 = 324294967296倍。2005 年时人们就研究出了破解 SHA-1 的办法，目前常用的有 SHA-256 和 SHA-512，信息摘要越长，发生碰撞的几率就越低，破解的难度就越大。但同时，耗费的性能和占用的空间也就越高。所以要按需要去选择。如果只是验证数据完整性，SHA-256 就足够了。如果希望安全性更高一些还可以考虑 MD5 和 SHA256 结合起来使用，可以将明文同时生成 MD5 摘要和 SHA-256 摘要，然后按规则各取一部分进行摘要合成，例如用 MD5 摘要的前 16 位字符拼接 SHA-256 摘要的后 32 位字符。

明文：        abcd
MD5摘要：
e2fc714c4727ee9395f324cd2e7f331f
SHA-256摘要：
88d4266fd4e6338d13b845fcf289579d209c897823b9217da3e161936f031589

合成摘要：
e2fc714c4727ee93209c897823b9217da3e161936f031589


# AES
AES 是典型的对称加密算法，可以避免信息在传输过程中被中间人截获并窥探到消息内容，对称加密算法与 MD5 和 SHA 这种摘要算法不同在于，摘要算法是不可逆的，主要作用是对信息一致性和完整性的校验，而对称加密算法是可逆的，主要作用是保证隐私信息不被泄露。

具体工作的步骤如下：
1.发送方利用密钥123456，加密明文“我是小灰”，加密结果为TNYRvx+SNjZwEK+ZXFEcDw==。
2.发送方把加密后的内容TNYRvx+SNjZwEK+ZXFEcDw==传输给接收方。
3.接收方收到密文TNYRvx+SNjZwEK+ZXFEcDw==，利用密钥123456还原为明文“我是小灰”。

要学习 AES 算法，首先要清楚三个基本概念：密钥、填充、模式，这三点也是在使用 AES 加密时要和后台开发人员确认的三点，两端要用相同的密钥、填充方式和模式。

## 密钥
密钥是AES算法实现加密和解密的根本。对称加密算法之所以对称，是因为这类算法对明文的加密和解密需要使用同一个密钥。AES支持三种长度的密钥：128位，192位，256位
平时大家所说的AES128，AES192，AES256，实际上就是指的AES算法对不同长度密钥的使用。AES256安全性最高，AES128性能最好（常用），原因是它们的加密处理轮数不同。

我们在调用封装好的AES算法时，表面上使用的Key并不是真正用于AES加密解密的密钥，而是用于生成真正密钥的“种子”。例如在我们项目中使用的 key 是 16字节的字符串，一字节 8 位，所以我们会生成 128 位的密钥。

## 填充
AES算法在对明文加密的时候，并不是把整个明文一股脑加密成一整段密文，而是把明文拆分成一个个独立的明文块，每一个明文块长度128bit。这些明文块经过AES加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。假如一段明文长度是192bit，如果按每128bit一个明文块来拆分的话，第二个明文块只有64bit，不足128bit。这时就需要对明文块进行填充（Padding）。（Common Crypto 对于 AES128 和 AES256，都是以 128bit 来拆分块，不支持以 256bit 拆分，如有要求需要自己实现）

- 使用哪种填充方式：noPadding, zeroPadding, pkcs7, pkcs5

noPadding：

不做任何填充，但是要求明文必须是16字节的整数倍。

PKCS5Padding（默认）：

如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字符，且每个字节的值等于缺少的字符数。

比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6}

pkcs7 秘 pkcs5 在 iOS 上一样。

pkcs#5填充和pkcs#7填充算法没有任何区别。.不同点：在PKCS5Padding中，明确定义Block的大小是8位，而在PKCS7Padding定义中，对于块的大小是不确定的，可以在1-255之间（块长度超出255的尚待研究）。现在最少都是 128位了，所以都是用 pkcs7，可以看下 CryptoSwift 库，就算指定 pkcs5 实际上也用的 pkcs7

zeroPadding：
不够补 0

填充的作用是在加密前将普通文本的长度扩展到需要的长度。关键在于填充的数据能够在解密后正确的移除。

## 模式
AES 加密算法的工作模式有五种：ECB、CBC、CTR、OCF、OFB，模式之间的主题思想是近似的，在处理细节上有一些差别。常用的是 ECB(默认) 和 CBC，ECB 比较简单，易于计算，安全性较差、CBC 安全性好，但性能稍差，苹果安全团队推荐的 CBC 模式。

ECB-电码本模式
ECB是最简单的块密码加密模式，加密前根据加密块大小（AES加密块固定为128位）分成若干块，之后将每块使用相同的密钥单独加密，所以加密块相同的明文会生成相同的密文。

CBC-密码分组链接模式
CBC模式对于每个待加密的密码块在加密前会先与前一个密码块的密文异或然后再用加密器加密。第一个明文块与一个叫初始化向量的数据块异或。

# Base64
Base64 是一种编码算法，因为算法固定，任何人都可以对编码后的字符串解码，所以不能作为加密算法使用，通常用于在通过 http 超文本传输协议传输数据时，对 bytes 数组进行编码（例如图片），只支持 64 个可打印字符，包括 26 个字母的大小写字符、0 到 9 的数字、以及 + 和 /。（再加上作为垫字的"="，实际上是65个字符）----作为一个基本字符集。然后，其他所有符号都转换成这个字符集中的字符。


我们从 AppStore 下载的 app 其实都已经由苹果加壳，要砸壳后才能有办法看到汇编形式的源代码，如果我们要自己再加一层壳，可以对关键代码的方法名做一些混淆，以增加别人分析代码的复杂度，不过这对于大多数 app 来说不太值得去做，我们可以把精力放在其他更易做并且更有效率的地方，例如：

- 使用 Https 保证数据传输安全

- 不将敏感数据直接存储在沙盒里

- 调用接口时 app 要做验签，并且对传输的敏感数据进行加密

- 不要将对称加密要用到的 Key 存储在客户端

- ，加密数据通常有两种方式

    - 对称加密：文件加密和解密使用相同的密钥，AES 相对其他对称加密方式来说更安全些。

    - 非对称加密：需要公钥和私钥，用公钥对数据进行加密，只有对应的私钥才能解密，如果用私钥对数据进行加密，那么只有对应的公钥才能解密。可以用 RSA 来做非对称加密，与对称加密比较，非对称加密速度较慢，但非常安全，据说还没被破解过。
        - 苹果官方生成一对公私钥，在 iOS 系统里内置公钥，私钥由苹果后台保存，我们上传 app 到 AppStore 时，苹果后台用私钥对 app 数据进行签名，iOS 系统下载这个 app 后，用公钥验证这个签名，若签名正确，这个 app 肯定是由苹果后台认证的，并且没有被修改过。

对敏感数据进行加密通常选择对称加密，这时如何使用密钥则是一件非常重要的事，如果将密钥存储在 app 端，那么不管是做代码混淆还是在编译期动态写入密钥都是不安全的，所以建议通过接口请求向后端索取，但过程要比一般 Https 请求麻烦一些：

- 首先由客户端向服务端发起获取钥匙的请求

- 服务端生成公钥 `pk1` 和私钥 `pk2`，然后将公钥 `pk1` 发送给客户端（假设此时黑客已经获取到了公钥 `pk1` ）

- 客户端这时首先生成公钥 `pk3` 和私钥 `pk4`，然后将公钥 `pk3` 通过服务端返回的公钥 `pk1` 加密并发送给服务端（假设此时黑客截获加密后的 `pk3`，虽然知道这是由 `pk1` 加密的，但是他不知道与其对应的私钥 `pk2`，所以无法对客户端发送的公钥进行解密）

- 服务端收到加密后的 `pk3` 后可以通过私钥 `pk2` 解密，并使用 `pk3` 对生成的对称加密密钥 `xxx` 进行加密并发送给客户端（黑客这时因为不知道公钥 `pk3` 是什么，所以得不到对称加密的密钥）

- 客户端收到数据后，可以用自己的私钥 `pk4` 解密并得到对称加密用的密钥 `xxx`，客户端将密钥 `xxx` 存储在内存中，接下来两端就可以使用 `xxx` 作为 key 来加密数据并进行安全的数据传输了。



