---
title: "接口请求过程"
date: 2020-04-01T18:39:15+08:00
draft: true
---


# 一次接口请求的生命周期
从购卡接口的调用来看一下一次接口请求设及到的知识点

- HTTPS
- tcp 三次握手
- 重要数据 AES 加密
- 请求参数的 MD5 验签
- request/response 数据加密
- RequestAdapter 的设计模式应用
- https 中 tcp 和数字证书的知识（三次握手，四次挥手）
- 数据返回时对于枚举字段在 Swift 中有坑的解决
- tcp 四次挥手

（写的时候可以参考在浏览器打开网页经历了什么，也可以是以万达项目的角度讲，还可以细到讲网络库）

# MD5
MD5 是一种生成信息摘要的算法，可以从任意长度的明文字符串生成128位的哈希值。常用于对接口传输数据做验签，以保证数据传输安全，验签过程：

1.发送方和请求方约定相同的字符串拼接规则，约定相同的密钥。
2.第三方平台接到支付请求，按规则拼接业务参数和密钥，利用MD5算法生成Sign。
3.用第三方平台自己生成的Sign和请求发送过来的Sign做对比，如果两个Sign值一模一样，则签名无误，如果两个Sign值不同，则信息做了篡改。这个过程叫做验签。

MD5 是可以破解的

破解方式并不是将 MD5 后的数据摘要还原成明文，因为128位的摘要是有穷的，而原文数量是无穷的，每一个摘要都可以由若干个原文通过Hash得到。所以对于 MD5 的破解都是通过碰撞的方式实现，也就是字符串生成的 MD5 摘要一样，

设MD5的哈希函数是H（X），那么：
H(A) = M
H(B) = M
任意一个B即为破解结果。B有可能等于A，也可能不等于A。

MD5碰撞通常用于登陆密码的破解。应用系统的数据库中存储的用户密码通常都是原密码的MD5哈希值

常用碰撞方法

- 暴力枚举法：通过枚举出所有原文并计算哈希，然后再看哪个哈希和给定的摘要一致，这种办法时间复杂度极度。
- 字典法：用现成的字典存储尽可能多的原文和哈希值，然后用指定的信息摘要去查找对应的原文，这种办法占空间大，但速度快
- 彩虹表：过于复杂。。。
- 差分攻击：过于复杂。。。

对于单机来说，暴力枚举法的时间成本很高，字典法的空间成本很高。但是利用分布式计算和分布式存储，仍然可以有效破解MD5算法。因此这两种方法同样被黑客们广泛使用。

# SHA
和 MD5 相似，也是一种生成信息摘要的哈希算法，MD5 的摘要长度为 128bit，SHA-1 的摘要长度为 160bit，虽然只多出了 32bit，但不同明文的碰撞几率降低了2^32 = 324294967296倍。2005 年时人们就研究出了破解 SHA-1 的办法，目前常用的有 SHA-256 和 SHA-512，信息摘要越长，发生碰撞的几率就越低，破解的难度就越大。但同时，耗费的性能和占用的空间也就越高。所以要按需要去选择。如果只是验证数据完整性，SHA-256 就足够了。如果希望安全性更高一些还可以考虑 MD5 和 SHA256 结合起来使用，可以将明文同时生成 MD5 摘要和 SHA-256 摘要，然后按规则各取一部分进行摘要合成，例如用 MD5 摘要的前 16 位字符拼接 SHA-256 摘要的后 32 位字符。

明文：        abcd
MD5摘要：
e2fc714c4727ee9395f324cd2e7f331f
SHA-256摘要：
88d4266fd4e6338d13b845fcf289579d209c897823b9217da3e161936f031589

合成摘要：
e2fc714c4727ee93209c897823b9217da3e161936f031589


# AES
AES 是典型的对称加密算法，可以避免信息在传输过程中被中间人截获并窥探到消息内容，对称加密算法与 MD5 和 SHA 这种摘要算法不同在于，摘要算法是不可逆的，主要作用是对信息一致性和完整性的校验，而对称加密算法是可逆的，主要作用是保证隐私信息不被泄露。

具体工作的步骤如下：
1.发送方利用密钥123456，加密明文“我是小灰”，加密结果为TNYRvx+SNjZwEK+ZXFEcDw==。
2.发送方把加密后的内容TNYRvx+SNjZwEK+ZXFEcDw==传输给接收方。
3.接收方收到密文TNYRvx+SNjZwEK+ZXFEcDw==，利用密钥123456还原为明文“我是小灰”。

要学习 AES 算法，首先要清楚三个基本概念：密钥、填充、模式，这三点也是在使用 AES 加密时要和后台开发人员确认的三点，两端要用相同的密钥、填充方式和模式。

## 密钥
密钥是AES算法实现加密和解密的根本。对称加密算法之所以对称，是因为这类算法对明文的加密和解密需要使用同一个密钥。AES支持三种长度的密钥：128位，192位，256位
平时大家所说的AES128，AES192，AES256，实际上就是指的AES算法对不同长度密钥的使用。AES256安全性最高，AES128性能最好（常用），原因是它们的加密处理轮数不同。

我们在调用封装好的AES算法时，表面上使用的Key并不是真正用于AES加密解密的密钥，而是用于生成真正密钥的“种子”。例如在我们项目中使用的 key 是 16字节的字符串，一字节 8 位，所以我们会生成 128 位的密钥。

## 填充
AES算法在对明文加密的时候，并不是把整个明文一股脑加密成一整段密文，而是把明文拆分成一个个独立的明文块，每一个明文块长度128bit。这些明文块经过AES加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。假如一段明文长度是192bit，如果按每128bit一个明文块来拆分的话，第二个明文块只有64bit，不足128bit。这时就需要对明文块进行填充（Padding）。（Common Crypto 对于 AES128 和 AES256，都是以 128bit 来拆分块，不支持以 256bit 拆分，如有要求需要自己实现）

- 使用哪种填充方式：noPadding, zeroPadding, pkcs7, pkcs5

noPadding：

不做任何填充，但是要求明文必须是16字节的整数倍。

PKCS5Padding（默认）：

如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字符，且每个字节的值等于缺少的字符数。

比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6}

pkcs7 秘 pkcs5 在 iOS 上一样。

pkcs#5填充和pkcs#7填充算法没有任何区别。.不同点：在PKCS5Padding中，明确定义Block的大小是8位，而在PKCS7Padding定义中，对于块的大小是不确定的，可以在1-255之间（块长度超出255的尚待研究）。现在最少都是 128位了，所以都是用 pkcs7，可以看下 CryptoSwift 库，就算指定 pkcs5 实际上也用的 pkcs7

zeroPadding：
不够补 0

填充的作用是在加密前将普通文本的长度扩展到需要的长度。关键在于填充的数据能够在解密后正确的移除。

## 模式
AES 加密算法的工作模式有五种：ECB、CBC、CTR、OCF、OFB，模式之间的主题思想是近似的，在处理细节上有一些差别。常用的是 ECB(默认) 和 CBC，ECB 比较简单，易于计算，安全性较差、CBC 安全性好，但性能稍差，苹果安全团队推荐的 CBC 模式。

ECB-电码本模式
ECB是最简单的块密码加密模式，加密前根据加密块大小（AES加密块固定为128位）分成若干块，之后将每块使用相同的密钥单独加密，所以加密块相同的明文会生成相同的密文。

CBC-密码分组链接模式
CBC模式对于每个待加密的密码块在加密前会先与前一个密码块的密文异或然后再用加密器加密。第一个明文块与一个叫初始化向量的数据块异或。

# Base64
Base64 是一种编码算法，因为算法固定，任何人都可以对编码后的字符串解码，所以不能作为加密算法使用，通常用于在通过 http 超文本传输协议传输数据时，对 bytes 数组进行编码（例如图片），只支持 64 个可打印字符，包括 26 个字母的大小写字符、0 到 9 的数字、以及 + 和 /。（再加上作为垫字的"="，实际上是65个字符）----作为一个基本字符集。然后，其他所有符号都转换成这个字符集中的字符。


我们从 AppStore 下载的 app 其实都已经由苹果加壳，要砸壳后才能有办法看到汇编形式的源代码，如果我们要自己再加一层壳，可以对关键代码的方法名做一些混淆，以增加别人分析代码的复杂度，不过这对于大多数 app 来说不太值得去做，我们可以把精力放在其他更易做并且更有效率的地方，例如：

- 使用 Https 保证数据传输安全

- 不将敏感数据直接存储在沙盒里

- 调用接口时 app 要做验签，并且对传输的敏感数据进行加密

- 不要将对称加密要用到的 Key 存储在客户端

- ，加密数据通常有两种方式

    - 对称加密：文件加密和解密使用相同的密钥，AES 相对其他对称加密方式来说更安全些。

    - 非对称加密：需要公钥和私钥，用公钥对数据进行加密，只有对应的私钥才能解密，如果用私钥对数据进行加密，那么只有对应的公钥才能解密。可以用 RSA 来做非对称加密，与对称加密比较，非对称加密速度较慢，但非常安全，据说还没被破解过。
        - 苹果官方生成一对公私钥，在 iOS 系统里内置公钥，私钥由苹果后台保存，我们上传 app 到 AppStore 时，苹果后台用私钥对 app 数据进行签名，iOS 系统下载这个 app 后，用公钥验证这个签名，若签名正确，这个 app 肯定是由苹果后台认证的，并且没有被修改过。

对敏感数据进行加密通常选择对称加密，这时如何使用密钥则是一件非常重要的事，如果将密钥存储在 app 端，那么不管是做代码混淆还是在编译期动态写入密钥都是不安全的，所以建议通过接口请求向后端索取，但过程要比一般 Https 请求麻烦一些：

- 首先由客户端向服务端发起获取钥匙的请求

- 服务端生成公钥 `pk1` 和私钥 `pk2`，然后将公钥 `pk1` 发送给客户端（假设此时黑客已经获取到了公钥 `pk1` ）

- 客户端这时首先生成公钥 `pk3` 和私钥 `pk4`，然后将公钥 `pk3` 通过服务端返回的公钥 `pk1` 加密并发送给服务端（假设此时黑客截获加密后的 `pk3`，虽然知道这是由 `pk1` 加密的，但是他不知道与其对应的私钥 `pk2`，所以无法对客户端发送的公钥进行解密）

- 服务端收到加密后的 `pk3` 后可以通过私钥 `pk2` 解密，并使用 `pk3` 对生成的对称加密密钥 `xxx` 进行加密并发送给客户端（黑客这时因为不知道公钥 `pk3` 是什么，所以得不到对称加密的密钥）

- 客户端收到数据后，可以用自己的私钥 `pk4` 解密并得到对称加密用的密钥 `xxx`，客户端将密钥 `xxx` 存储在内存中，接下来两端就可以使用 `xxx` 作为 key 来加密数据并进行安全的数据传输了。





# 讲一下 HTTP 与 HTTPS 的区别

HTTPS的主要思想是在不安全的⽹络上创建⼀
安全信道，并可在使⽤适当的加密包和服务器
证书可被验证且可被信任时，对窃听和中间⼈
攻击提供合理的保护

可以选择类似 protobuf (google 提供的⼀个开源数据交
换格式，其最⼤的特点是基于⼆进制，因此⽐传统的
JSON 格式要短⼩得多) 之类的⼆进制通讯协议或者⾃⼰
实现通讯协议，对于传输的内容进⾏⼀定程度的加密，
以增加⿊客破解协议的难度。下图是我截取的淘宝客户
端的通讯数据，可以看到其中的值都不能直观地猜出内
容，所以这对于通讯协议是有⼀定的保护作⽤。



Http和Https的区别？
答：Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：

端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；

资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；

开销：Https通信需要证书，而证书一般需要向认证机构购买；

Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。






HTTP 和 HTTPS 的主要区别在于 HTTP 协议传递的是明文数据，而 HTTPS 传递的是加密过的数据，也就是说 HTTPS 更具有安全性。也正由 HTTPS 需要保证安全性，所以它的性能要比 HTTP 差一点。

单说安全性肯定是不够的，我打算扩展讲一下 HTTPS 是怎么解决安全性问题的，通过这些 HTTP 没有机制，反映出 HTTPS 与 HTTP 的区别。下面尝试把 HTTPS 加密的过程推导出来。推导过程不涉及复杂的实现细节：

如何安全地进行数据传输？
假设现在 A 和 B 要进行安全的通信，那么究竟怎样才算是安全的通信？很自然地会想到：A 和 B 之间传递数据，这些数据只有 A 和 B 才看得懂，中间人就算截取了信息但也看不懂，这才算得上安全。

安全通信的处理手段：
为了能让 A 和 B 才能看懂，就必须要对数据进行加密，而且首先想到的就是对称加密。对称加密的意思是 A 和 B 各持有一个相同的密钥，它们传递信息时会用密钥给信息加密，在消息到达端给消息解密，完成安全通信。

在对称加密中又会涉及到加密算法的选择问题。现实世界中，通常是多个客户端面向一个服务器的情况，不可能让每个客户端和服务器之间都采用相同的加密算法，如果是这样那和没加密差不多。所以注定每个客户端和服务器之间都会采用不同的加密方式。

如何让每个客户端与服务器之间都采用不同的加密方式？
要想对不同的机器使用不同的加密方式，最直接想到的就是使用随机数。也就说客户端和服务器之间每次都基于一个随机数产生加密算法。（具体实现时为了保证随机，用到还不止一个随机数）

这个产生加密算法的过程称之为协商，现在问题是协商的过程是透明的，也就是说中间人可以截获协商的过程，从而知道我们的加密方式。为了解决这个问题，我们需要对协商的过程进行加密。

如何对协商的过程进行加密？
之所以能来到这一步，是因为我们一开始就选择使用了对称加密，也就说一开始的对称加密导致了现在的问题，所以这时我们不能再使用对称加密了，否则会陷入死循环。

在密码学领域，还有一种加密过程叫非对称加密，它的逻辑是这样的：通信双方一方持有私钥，一方持有公钥，经过私钥加密的信息，都能通过公钥进行解密。但是经过公钥加密的数据，只有私钥可以解密。

按照非对称加密的规则，我们让服务器持有私钥，让客户端持有公钥。这样就能保证客户端给服务器发送消息的时候是安全的（相反，服务器给客户端发送消息就是不安全的），我们可以把协商时重要的逻辑安排在客户端给服务器发送信息的过程中，从而保证了协商过程的安全性。

客户端如何获得公钥？
现在用非对称加密算法解决了协商的安全问题，但是非对称加密的前提是客户端需要获得公钥，这又是一个问题了，客户端与服务器打交道之前是互不知道双方身份的，怎么才能让客户端获得公钥呢？

也就只有两种办法：

客户端向服务器要公钥
客户端向一个远程的公共服务器获取公钥
方法2显然是不行的，尚且不说多了一个访问节点，如何找到公共服务器的地址也是一个待解决的问题，所以还是使用方法 1。

但是方法 1 存在一个问题：如果中间人把服务器发送给客户端的公钥调包了怎么办？也就是说客户端无法知道发送公钥的是否是正真的服务器。

引入第三方机构解决问题
客户端无法辨识服务端和中间人的问题称为“身份验证”问题，也就是说我们需要为服务器向客户端发送公钥的过程进行加密。

这下完了，之前我们因遇到对称加密的瓶颈选择了非对称加密，现在使用非对称加密也遇到了瓶颈。显然这两种加密方式都是不可用的了，否则会再次陷入死循环。

接下来我们只好通过第三方机构的介入，解决这个问题。首先我们自己保存有第三方权威机构的公钥，然后第三方机构使用私钥对服务器将要发送给客户端的公钥进行加密，客户端接收到这个经加密的公钥后（数字证书），就能通过自己保存的第三方机构公钥进行解密。

“到这里为止，我们解释了 HTTPS 中使用到的对称加密，非对称加密，CA，数字证书的概念，但是还差一个叫数字签名的概念没有解释。
在现实生活中，CA 不单止会给我们正常公司发放证书，还会给中间人的坏公司发放证书，如果中间人把发放的证书调包了怎么办？这时我们仍能用 CA 的私钥进行解密，但是证书已经被调包了。

那么客户端怎样验证证书的真伪呢？答案是证书本身会告诉客户端如何辨认真伪。比方说证书上面有一个证书编号，还有一个如何计算证书编号的方法，客户端可以根据计算证书编号的方法计算出自己要获得的证书的编号，然后把这个编号和证书上的编号进行比对，如果一样证明没有被调包。

这里的证书编号指的就是数字签名，证书指的就是数字证书。

总结一下 HTTPS ：HTTPS 想要保证客户端与服务器之间的通信安全，就得使用对称加密算法进行加密。协商对称加密算法的过程通过非对称加密算法来保证。在非对称加密算法中，客户端获得公钥的过程需要第三方机构（CA）通过颁发数字证书保证安全性。

总得来说通过这一系列机制协商出了一个对称加密算法后，客户端与服务器之间就能通过该算法进行安全的通信了。


https://cloud.tencent.com/developer/article/1369607


