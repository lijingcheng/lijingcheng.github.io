接口请求过程


# 一次接口请求的生命周期
从购卡接口的调用来看一下一次接口请求设及到的知识点

- HTTPS
- tcp 三次握手
- 重要数据 AES 加密
- 请求参数的 MD5 验签
- request/response 数据加密
- RequestAdapter 的设计模式应用
- https 中 tcp 和数字证书的知识（三次握手，四次挥手）
- 数据返回时对于枚举字段在 Swift 中有坑的解决
- tcp 四次挥手

（写的时候可以参考在浏览器打开网页经历了什么，也可以是以万达项目的角度讲，还可以细到讲网络库）

# MD5
MD5 是一种生成信息摘要的算法，可以从任意长度的明文字符串生成128位的哈希值。常用于对接口传输数据做验签，以保证数据传输安全，验签过程：

1.发送方和请求方约定相同的字符串拼接规则，约定相同的密钥。
2.第三方平台接到支付请求，按规则拼接业务参数和密钥，利用MD5算法生成Sign。
3.用第三方平台自己生成的Sign和请求发送过来的Sign做对比，如果两个Sign值一模一样，则签名无误，如果两个Sign值不同，则信息做了篡改。这个过程叫做验签。

MD5 是可以破解的

破解方式并不是将 MD5 后的数据摘要还原成明文，因为128位的摘要是有穷的，而原文数量是无穷的，每一个摘要都可以由若干个原文通过Hash得到。所以对于 MD5 的破解都是通过碰撞的方式实现，也就是字符串生成的 MD5 摘要一样，

设MD5的哈希函数是H（X），那么：
H(A) = M
H(B) = M
任意一个B即为破解结果。B有可能等于A，也可能不等于A。

MD5碰撞通常用于登陆密码的破解。应用系统的数据库中存储的用户密码通常都是原密码的MD5哈希值

常用碰撞方法

- 暴力枚举法：通过枚举出所有原文并计算哈希，然后再看哪个哈希和给定的摘要一致，这种办法时间复杂度极度。
- 字典法：用现成的字典存储尽可能多的原文和哈希值，然后用指定的信息摘要去查找对应的原文，这种办法占空间大，但速度快
- 彩虹表：过于复杂。。。
- 差分攻击：过于复杂。。。

对于单机来说，暴力枚举法的时间成本很高，字典法的空间成本很高。但是利用分布式计算和分布式存储，仍然可以有效破解MD5算法。因此这两种方法同样被黑客们广泛使用。

# SHA
和 MD5 相似，也是一种生成信息摘要的哈希算法，MD5 的摘要长度为 128bit，SHA-1 的摘要长度为 160bit，虽然只多出了 32bit，但不同明文的碰撞几率降低了2^32 = 324294967296倍。2005 年时人们就研究出了破解 SHA-1 的办法，目前常用的有 SHA-256 和 SHA-512，信息摘要越长，发生碰撞的几率就越低，破解的难度就越大。但同时，耗费的性能和占用的空间也就越高。所以要按需要去选择。如果只是验证数据完整性，SHA-256 就足够了。如果希望安全性更高一些还可以考虑 MD5 和 SHA256 结合起来使用，可以将明文同时生成 MD5 摘要和 SHA-256 摘要，然后按规则各取一部分进行摘要合成，例如用 MD5 摘要的前 16 位字符拼接 SHA-256 摘要的后 32 位字符。

明文：        abcd
MD5摘要：
e2fc714c4727ee9395f324cd2e7f331f
SHA-256摘要：
88d4266fd4e6338d13b845fcf289579d209c897823b9217da3e161936f031589

合成摘要：
e2fc714c4727ee93209c897823b9217da3e161936f031589


# AES
AES 是典型的对称加密算法，可以避免信息在传输过程中被中间人截获并窥探到消息内容，对称加密算法与 MD5 和 SHA 这种摘要算法不同在于，摘要算法是不可逆的，主要作用是对信息一致性和完整性的校验，而对称加密算法是可逆的，主要作用是保证隐私信息不被泄露。

具体工作的步骤如下：
1.发送方利用密钥123456，加密明文“我是小灰”，加密结果为TNYRvx+SNjZwEK+ZXFEcDw==。
2.发送方把加密后的内容TNYRvx+SNjZwEK+ZXFEcDw==传输给接收方。
3.接收方收到密文TNYRvx+SNjZwEK+ZXFEcDw==，利用密钥123456还原为明文“我是小灰”。

要学习 AES 算法，首先要清楚三个基本概念：密钥、填充、模式，这三点也是在使用 AES 加密时要和后台开发人员确认的三点，两端要用相同的密钥、填充方式和模式。

## 密钥
密钥是AES算法实现加密和解密的根本。对称加密算法之所以对称，是因为这类算法对明文的加密和解密需要使用同一个密钥。AES支持三种长度的密钥：128位，192位，256位
平时大家所说的AES128，AES192，AES256，实际上就是指的AES算法对不同长度密钥的使用。AES256安全性最高，AES128性能最好（常用），原因是它们的加密处理轮数不同。

我们在调用封装好的AES算法时，表面上使用的Key并不是真正用于AES加密解密的密钥，而是用于生成真正密钥的“种子”。例如在我们项目中使用的 key 是 16字节的字符串，一字节 8 位，所以我们会生成 128 位的密钥。

## 填充
AES算法在对明文加密的时候，并不是把整个明文一股脑加密成一整段密文，而是把明文拆分成一个个独立的明文块，每一个明文块长度128bit。这些明文块经过AES加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。假如一段明文长度是192bit，如果按每128bit一个明文块来拆分的话，第二个明文块只有64bit，不足128bit。这时就需要对明文块进行填充（Padding）。（Common Crypto 对于 AES128 和 AES256，都是以 128bit 来拆分块，不支持以 256bit 拆分，如有要求需要自己实现）

- 使用哪种填充方式：noPadding, zeroPadding, pkcs7, pkcs5

noPadding：

不做任何填充，但是要求明文必须是16字节的整数倍。

PKCS5Padding（默认）：

如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字符，且每个字节的值等于缺少的字符数。

比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6}

pkcs7 秘 pkcs5 在 iOS 上一样。

pkcs#5填充和pkcs#7填充算法没有任何区别。.不同点：在PKCS5Padding中，明确定义Block的大小是8位，而在PKCS7Padding定义中，对于块的大小是不确定的，可以在1-255之间（块长度超出255的尚待研究）。现在最少都是 128位了，所以都是用 pkcs7，可以看下 CryptoSwift 库，就算指定 pkcs5 实际上也用的 pkcs7

zeroPadding：
不够补 0

填充的作用是在加密前将普通文本的长度扩展到需要的长度。关键在于填充的数据能够在解密后正确的移除。

## 模式
AES 加密算法的工作模式有五种：ECB、CBC、CTR、OCF、OFB，模式之间的主题思想是近似的，在处理细节上有一些差别。常用的是 ECB(默认) 和 CBC，ECB 比较简单，易于计算，安全性较差、CBC 安全性好，但性能稍差，苹果安全团队推荐的 CBC 模式。

ECB-电码本模式
ECB是最简单的块密码加密模式，加密前根据加密块大小（AES加密块固定为128位）分成若干块，之后将每块使用相同的密钥单独加密，所以加密块相同的明文会生成相同的密文。

CBC-密码分组链接模式
CBC模式对于每个待加密的密码块在加密前会先与前一个密码块的密文异或然后再用加密器加密。第一个明文块与一个叫初始化向量的数据块异或。

# Base64
Base64 是一种编码算法，因为算法固定，任何人都可以对编码后的字符串解码，所以不能作为加密算法使用，通常用于在通过 http 超文本传输协议传输数据时，对 bytes 数组进行编码（例如图片），只支持 64 个可打印字符，包括 26 个字母的大小写字符、0 到 9 的数字、以及 + 和 /。（再加上作为垫字的"="，实际上是65个字符）----作为一个基本字符集。然后，其他所有符号都转换成这个字符集中的字符。


我们从 AppStore 下载的 app 其实都已经由苹果加壳，要砸壳后才能有办法看到汇编形式的源代码，如果我们要自己再加一层壳，可以对关键代码的方法名做一些混淆，以增加别人分析代码的复杂度，不过这对于大多数 app 来说不太值得去做，我们可以把精力放在其他更易做并且更有效率的地方，例如：

- 使用 Https 保证数据传输安全

- 不将敏感数据直接存储在沙盒里

- 调用接口时 app 要做验签，并且对传输的敏感数据进行加密

- 不要将对称加密要用到的 Key 存储在客户端

- ，加密数据通常有两种方式

    - 对称加密：文件加密和解密使用相同的密钥，AES 相对其他对称加密方式来说更安全些。

    - 非对称加密：需要公钥和私钥，用公钥对数据进行加密，只有对应的私钥才能解密，如果用私钥对数据进行加密，那么只有对应的公钥才能解密。可以用 RSA 来做非对称加密，与对称加密比较，非对称加密速度较慢，但非常安全，据说还没被破解过。
        - 苹果官方生成一对公私钥，在 iOS 系统里内置公钥，私钥由苹果后台保存，我们上传 app 到 AppStore 时，苹果后台用私钥对 app 数据进行签名，iOS 系统下载这个 app 后，用公钥验证这个签名，若签名正确，这个 app 肯定是由苹果后台认证的，并且没有被修改过。

对敏感数据进行加密通常选择对称加密，这时如何使用密钥则是一件非常重要的事，如果将密钥存储在 app 端，那么不管是做代码混淆还是在编译期动态写入密钥都是不安全的，所以建议通过接口请求向后端索取，但过程要比一般 Https 请求麻烦一些：

- 首先由客户端向服务端发起获取钥匙的请求

- 服务端生成公钥 `pk1` 和私钥 `pk2`，然后将公钥 `pk1` 发送给客户端（假设此时黑客已经获取到了公钥 `pk1` ）

- 客户端这时首先生成公钥 `pk3` 和私钥 `pk4`，然后将公钥 `pk3` 通过服务端返回的公钥 `pk1` 加密并发送给服务端（假设此时黑客截获加密后的 `pk3`，虽然知道这是由 `pk1` 加密的，但是他不知道与其对应的私钥 `pk2`，所以无法对客户端发送的公钥进行解密）

- 服务端收到加密后的 `pk3` 后可以通过私钥 `pk2` 解密，并使用 `pk3` 对生成的对称加密密钥 `xxx` 进行加密并发送给客户端（黑客这时因为不知道公钥 `pk3` 是什么，所以得不到对称加密的密钥）

- 客户端收到数据后，可以用自己的私钥 `pk4` 解密并得到对称加密用的密钥 `xxx`，客户端将密钥 `xxx` 存储在内存中，接下来两端就可以使用 `xxx` 作为 key 来加密数据并进行安全的数据传输了。






# 面试题

## 组件化
0、怎么分的组件
1、跨组件的资源访问如何处理
2、跨组件的页路路由跳转怎么处理的
3、打二进制包的优缺点，问对方是怎么平衡或者说是怎么处理的
4、打包方式、组件版本管理、组件代码分支管理，是人工管理还是角本化，角本化做到了什么程度
5、使用静态库或动态库对项目有什么影响
6、去 Model 有什么利弊

## 设计模式
### 单例模式优缺点，使用时需要注意什么？
实例需要访问某些共享资源时可以考虑使用单例模式，这样可以实现线程安全，避免线程同步问题，例：NSFileManager、NSUserDefaults。正确的使用单例模式能够节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。如果使用不当的话单例类很容易变得职责过重，违反单一职责原则，并且单例类比较不容易扩展，因为只有一个实例，所以不适合需要保存实例状态的场景。还要注意单例只有在程序被杀掉时才会释放，所以偶尔使用一次又很占内存的对象需要慎重考虑使用。
 
### 使用继承时需要注意什么，什么情况适合用什么情况不适合用
需要遵守里氏替换原则，使用父类的地方必须能够使用其子类，但父类未必能胜任子类做的事情，如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开继承关系，改为通过依赖、聚合、组合等方式来实现代码的复用。不要为了代码重用而用继承。
 
## 数据库
- 新版本 app 对数据库有较大变更时如何设计版本迁移方案？如果新增一个字段，对字段有什么限制？
表中数据  -->  临时表  -->  新表    （放事务里） 如果直接新加字段，则新加字段不能设计成”非空“

- 索引有什么用，应该怎么用？

## 缓存
如何给网络库设计数据缓存功能
1、每个接口可配置对应数据的缓存时间，每次请求接口时检查数据是否有效
2、缓存数据通过 key 查找，key = path + params
3、当内存缓存达到一定程度后，将超出数据转为文件缓存
4、每隔几分钟清理一次过期缓存
 
## 微信支付流程
从点支付按钮开始到订单详情页，为什么需要轮询支付状态接口?怎么改善轮询效率？

## OAuth 授权流程
在手机上点击微信登录后都发生了什么，微信和微博在流程上有什么区别？
 OAuth 是一个关于授权的网络标准，它有四种授权方式
 授权码模式（微信，这是最安全的授权方式）
 简化模式（微博、QQ，与授权码模式不同的是省略了下发 code 这一步）
 密码模式
 客户端模式
 
在微信平台注册并申请微信登录权限，会获得 weixinId 和 weixinSecret
用户点击微信登录，微信用收到的 bundleId 和 weixinId 查询到咱们 app 在微信平台上注册过并拥有登录权限，然后询问用户是否允许 app 拿到登录权限以及用户基础数据，包括头像和昵称，用户允许后微信会根据此手机用户的微信账号生成 code 并通过微信 iOS SDK 返回，我们将 code 发送给后台，后台将 code 和 weixinSecret 一起发送给微信开发平台用来获取 accessToken 和 openId，获得后再根据此内容去拿用户在微信中的头像和昵称，判断此数据在用户表里是否存在，存在就直接登录，如果没有会创建新用户，然后要求用户绑定手机号。
 
微博使用的简化模式没有下发 code 这一步，直接返回 accesstoken 和 openId，相对来说微信使用的授权码模式更安全一些，能避免特殊用户拿到 accesstoken 后做一些随意调用开放平台 API 的事情，所以微博总是会出现有人刷粉的现象。

## Runtime
- Categroy 为什么不能直接添加属性，而是要用的关联对象(Associated Objects)的方式添加？关联对象是怎么存储对象的
- 多个 Categroy 文件添加相同方法，程序在运行时会出现什么问题，怎么解决？

## 多线程
如何解决多个线程同时对属性进行修改和读取时产生的同步问题

dispatch_barrier_async 能够高效的解决属性的同步问题（get 方法可以并发执行，但是 set 方法只能同步执行并且在执行过程中 get 方法不能同时执行）

```objc
_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
- (NSString *)userName {
    __weak NSString *localUserName;
    dispatch_sync(_syncQueue, ^{
        localUserName = _userName;
    }
    return localUserName;
}
    
- (void)setUserName:(NSString *)userName {
    dispatch_barrier_async(_syncQueue, ^{
        _userName = userName;
    }
}
```

## 内存管理
### 循环引用
A -> B -> C 没问题，即使 A -> C 也没问题，因为没有 “环”
A -> B -> C -> A 都释放不了
A -> B -> C -> B 只有 A 能释放，这也说明了不在 “环” 里的对象就不受影响

### 自动释放池工作原理
苹果是如何实现 AutoReleasePool 的 （AutoreleasePoolPage 对象组成的双向链表，Page 对象通过 next 指针实现用栈的结构形式存储 autorelease 对象，next 指针会被初始化在栈底，当有 autorelease 对象入栈时，next 便会指向下一地址，当 Page 空间被占满便指向栈顶，这时如果再添加 autorelease 对象，便会交给新建的 Page 对象存储，并连接链表。）

- autorelease 的对象何时被释放

- 是否需要为子线程开启 Runloop （添加 autorelease 对象时，如果发现线程没有 AutoreleasePoolPage 则会创建新的，所以不用担心子线程中没开启 Runloop 导致的内存泄露问题。）

## Runloop
RunLoop 能够保持程序始终运行并监听处理分发事件，当没有事件发生时进入休眠状态，有事件发生时系统会将接收到的事件放在一个队列里，然后唤醒 RunLoop 依次处理事件，使用队列不仅可以解决线程同步问题也促使我们要把更新 UI 的代码放在主线程中运行，以免由于多个线程抢占资源产生奇怪的问题。RunLoop 可以接收的事件来自两种不同的来源，分别是输入源和定时源，输入源传递异步事件，事件通常来自于其他线程或程序，如一些 UI 事件等。定时源则传递同步事件，发生在特定时间或者重复的时间间隔，如 NSTimer。

## 响应链
- 点击按钮后，事件是怎么通过响应者链进行传递的？

- 当子视图添加到父视图后，默认情况下其响应事件的范围就是父视图的 bounds，如果部分界面超出了这个范围，则超出部分无法响应事件，未超出部分仍然可以响应事件，如何实现超出部分也能够响应事件

```objc
// hitTest 方法返回的视图会作为响应者来处理事件，如果返回 nil，则事件会传递给下一响应者
 - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
     UIView *view = [super hitTest:point withEvent:event];
     
     if (!view) {
         for (UIView *subView in self.subviews) {
             CGPoint p = [subView convertPoint:point fromView:self];
             if (CGRectContainsPoint(subView.bounds, p)) {
                 view = subView;
             }
         }
     }
     
     return view;
 }
```

## Swift
### Swift ABI 稳定后的好处是什么？
ABI 稳定后好处是包体积减少并且启动速度变快，坏处是开发时需要考虑系统兼容性。

ABI 代表应用程序二进制接口，它定义了编译后的代码在运行时如何与其他库通信，例如函数如何调用，数据如何在内存中呈现等

ABI 稳定之前，Swift runtime 是被作为库打包到 app 中，所以在开发时我们可以随意使用新版本 Swift 的类型或特性，当 ABI 稳定后，Swift runtime 存在于用户的手机系统中，当 Swift 语言的新特性要求更高的 Swift runtime 版本时，就需要考虑设备兼容问题，这和我们一直以来适配新系统 API 的情况一样，需要判断代码是否能够在 iOS 12.2系统下执行
 
Xcode10.2+ 搭载了 Swift5.0 版本的编译器，用它打出的包能够运行在 Swift 5 的运行时环境中，即使你使用的语言是 Swift 4 也没关系
 iOS12.2+ 系统预装了 Swift 5 运行时环境，使用 Xcode10.2+ 打出的 app 包安装在这个系统上时，系统会将安装包中与系统重复的 Swift 动态库删掉
 
### Swift 为什么将 String,Array,Dictionary 设计为值类型?
值类型和引用类型相比,最大优势可以高效的使用内存，值类型在栈上操作，引用类型在堆上操作，栈上操作仅仅是单个指针的移动，而堆上操作牵涉到合并,位移,重链接，Swift 这样设计减少了堆上内存分配和回收次数，使用 copy-on-write 将值传递与复制开销降到最低。

### 值类型 VS 引用类型
Swift 中的所有的基本类型和枚举都是值类型，它们在底层都是以结构体的形式所实现，所以结构体是值类型，类是引用类型。值类型数据在进行函数传递时会被拷贝，引用类型不会。当定义数据结构的目的是用来封装简单的数据值，并且希望该数据结构在被赋值或传递时，封装的数据及其内部存储的属性也能够通过值传递，那么适合用结构体来定义它。Swift 中类和结构体都支持属性、方法、下标、构造器、扩展和协议，与结构体相比，类还支持继承、多态、用析构器释放所分配资源以及用引用计数对一个类进行多次引用。另外引用类型对象存储在堆上，值类型在栈上，栈的操作仅仅是指针的上下移动，而堆的操作会因内存的分配和回收产生合并、移位、重新链接等行为，所以使用结构体效率会高一些。另外值类型在复制时，复制的对象和原对象实际上在内存中指向同一个对象。只有当复制后的对象被修改时才会在内存中重新创建一个新的对象，通过 copy-on-write 这种的方式提高效率。

### Swift 语言特性
可选Optional、Guard、defer、tuple、尾随闭包、类型推断、支持泛型、引入了命名空间、结构体可添加方法、支持拓展、支持协议，函数支持可选参数，支持多返回值，支持函数入参， if a = c (X)


### 利用 Swift 语言特性写一个函数，用来交换数组中的两个元素。

func swap<T>(_ num1: inout Int, _ num2: inout Int) {
    (num1, num2) = (num2, num1)
}

## Http 建议连接时为什么要进行第三次握手
第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。因此，需要三次握手才能确认双方的接收与发送能力是否正常。

## 社区多图片状态的 cell 如何设计

## 在数组中找出第一个只出现一次的数字
可用哈希表实现，哈希表最主要的优点是效率高 0(1)，缺点是需要额外的空间来实现哈希表。用数组中的数字作为key，数字出现次数作为value

## 讲一下 tableview 的重用机制是怎么实现的，如何优化 tableview 的滚动效率？
 
## 平时通过什么渠道学习

## 商店里 app size 60M 手机上 40M + 10M 数据，这是为什么?

## NotificationCenter
通知中心会以 Set 存储注册通知的关系，所以通知发出后，响应者们收到通知的顺序是无序的
 
## NSTimer、CADisplayLink、GCD区别
NSTimer和CADisplayLink都是注册在Runloop上的，所以当Runloop忙碌时造成触发不及时问题，NSTimer如果延迟超过了一个周期，则会在延时结束后立刻执行，CADisplayLink是和屏幕刷新率同步的定时器，适合做界面的不停重绘，比如视频播放的时候需要不停地获取下一帧用于界面渲染，或者做动画。如果CPU过于繁忙，无法保证屏幕60次/秒的刷新率，就会导致跳过若干次调用回调方法的机会。GCD通过自己的调度机制实现定时器，相对来说最精确，


## 老鼠毒药问题，有 1000 个一模一样的瓶子，其中有 999 瓶是普通的水，有一瓶是毒药。任何喝下毒药的生物都会在一星期之后死亡。现在，你只有 10 只小白鼠和一星期的时间，如何检验出哪个瓶子里有毒药？
把瓶子从 0 到 999 依次编号，然后全部转换为 10 位二进制数。让第一只老鼠喝掉所有二进制数右起第一位是 1 的瓶子，让第二只老鼠喝掉所有二进制数右起第二位是 1 的瓶子，等等。一星期后，如果第一只老鼠死了，就知道毒药瓶子的二进制编号中，右起第一位是 1 ；如果第二只老鼠没死，就知道毒药瓶子的二进制编号中，右起第二位是 0 ⋯⋯每只老鼠的死活都能确定出 10 位二进制数的其中一位，由此便可知道毒药瓶子的编号了。

因为只有生和死两种状态，所以将编号转为二进制，如果是题目扩展成可以测两轮的话，问可以测多少瓶水中的一瓶毒药？或者问1000瓶水最少需要几只老鼠，因为此时状态有三种：一轮死、两轮死、都不死，所以可将编号转为三进制，便可得知10只小老鼠能测多少瓶水，或1000瓶水最少能用几只小老鼠测

## 视图渲染及为什么要做双缓冲，并且双缓冲技术会有什么问题，系统是如何解决的
计算机将存储在内存中的形状转换成实际绘制在屏幕上的对应的过程称为渲染. CPU 负责创建视图、计算布局、图片解码等操作后将结果保存起来，然后在下一次 Runloop 触发时发送给独立负责渲染的进程 Render Server，然后由它将内容提交至 GPU，GPU 渲染完成后将渲染结果存入帧缓冲区，视频控制器会按照 VSync信号逐帧读取帧缓冲区的数据，经过数据转换后最终由显示器进行显示，

在单缓冲的情况下，GPU输出了一帧画面，缓冲区就需要马上获取这个画面，并交给显示屏去显示，而这段时间GPU输出的画面就全都丢失了，因为没有缓冲区去承载这些画面，就会造成画面的闪烁。iOS使用的双缓冲机制是用于避免或减少画面闪烁的问题，GPU 会预先渲染一帧放入一个缓冲区中，用于视频控制器的读取。当下一帧渲染完毕后，GPU 会直接把视频控制器的指针指向第二个缓冲器，如此循环操作。双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。

## 僵尸对象
访问僵尸对象（已经释放）时会出现 EXC_BAD_ACCESS 错误，可以打开僵尸对象调试功能来调试，这时虽然还是会崩溃，但 Xcode 会告诉你是哪个对象出的问题开僵尸对象的原理是，在对象释放（retainCount为0)时，使用一个内置的Zombie对象，替代原来被释放的对象。无论向该对象发送什么消息（函数调用），都会触发异常，抛出调试信息。

##FPS卡顿检测
目前我们要采集的方主要是基于CADisplayLink以屏幕刷新频率同步绘图的特性，观察屏幕当前帧数的指示器，若帧率少于指定的帧率看成一个FPS卡顿。

##卡顿检测
使用监听线程监听 Runloop 的 kCFRunLoopBeforeWaiting 和 kCFRunLoopAfterWaiting 这两个状态的间隔，如果消耗时间太久，就代表着卡顿的发生。

## Tagged Pointer 
可以节省内存和提高执行效率，它用于优化NSNumber、NSDate、NSString 等小对象的存储，它可以直接在指针中存储数据，当指针不够存储数据时再使用动态分配内存的方式。








 
 
 
 
 重构原则
 
 要充分理解旧代码后再进行修改，模块之间过度耦合导致牵一发而动全身，不易控制影响范围，有时代码摆放顺序的修改都会造成问题

 优先重构经常修改的部分，如果代码一两年都没有修改过，那么说明改动的收益很小

 重构可能需要很长时间，并且不是非要一次做完，主要取决于团队对于风险的容忍程度

 删除无用代码是提高代码可维护性最有效的方式

 小范围重构，当重构后会导致大量测试工作时，需要谨慎决定是否有必要重构

 要构建可扩展系统，我们需要认同错误的不可避免性，有时候避免这些错误会带来高昂的成本，因此我们不妨将注意力集中在对问题的快速检测以及出现后的应对措施上

 哪种代码需要重构
 臃肿的类：一个类应该只做一件事，可通过一些设计模式去拆分

 长方法：方法应尽量短小，专注一个功能点，并且要放在合适的类里

 重复代码：往往由于开发人员对框架不熟悉，也有个别不讲究的情况

 方法有多个参数：可通过提取成类对象或字典解决，个别情况也可拆分方法

 魔鬼数字：尽量用常量去定义数字，或在使用处添加注释说明用意

 模糊的命名：要做到见名知意

 if/else 嵌套过多：尽量不超过3层，如果不能简化逻辑，可通过拆分方法或添加注释方式解决

 
0、UIScrollView 的滚动效果是怎么实现的？
当 contentSize 比 bounds 大的时候，用户可以滚动视图，这时我们首先会观察到 contentOffset 的变化，而它的值会做为 UIScrollView 内部视图的 bounds 的 origin，并在修改时通过 layoutSubviews 对子视图进行布局。
        
1、Objective-C 开发时为什么不建议在 init 里用 self.name = name 而是要用 _name = name？在 Swift 开发时也存在这种问题吗？为什么？
因为苹果不保证 name 能够初始化成功，也许你用属性方式从来没发现有问题，但是有隐患，比如在 name 未初始化成功时，如果对它使用了 KVO 或者有子类重写了 setName 时，并把 name 当有有值情况来使用时会出问题，Swift没有这问题，因为在初始化方法里会要求自己以及父类的所有属性都必须初始化，这和OC不同
        
      


岗位描述
 1.负责时光网和万达电影 iOS 客户端程序的设计开发;
 2.参与产品需求讨论，功能定义;
 3.在版本迭代过程中持续优化代码质量和性能;
 
 任职要求
 1.计算机相关专业本科及以上学历，四年及以上 iOS 开发经验;
 2.熟练使用 Swift 语言开发，并具有良好的代码风格;
 3.熟悉多线程开发，深入理解 Objective-C Runtime 运行机制和内存管理机制;
 4.熟练使用 Instrument，有丰富的性能调优经验;
 5.具有扎实的数据结构、算法基础和解决问题的能力;
 6.具有强烈的责任心和团队精神，善于沟通与合作;
 7.有较成熟产品的开发经验，能够独立承担模块的设计开发和技术选型;

英语语法

学习语法之前首先要明白什么是主语、主语、谓语和宾语。。。。其中主语和谓语是每个句子中都有的元素，其中谓语在句子中只会有一份

- 主语：是谈论的话题，所有的英语句子中必须有主语，这与汉语不同
    例如这样2句话，A句主语是I，B句主语是The Cake，一个强调我做了cake，一个强调cake是我做的
    A：I made a cake.
    B：The cake was made by me.
    
- 谓语：用来陈述主语的内容，通常是个动作，例如 I came. 主语强调是“我”，谓语说明“我”“来了”，谓语一般在主语后面，一句话只能有一个动词，例 He went to Beijing met the star.，went 和 met 两个动词，容易让人迷惑他是去北京了还是去见明星了，如果要表达他去北京见明星的话，应该把后面的改成 meeting


- 宾语：宾语是主语动作的对象，是动作的承受者，一句话里可以有两个宾语，例如：I geive somebody something.
2.He is a teacher.（主语是 He，is是系动词，联系主语He 和 “a teacher”，表示二者的关系：他是老师。“a teacher”在这里叫做 表语（表达表述主语的内容），也叫做“补语”，补充说明主语“He”到底是什么。）

- 定语
定语是填补名词的语意缺失的，作用是让名词的意思更明确

The beautiful girl is watching TV.（此句中，beautiful作定语，修饰girl。与girl一起构成了一个名词短语：漂亮的女孩。一起作为句子中的主语） 

- 状语
让句子中“动作”的修饰意义更加完整，与定语的区别是，定语修改名词形成短语，状语修饰动词表达程度。
He speaks English very well.very well 是修改speak 的状语

- 补语
句子中，起补充说明作用的成分，叫做补语。补语分为主语补足语和宾语补足语两大类。前者就是大家熟悉的「表语」，后者就是「宾补」

You are my sunshine. 主语+谓语+主补/表语

I made your English better. 主语+谓语+宾语+补语
better是 your english 的补足语，如果没有 better那句子的意思就不完整了。

# 造句
## 简单句
### 主 + 谓
I remember.
### 主 + 谓 + 宾
I like you.
### 主 + 系 + 表 （系代表系动词，就是起到联系作用的动词，最常见的系动词就是be动词，就是能翻译成“是”的那些词。比如am is are was were，都是系动词）
I am a student.
### 主 + 谓 + 宾 + 宾
I told you a story.
### 主 + 谓 + 宾 + 宾补
The story made you happy.
## 并列句
## 复合句
### 定从
### 状从
### 名从
## 特殊语式
### 倒装
I seldom go to work by bus.
->
Seldom do I go to work by bus.
后面这个就是倒装句，强调很少坐公交上班，上面的句子也对，但容易搞不明白是强调 work 还是 by bus
### 强调
### 省略
### 祈使
### 感叹
### 反义疑问句




# 用词
## 实词
- 名
- 形
- 动
    - 谓语动词：时态、语态、情态、虚拟
    - 非谓语动词：不定式、动名词和分词
- 副
- 数
- 代
## 虚词
- 冠
- 介
- 感
- 连 


英语流利说

LLVM 的核心是中间表示（intermediate representation，IR）。LLVM 所支持的语言使用 编译器前端（compiler frontend） 生成 IR，再使用 编译器后端（compiler backend） 将 IR 生成所支持平台的机器码。


# Mach-O
Mach-O（Mach Object File Format)是一种用于记录可执行文件、对象代码、共享库、动态加载代码和内存转储的文件格式。App 编译生成的二进制可执行文件就是 Mach-O 格式的，iOS 工程所有的类编译后会生成对应的目标文件 .o 文件，而这个可执行文件就是这些 .o 文件的集合。

Mach-O 文件主要由三部分组成：

• Mach header：描述 Mach-O 的 CPU 架构、文件类型以及加载命令等；

• Load commands：描述了文件中数据的具体组织结构，不同的数据类型使用不同的加载命令；

• Data：Data 中的每个段（segment）的数据都保存在这里，每个段都有一个或多个 Section，它们存放了具体的数据与代码，主要包含这三种类型：
￮ __TEXT 包含 Mach header，被执行的代码和只读常量（如C 字符串）。只读可执行（r-x）。
￮ __DATA 包含全局变量，静态变量等。可读写（rw-）。
￮ __LINKEDIT 包含了加载程序的元数据，比如函数的名称和地址。只读（r–-）。



## 编译
LLVM 项目是模块化、可重用的编译器以及工具链技术的集合。

- Frontend：前端编译器对源码做语法分析、语义分析、生成中间代码，在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行。（Clang 负责 C/C++/Objective-C，swiftc 负责 Swift）
- Optimizer：优化器用于中间代码优化，使得代码效率更高，体积更小。
- Backend：后端编译器负责把优化后的 bitcode 针对不同的架构，比如arm64等生成不同的机器码。

点击 Run 之后 app 做了什么
1.预处理，宏替换，删除注释，展开头文件
3.编译（根据 build configuration 得知头文件的位置，编译器就开始生成机器码）
4.静态连接（根据 build configuration 得知需要的静态库在哪，进行连接考贝）
5.编译拷贝xib文件  图片等资源文件到结果目录
6.代码签名
7.安装（将可执行文件拷贝到设备的安装目录）
8.连接操作系统（可能会做些验证签名之类的事）
9.在启动后进行动态链接


# 网络
### 分层
- 应用层：为程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。
- 传输层：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。

建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。我们必须在数据包中加入端口信息，这就需要新的协议，包括不可靠的 UDP 和可靠的 TCP

- 网络层：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。

定义网络地址来区分不同计算机是否在一个子网络，网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。
目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。

- 数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。

规定信号的解读方式，用以太网协议制定 0  和 1 的分组方式，以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（包括发送者、接受者等）和数据。发送者和接受者的信息通过 网卡中的 MAC 地址标识

- 物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

用光缆、电缆、双绞线、无线电波等方式把电脑连接起来，传送 0 和1 的电信号
     
### 三次握手
三次握手其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。

假设 A 为客户端，B 为服务器端，首先 A 处于关闭状态，B 处于 LISTEN 状态

- A 向 B 发送连接请求报文并指明 A 的初始序列号(ISN:Initial Sequence Number) seq=x，同步位 SYN=1，ACK报文段不可以携带数据，这时 A 处于 SYN_SEND 状态
- B 收到连接请求报文后说明 A 的发送能力正常，但不清楚 A 的接收能力是否正常，然后 B 向 A 发送确认报文并指明 B 的初始序列号 seq=y，SYN=1，ACK=1，确认号 ack=x+1，这时 B 处于 SYN_REVD 状态，B 会把这种状态的请求放到一个队列中，称为半连接队列
- A 收到 B 的连接确认报文说明 B 的接收和发送能力正常，然后 A 向 B 发出确认，确认号为 ack=y+1，序号为 x+1，ACK=1，ACK报文段可以携带数据，这是 A 处于 ESTABLISHED 状态，B 收到 A 的确认后说明 A 的接收能力也是正常的，于是 B 也处于 ESTABLISHED 状态，此时双方连接建立，B 这时会将已经建立连接的请求放到一个队列中，称为全连接队列

![](media/15711083866057/15713925070707.jpg)

#### 三次握手的原因
第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。因此，需要三次握手才能确认双方的接收与发送能力是否正常。

#### ISN(Initial Sequence Number) 为什么不是固定的
当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。     
#### 为什么只有第三次握手时才可以在报文中携带数据
第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据，服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。

### 四次握手关闭连接
TCP 的连接的关闭需要发送四个包，因此称为四次挥手，这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。客户端或服务器均可主动发起挥手动作。

A 和 B 都处于 ESTABLISHED 状态（以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1）

- A 发送连接释放报文，FIN=1，这时 A 处于 FIN_WAIT1 状态。
- B 收到之后发出确认报文，此时 TCP 属于 CLOSE_WAIT 半关闭状态，A 到 B 的连接释放了，A 收到 B 的确认后进入 FIN_WAIT2 状态，等待 B 发出连接释放报文，此时 B 能向 A 发送数据但是 A 不能向 B 发送数据。
- 当 B 不再需要连接时，发送连接释放报文，FIN=1，此时 B 处于 LAST_ACK 状态。
- A 收到后发出确认报文后进入 TIME-WAIT 状态，等待 2 MSL（Maximum Segment Lifetime 最大报文存活时间）后关闭连接。B 收到 A 的确认后关闭连接，状态为 CLOSED。 
这个过程可以用以下四句形象的对话表示：
A：我要关闭连接了。
B：你那边的连接可以关闭了。
B：我这边也要关闭连接了。
A：你那边的连接可以关闭了。
由于连接是双向的，所以双方都要主动关闭自己这一侧的连接。

![](media/15711083866057/15713924947008.jpg)


#### 四次挥手的原因
三次握手连接时，B 可以同时向 A 发送 SYN 同步报文和 ACK 应答报文，但是关闭时 B 收到 FIN 报文时很可能不会立即关闭 Socket，所以只能先回复一个 ACK 报文，告诉 A 你发的 FIN 报文我收到了，然后就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。


#### 四次挥手释放连接时，等待2MSL的意义?
为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在 LAST-ACK 状态的服务器收不到对 FIN-ACK 的确认报文。服务器会超时重传这个 FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

# 
HTTPS(HTTP Secure) 就是在 HTTP 协议基础之上加入加密以及认证机制的 HTTP。使得 HTTP 先与 SSL 通信，再由 SSL 和 TCP 通信，而不是 HTTP 直接与 TCP 通信






### HTTPS为什么安全
HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。


它同时需要对称加密算法和非对称加密算法：
“非对称加密”的加密算法，特点是私钥加密后的密文，只要是公钥，都可以解密，但是公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人


“数字证书”，证书中只有服务器交给第三方机构的公钥，而且这个公钥被第三方机构的私钥加密了，如果能解密，就说明这个公钥没有被中间人调包。因为如果中间人使用自己的私钥加密后的东西传给客户端，客户端是无法使用第三方的公钥进行解密的。

- 服务端将生成的公钥交给第三方机构
- 第三方机构将收到的公钥用自己的私钥加密后传给客户端（发送内容包括加密后的服务器公钥和第三方机构自己提供的公钥）
- 客户端使用第三方机构的公钥进行解密操作得到服务端的公钥，然后用它加密数据发送给服务端
- 服务端用自己的私钥解密数据



https单向验证流程：
- 用户发起请求
- 服务器响应后返回一个证书，证书中包含一些基本信息和公钥。
- 用户拿到证书后，去验证这个证书是否合法，不合法，则请求终止。合法则生成一个随机数，作为对称加密的密钥，用服务器返回的公钥对这个随机数加密。然后返回给服务器。
- 服务器拿到加密后的随机数，利用私钥解密，然后再用解密后的随机数（对称密钥），把需要返回的数据加密，加密完成后数据传输给用户。
- 最后用户拿到加密的数据，用一开始的那个随机数（对称密钥），进行数据解密。整个过程完成。

双向认证相对于单向仅多了服务端验证客户端这一步。


用 HTTPDNS 来优化解析速度以及防止 DNS 劫持  原理很简单，就是自己做域名解析的工作，通过 HTTP 请求后台去拿到域名对应的 IP 地址



为什么 HTTPS 还会存在 DNS 劫持问题呢？HTTPS 从身份认证、内容加密、防止篡改三个方面来保证网络安全，但是它的时机相对靠后，DNS 解析是网络请求的第一个步骤，完整的步骤是 DNS 解析 -> TCP 连接 -> TLS 握手 -> Request -> Response，所以 HTTPS 对 DNS 劫持也无能为力，但是可以通过客户端身份认证来避免被塞广告等状况的发生，被劫持后直接访问失败。


TCP 传输控制协议，是面向连接的，建立连接需要经历三次握手，是可靠的传输层协议。
UDP 用户数据协议，是面向无连接的，数据传输是不可靠的，它只管发，不管收不收得到。
简单的说，TCP注重数据安全，而UDP数据传输快点，但安全性一般。


# 讲一下 HTTP 与 HTTPS 的区
答：Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：

端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；

资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；

开销：Https通信需要证书，而证书一般需要向认证机构购买；

Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。






HTTP 和 HTTPS 的主要区别在于 HTTP 协议传递的是明文数据，而 HTTPS 传递的是加密过的数据，也就是说 HTTPS 更具有安全性。也正由 HTTPS 需要保证安全性，所以它的性能要比 HTTP 差一点。

单说安全性肯定是不够的，我打算扩展讲一下 HTTPS 是怎么解决安全性问题的，通过这些 HTTP 没有机制，反映出 HTTPS 与 HTTP 的区别。下面尝试把 HTTPS 加密的过程推导出来。推导过程不涉及复杂的实现细节：

如何安全地进行数据传输？
假设现在 A 和 B 要进行安全的通信，那么究竟怎样才算是安全的通信？很自然地会想到：A 和 B 之间传递数据，这些数据只有 A 和 B 才看得懂，中间人就算截取了信息但也看不懂，这才算得上安全。

安全通信的处理手段：
为了能让 A 和 B 才能看懂，就必须要对数据进行加密，而且首先想到的就是对称加密。对称加密的意思是 A 和 B 各持有一个相同的密钥，它们传递信息时会用密钥给信息加密，在消息到达端给消息解密，完成安全通信。

在对称加密中又会涉及到加密算法的选择问题。现实世界中，通常是多个客户端面向一个服务器的情况，不可能让每个客户端和服务器之间都采用相同的加密算法，如果是这样那和没加密差不多。所以注定每个客户端和服务器之间都会采用不同的加密方式。

如何让每个客户端与服务器之间都采用不同的加密方式？
要想对不同的机器使用不同的加密方式，最直接想到的就是使用随机数。也就说客户端和服务器之间每次都基于一个随机数产生加密算法。（具体实现时为了保证随机，用到还不止一个随机数）

这个产生加密算法的过程称之为协商，现在问题是协商的过程是透明的，也就是说中间人可以截获协商的过程，从而知道我们的加密方式。为了解决这个问题，我们需要对协商的过程进行加密。

如何对协商的过程进行加密？
之所以能来到这一步，是因为我们一开始就选择使用了对称加密，也就说一开始的对称加密导致了现在的问题，所以这时我们不能再使用对称加密了，否则会陷入死循环。

在密码学领域，还有一种加密过程叫非对称加密，它的逻辑是这样的：通信双方一方持有私钥，一方持有公钥，经过私钥加密的信息，都能通过公钥进行解密。但是经过公钥加密的数据，只有私钥可以解密。

按照非对称加密的规则，我们让服务器持有私钥，让客户端持有公钥。这样就能保证客户端给服务器发送消息的时候是安全的（相反，服务器给客户端发送消息就是不安全的），我们可以把协商时重要的逻辑安排在客户端给服务器发送信息的过程中，从而保证了协商过程的安全性。

客户端如何获得公钥？
现在用非对称加密算法解决了协商的安全问题，但是非对称加密的前提是客户端需要获得公钥，这又是一个问题了，客户端与服务器打交道之前是互不知道双方身份的，怎么才能让客户端获得公钥呢？

也就只有两种办法：

客户端向服务器要公钥
客户端向一个远程的公共服务器获取公钥
方法2显然是不行的，尚且不说多了一个访问节点，如何找到公共服务器的地址也是一个待解决的问题，所以还是使用方法 1。

但是方法 1 存在一个问题：如果中间人把服务器发送给客户端的公钥调包了怎么办？也就是说客户端无法知道发送公钥的是否是正真的服务器。

引入第三方机构解决问题
客户端无法辨识服务端和中间人的问题称为“身份验证”问题，也就是说我们需要为服务器向客户端发送公钥的过程进行加密。

这下完了，之前我们因遇到对称加密的瓶颈选择了非对称加密，现在使用非对称加密也遇到了瓶颈。显然这两种加密方式都是不可用的了，否则会再次陷入死循环。

接下来我们只好通过第三方机构的介入，解决这个问题。首先我们自己保存有第三方权威机构的公钥，然后第三方机构使用私钥对服务器将要发送给客户端的公钥进行加密，客户端接收到这个经加密的公钥后（数字证书），就能通过自己保存的第三方机构公钥进行解密。

“到这里为止，我们解释了 HTTPS 中使用到的对称加密，非对称加密，CA，数字证书的概念，但是还差一个叫数字签名的概念没有解释。
在现实生活中，CA 不单止会给我们正常公司发放证书，还会给中间人的坏公司发放证书，如果中间人把发放的证书调包了怎么办？这时我们仍能用 CA 的私钥进行解密，但是证书已经被调包了。

那么客户端怎样验证证书的真伪呢？答案是证书本身会告诉客户端如何辨认真伪。比方说证书上面有一个证书编号，还有一个如何计算证书编号的方法，客户端可以根据计算证书编号的方法计算出自己要获得的证书的编号，然后把这个编号和证书上的编号进行比对，如果一样证明没有被调包。

这里的证书编号指的就是数字签名，证书指的就是数字证书。

总结一下 HTTPS ：HTTPS 想要保证客户端与服务器之间的通信安全，就得使用对称加密算法进行加密。协商对称加密算法的过程通过非对称加密算法来保证。在非对称加密算法中，客户端获得公钥的过程需要第三方机构（CA）通过颁发数字证书保证安全性。

总得来说通过这一系列机制协商出了一个对称加密算法后，客户端与服务器之间就能通过该算法进行安全的通信了。

# 支付轮询例子

```swift
class PaymentViewController: UITableViewController {
    private var requestStatusCount: Int = 0
    private var requestStatusInterval: Int = 2
    private var requestStatusMaxCount: Int = 30

    private var payStatus: PayStatus = .none

    private func bindViewModel() {
        viewModel.payInfo.subscribe(onNext: { [weak self] payInfo in
            self?.orderId = payInfo["uuid"] as? String

            self?.payStatus = .none

            PayService.weixin(payInfo["pay_params"] as? [String: Any] ?? [:])
        }).disposed(by: rx.disposeBag)

        viewModel.payStatus.subscribe(onNext: { [weak self] status in
            guard let self = self, let orderId = self.orderId, self.payStatus == PayStatus.none else {
                ProgressHUD.dismiss()
                return
            }

            if status == PayStatus.fail {
                self.payStatus = PayStatus.fail
                ProgressHUD.dismiss()
                Toast.show("支付失败")
            } else if status == PayStatus.success {
                self.payStatus = PayStatus.success
                ProgressHUD.dismiss()
                Toast.show("支付成功")
                self.buyButtonView.removeFromSuperview()
                RouterService.switchTabBarSelectedIndex(index: .home)
            } else {
                if self.requestStatusCount < self.requestStatusMaxCount {
                    delay(TimeInterval(self.requestStatusInterval), task: {
                        self.viewModel.requestPayStatus(orderId)
                    })

                    self.requestStatusCount += 1
                } else {
                    self.payStatus = PayStatus.timeout
                    ProgressHUD.dismiss()
                    Toast.show("支付超时")
                }
            }
        }).disposed(by: rx.disposeBag)

        NotificationCenter.default.rx.notification(.UIApplicationWillEnterForeground).subscribe(onNext: { [weak self] notification in
            delay(0.5, task: {
                if let orderId = self?.orderId, self?.payStatus == PayStatus.none {
                    ProgressHUD.show()
                    self?.viewModel.requestPayStatus(orderId)
                }
            })
        }).disposed(by: rx.disposeBag)

        NotificationCenter.default.rx.notification(Notification.Name.Social.weixinPayCancel).subscribe(onNext: { [weak self] notification in
            self?.payStatus = PayStatus.cancel
        }).disposed(by: rx.disposeBag)

        NotificationCenter.default.rx.notification(Notification.Name.Social.weixinPayFail).subscribe(onNext: { [weak self] notification in
            self?.payStatus = PayStatus.fail
        }).disposed(by: rx.disposeBag)
    }
}
public class PayViewModel: BaseViewModel {
    var payInfo = BehaviorRelay(value: [String: Any]())
    var payStatus = BehaviorRelay(value: PayStatus(rawValue: 0))

    public func requestPayInfo(_ params: [String: Any]) {
        self.loading.onNext(true)
        NetworkService.post("/order/create", parameters: params) { [weak self] (result, error) in
            self?.loading.onNext(false)
            if let error = error {
                self?.toast.onNext(error.message)
            } else {
                if let datas = result as? [String: Any], !datas.isEmpty {
                    self?.payInfo.accept(datas)
                }
            }
        }
    }

    public func requestPayStatus(_ uuid: String) {
        NetworkService.get("/order/\(uuid)/check_status") { [weak self] (result, error) in
            if let datas = result as? [String: Any], !datas.isEmpty, let status = datas["status"] as? Int {
                if status == 1 {
                    self?.payStatus.accept(.success)
                } else {
                    self?.payStatus.accept(.paying)
                }
            } else {
                self?.payStatus.accept(.fail)
            }
        }
    }
}

```

