<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[风行的博客]]></title>
  <link href="http://lijingcheng.github.io/atom.xml" rel="self"/>
  <link href="http://lijingcheng.github.io/"/>
  <updated>2017-11-08T20:30:08+08:00</updated>
  <id>http://lijingcheng.github.io/</id>
  <author>
    <name><![CDATA[风行]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[给新司机的一点建议]]></title>
    <link href="http://lijingcheng.github.io/blog/2017/10/19/new-driver/"/>
    <updated>2017-10-19T20:04:50+08:00</updated>
    <id>http://lijingcheng.github.io/blog/2017/10/19/new-driver</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/get_in_the_car.jpeg" width="200" height="200"  >
<strong><em>来不及解释了，快上车！</em></strong></p>

<p><br><br><br></p>

<!-- more -->


<p>作为一个仅开了半年车的新司机，总结了一些开车时需要注意的事情，希望能和刚拿到驾照不久的新司机们一起分享，虽然很多老司机都说开车就像走路一样简单，但对于刚学会站立的孩子来说走路也并不简单&hellip;</p>

<h2>起步</h2>

<ul>
<li>不要酒后/疲劳/生气时开车</li>
<li>确认车周围有没有障碍物或人（曾顶着停车桩开了十多米）</li>
<li>车上所有人都要系安全带</li>
<li>打左转向灯提醒后方来车，并通过后视镜确认安全后再起步

<h2>行车</h2></li>
<li>要频繁看后视镜，就象打王者荣耀时看小地图一样</li>
<li>让速不让路，除非前后都是能夹死你的大车</li>
<li>养成变道打转向灯的习惯，无论后面有没有车，变道的时候对准车道后再踩油门，并且小心两边车道的人都往中间车道并</li>
<li>不要跟其他车并排行驶</li>
<li>走车道中间，否则会被挤，也不安全</li>
<li>路口减速，避免电动车、自行车和人窜出</li>
<li>转弯让直行</li>
<li>小心公交车，很多公交司机都太霸道</li>
<li>前车突然变道，最好踩下刹车并同时考虑变道，有可能前方有事故</li>
<li>遇到紧急情况先踩刹车，在看后视镜</li>
<li>在不确定要踩油门加速的情况下，把脚悬在刹车上，刹车后轻抬刹车可以不点头，油门要慢踩慢抬</li>
<li>不要开太快，十次出事九次快</li>
<li>离路边停的车远点，他们随时可能打开车门</li>
<li>经过路口有意识地放开油门或者轻踩刹车，以防有路人或车冲出来</li>
<li>视线被挡时必须慢，例如右面有公交车时，要小心有人从车前跑出来

<h2>跟车</h2></li>
<li>保持车距眼光要放远</li>
<li>不跟大车，大车档视线、货车掉东西</li>
<li>不跟出租车，因为他随时会踩刹车和变道</li>
<li>前车刹车你最好也刹</li>
<li>雨雪天气以及车上满员时要提前踩刹车</li>
<li>超车前先给信号，闪两下大灯，并且要避免前车忽然变道（遇到过两次大车故意在我变道时別我）

<h2>倒车</h2></li>
<li>方向盘调整要快，车速要慢</li>
<li>如果不是在坡路上不要踩油门，特别是方向盘不正的情况下会很危险

<h2>高速</h2></li>
<li>远离大车</li>
<li>不出高速尽量不走外侧车道，出高速下匝道时也要小心旁边车道强行并线下匝道</li>
<li>因为速度很快，不要急打方向</li>
<li>急刹车的时候看下后视镜，高速上被追尾的死亡率远远大于追尾的</li>
<li>快出高速时最后一公里左右就提前进入最外侧车道，如果路口开过了就下一个口出去再掉头，千万不要强行并线</li>
<li>冲出动物时，宁可直接撞，也别躲！</li>
<li>在高速上发生爆胎，首先稳住方向盘，千万不要猛打方向或踩死刹车</li>
<li>最内侧车道是给快车的，最外侧是给大车的

<h2>停车</h2></li>
<li>打右转向灯提示后方</li>
<li>如果路面有坡，先挂 N 档，再拉手刹，再挂 P 档。</li>
<li>路边停车时前面最好留出距离能让自己出来</li>
<li>车上所有人下车都要注意后面是否来车</li>
<li>车不要停在楼下，停在明处，不要停在角落里

<h2>其他</h2></li>
<li>少开夜车，不仅不安全，而且晚上省出的时间白天还的更多</li>
<li>别人按喇叭催你时千万别着急，否则出了事担责任的是你自己</li>
<li>永远要假设别的车或人都是不规矩的</li>
<li>跟车不要开远光，会车更不要开远光</li>
<li>紧急情况下要踩死刹车才能启动 ABS，并且不要在速度没降下来的时候急打方向</li>
<li>车里面不要摆挂一些东西，防止急刹车砸到人身上</li>
<li>遇到有陌生人询问，车窗开条缝就好</li>
<li>行至偏僻、陌生路段遇拦车的不要停车，下车</li>
<li>车内财物不要直接放在座位上，防止别人砸窗

<h2>事故处理</h2>

<p>出了事故再来补。。。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从 Objective-C 过渡到 Swift]]></title>
    <link href="http://lijingcheng.github.io/blog/2017/03/17/swift-base/"/>
    <updated>2017-03-17T19:10:37+08:00</updated>
    <id>http://lijingcheng.github.io/blog/2017/03/17/swift-base</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/swift.jpg" width="250" height="250"  >
<strong>Swift - <em>不仅支持面向对象和面向协议开发，同时还支持函数式开发，在使用封装继承多态的同时，也可以用协议去组合代码，还可以利用高阶函数去简化代码、组织程序。</em></strong></p>

<p><br><br></p>

<!-- more -->


<p>Swift 还是一个强类型语言，类型在运行时和编译期间是一致的，这样编译器可以得到足够的信息在生成中间码和机器码时进行优化，并在编译期间完成方法的绑定，可以直接获取方法地址并进行调用。</p>

<p>下面所写的所有内容都只是 Swift 的一些基础知识，仅适用于初学者或培训使用。本文初写目的就是为了培训，曾在三个小时内催眠了所有听众。</p>

<h2>Hello World</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello world!&quot;</span><span class="p">)</span> <span class="c1">// 打印并换行</span>
</span></code></pre></td></tr></table></div></figure>


<h2>数据类型</h2>

<h3>整数</h3>

<p>通常使用 Int 来声明整数就可以了，当为了优化内存占用或要处理接口返回的长度明确的数据等情况时可使用显式指定长度的类型，这样可以及时发现值溢出并增强代码可读性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="nl">age</span><span class="p">:</span> <span class="n">Int</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1">// 常量 age 在 32-bit 平台下为 Int32,在 64-bit 下为 Int64</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">twoThousand</span> <span class="o">=</span> <span class="mi">2</span><span class="n">_000</span> <span class="c1">// 变量 twoThousand 会被编译器自动推断为 Int 类型，并且用 _ 增强可读性</span>
</span></code></pre></td></tr></table></div></figure>


<h3>浮点数</h3>

<p>32/64 位浮点数分别用 Float 和 Double 表示，精度分别为 6/15+ 位数字。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.14159</span> <span class="c1">// 浮点数值总是会被推断为 Double</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="c1">// 自动截断，值为 3</span>
</span><span class='line'><span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="nl">exactly</span><span class="p">:</span> <span class="n">pi</span><span class="p">)</span> <span class="c1">// 要求更为精确的转换，当精度有损失，认为转换失败，值为 nil</span>
</span></code></pre></td></tr></table></div></figure>


<h3>布尔值</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="nl">isChild</span><span class="p">:</span> <span class="n">Bool</span> <span class="o">=</span> <span class="nb">true</span> <span class="c1">// or false</span>
</span></code></pre></td></tr></table></div></figure>


<h3>字符</h3>

<p>Character 类型通常由编码无关的 Unicode 字符组成</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="nl">c</span><span class="p">:</span> <span class="n">Character</span> <span class="o">=</span> <span class="s">&quot;e&quot;</span> <span class="c1">// 如果不指定类型，双引号会被推断为字符串类型</span>
</span></code></pre></td></tr></table></div></figure>


<p>Character 可以由一个或多个 Unicode 标量（Scalar）组成</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="nl">c1</span><span class="p">:</span> <span class="n">Character</span> <span class="o">=</span> <span class="s">&quot;\u{00E9}&quot;</span> <span class="c1">// é</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="nl">c2</span><span class="p">:</span> <span class="n">Character</span> <span class="o">=</span> <span class="s">&quot;\u{0065}\u{0301}&quot;</span> <span class="c1">// e +  ́ = é</span>
</span></code></pre></td></tr></table></div></figure>


<h3>字符串</h3>

<p>Swift 中的 String 是值类型，所以在进行传递时都会进行值拷贝，不用担心会被意外修改。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="nl">str</span><span class="p">:</span> <span class="n">String</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;str: \(str)&quot;</span><span class="p">)</span> <span class="c1">// Swift 会用 str 的值替换占位符 \(str)</span>
</span></code></pre></td></tr></table></div></figure>


<p>给字符串追加字符不一定会更改字符串的字符数量</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="n">word</span> <span class="o">=</span> <span class="s">&quot;cafe&quot;</span> <span class="o">+</span> <span class="s">&quot;\u{301}&quot;</span> <span class="c1">// café</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">characters</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="c1">// 有 4 个 char</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">unicodeScalars</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="c1">// 有 5 个 Unicode Scalar</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 Swift 中不同的字符以及相同字符的不同表示方式可能需要不同数量的内存空间来存储，所以要知道字符的确定位置就必须从 String 开头遍历每一个 Unicode 标量直到结尾。因此 Swift 的字符串不能用整数做索引，而是使用一个关联的索引类型 String.Index，它对应着字符串中每一个字符的位置。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;Guten Tag!&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">[</span><span class="n">greeting</span><span class="p">.</span><span class="n">startIndex</span><span class="p">])</span><span class="c1">// 值为 G，如果用 greeting[0] 会报错</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">[</span><span class="n">greeting</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">greeting</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="nl">offsetBy</span><span class="p">:</span> <span class="mi">7</span><span class="p">)])</span> <span class="c1">// a</span>
</span></code></pre></td></tr></table></div></figure>


<h3>数组</h3>

<p>Array 使用有序列表存储同一类型的多个值，可以存储重复值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="n">array1</span> <span class="o">=</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">()</span> <span class="c1">// 字符串数组</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">array2</span> <span class="o">=</span> <span class="p">[</span><span class="n">String</span><span class="p">]()</span> <span class="c1">// 字符串数组（推荐写法）</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">array3</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="nl">repeating</span><span class="p">:</span> <span class="s">&quot;_&quot;</span><span class="p">,</span> <span class="nl">count</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// 字符串数组，包含3个元素，默认值为 _</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">array4</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;apple&quot;</span><span class="p">,</span> <span class="s">&quot;pen&quot;</span><span class="p">,</span> <span class="s">&quot;apple-pen&quot;</span><span class="p">]</span> <span class="c1">// 自动推断出数组类型为 String</span>
</span><span class='line'><span class="n">array4</span> <span class="o">+=</span> <span class="p">[</span><span class="s">&quot;Pineapple&quot;</span><span class="p">]</span> <span class="c1">// 相同类型数组可以用 + 进行组合</span>
</span><span class='line'><span class="n">array4</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Pen&quot;</span><span class="p">)</span> <span class="c1">// 添加元素</span>
</span><span class='line'><span class="n">array4</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Apple&quot;</span> <span class="c1">// 可以用下标访问和修改数组元素</span>
</span><span class='line'><span class="n">array4</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="mf">.2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Pen&quot;</span><span class="p">,</span> <span class="s">&quot;Apple-Pen&quot;</span><span class="p">]</span> <span class="c1">// 还可以利用下标来一次改变一系列数据值，尽量保证下标区间与值的个数相匹配</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用 for-in 循环来遍历数组中的数据项</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">array4</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果我们同时需要每个数据项的值和索引值，可以使用 enumerated() 来进行数组遍历。enumerated() 返回一个由每一个数据项索引值和数据值组成的元组。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="n">array4</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以嵌套多对方括号来创建多维数组</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="nl">array3D</span><span class="p">:</span> <span class="p">[[[</span><span class="n">Int</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]]</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">array3D</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">array3D</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">array3D</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<h3>集合</h3>

<p>Set 用来存储相同类型并且没有确定顺序的值，不可以存储重复值。一个类型为了存储在集合中必须是可哈希化的，需要确认 Hashable 协议并提供方法来计算它的哈希值，因为 Hashable 符合 Equatable 协议，所以还需要提供 <code>==</code> 的实现。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="n">set1</span> <span class="o">=</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">()</span> <span class="c1">// 与数组不同的是集合的声明没有简化形式</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="nl">set2</span><span class="p">:</span> <span class="n">Set</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;apple&quot;</span><span class="p">,</span> <span class="s">&quot;pen&quot;</span><span class="p">,</span> <span class="s">&quot;apple-pen&quot;</span><span class="p">]</span> <span class="c1">// 如果不指定类型就会被认为是数组</span>
</span><span class='line'><span class="n">set2</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&quot;pineapple&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>按照特定顺序来遍历一个 Set 中的值可以使用 sorted() 方法，它将返回一个有序数组。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">set2</span><span class="p">.</span><span class="n">sorted</span><span class="p">()</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>字典</h3>

<p>Dictionary 用来存储多个相同类型的值，每个值都关联唯一的 key，key 的类型必须遵循 Hashable 协议，字典中的数据项没有具体顺序。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="n">dict1</span> <span class="o">=</span> <span class="n">Dictionary</span><span class="o">&lt;</span><span class="n">Int</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;</span><span class="p">()</span> <span class="c1">// 键是Int型，值是String型</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">dict2</span> <span class="o">=</span> <span class="p">[</span><span class="nl">Int</span><span class="p">:</span> <span class="n">String</span><span class="p">]()</span> <span class="c1">//推荐写法</span>
</span><span class='line'><span class="n">dict2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;lijingcheng&quot;</span> <span class="c1">// key: 3, value: lijingcheng 字典包含 key 时此操作为修改，否则为添加</span>
</span><span class='line'><span class="n">dict2</span> <span class="o">=</span> <span class="p">[</span><span class="o">:</span><span class="p">]</span> <span class="c1">// 赋值为空字典</span>
</span></code></pre></td></tr></table></div></figure>


<p>遍历字典时每一个数据项都以 (key, value) 元组形式返回</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="n">dict2</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>元组</h3>

<p>tuples 可以把多个不同类型的值组合成一个复合值，并且值是有序的，元组不支持 add 和 remove 操作，但是支持修改。元组并不适合创建复杂的数据结构，更适合用于组合少量的多元数据，例如可以在函数中一次返回多个值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">http404Error</span> <span class="o">=</span> <span class="p">(</span><span class="mi">404</span><span class="p">,</span> <span class="s">&quot;Not Found&quot;</span><span class="p">)</span> <span class="c1">// http404Error 的类型是 (Int, String)</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;\(http404Error.0), \(http404Error.1).&quot;</span><span class="p">)</span> <span class="c1">// 用下标访问元组</span>
</span></code></pre></td></tr></table></div></figure>


<p>定义元组时给单个元素命名，然后通过名字来获取元素的值</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">http200Status</span> <span class="o">=</span> <span class="p">(</span><span class="nl">statusCode</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span> <span class="nl">description</span><span class="p">:</span> <span class="s">&quot;OK&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;\(http200Status.statusCode), \(http200Status.description).&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>将元组的内容分解为常量</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="p">(</span><span class="n">statusCode</span><span class="p">,</span> <span class="n">statusMessage</span><span class="p">)</span> <span class="o">=</span> <span class="n">http404Error</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;\(statusCode), \(statusMessage).&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>元组支持嵌套</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">userInfo</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;lijingcheng&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;male&quot;</span><span class="p">,</span> <span class="s">&quot;Mtime&quot;</span><span class="p">),</span> <span class="p">[</span><span class="s">&quot;obj1&quot;</span><span class="p">,</span> <span class="s">&quot;obj2&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s">&quot;key&quot;</span><span class="o">:</span> <span class="s">&quot;value&quot;</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Optional</h3>

<p>在声明变量时可以用可选类型来处理值可能为 nil 的情况，可选类型也可用于函数参数和函数返回值。（Swift 中 nil 不是指针，它是一个确定的值，可用来表示任何类型变量的值缺失）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="nl">possibleNumber</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span> <span class="o">=</span> <span class="s">&quot;123&quot;</span> <span class="c1">// String? 也可以写成 Optional&lt;String&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 使用可选绑定来判断可选类型是否为空</span>
</span><span class='line'><span class="k">if</span> <span class="k">let</span> <span class="n">num</span> <span class="o">=</span> <span class="n">possibleNumber</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="n">possibleNumber</span><span class="o">!</span><span class="p">)</span> <span class="c1">// 强制解析可选类型 possibleNumber，如果值为 nil 则会报错</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>当确定可选类型变量有值的情况下，可以用隐式解析可选类型来定义这个变量来避免每次使用前的 if 判断，以提高效率。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="nl">assumedString</span><span class="p">:</span> <span class="n">String</span><span class="o">!</span> <span class="o">=</span> <span class="s">&quot;An implicitly unwrapped optional string.&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">assumedString</span><span class="p">)</span> <span class="c1">// 不需要强制解析</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Any</h3>

<p>Any 相当于 Objective-C 中的 id，它可以表示任何类型，包括函数类型，AnyObject 可以表示任何类类型的实例。可以用类型检查操作符 is 来检查一个实例是否属于特定类型，就像 Objective-C 中的 isKindOf 方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="nl">things</span><span class="p">:</span> <span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">42</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="k">in</span> <span class="s">&quot;Hello, \(name)&quot;</span> <span class="p">}]</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">things</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 用 as? 进行类型转换，如果用 as! 来强制转换，当转换失败时会在运行时报错</span>
</span><span class='line'>    <span class="k">if</span> <span class="k">let</span> <span class="n">intValue</span> <span class="o">=</span> <span class="n">item</span> <span class="kt">as</span><span class="o">?</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;intValue: \(intValue)&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 因为可选值有可能为 nil，所在再往数组里放时会有警告，避免出现警告可用下面两种方式</span>
</span><span class='line'><span class="k">let</span> <span class="nl">optionalNumber</span><span class="p">:</span> <span class="n">Int</span><span class="o">?</span> <span class="o">=</span> <span class="mi">3</span>
</span><span class='line'><span class="n">things</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">optionalNumber</span> <span class="o">??</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'><span class="n">things</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">optionalNumber</span> <span class="kt">as</span> <span class="n">Any</span><span class="p">)</span> <span class="c1">// Int to Any</span>
</span></code></pre></td></tr></table></div></figure>


<h2>运算符</h2>

<p>Swift 支持大部分标准 C 语言的运算符，并改进许多特性来减少常规编码错误。</p>

<h3>赋值运算符</h3>

<p>Swift 的赋值操作不返回任何值，所以无法把 == 错写成 =，下面代码会在编译时报错</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>算术运算符</h3>

<p>没有自增和自减运算符，加法运算符可用于字符串拼接</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&quot;hello, &quot;</span> <span class="o">+</span> <span class="s">&quot;world&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>比较运算符</h3>

<p>字符、字符串、元组等值类型值可以用 <code>&lt;</code> <code>&gt;</code> <code>==</code> 和 <code>!=</code> 来进行比较</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">if</span> <span class="s">&quot;apple&quot;</span> <span class="o">==</span> <span class="s">&quot;pen&quot;</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>三目运算符</h3>

<p>不支持下面这种写法</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="n">i</span> <span class="o">=</span> <span class="n">num</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="o">?</span> <span class="o">:</span> <span class="mi">3</span>
</span></code></pre></td></tr></table></div></figure>


<h3>空合运算符</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="nl">colorName</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">colorName</span> <span class="o">??</span> <span class="s">&quot;red&quot;</span><span class="p">)</span> <span class="c1">// red</span>
</span></code></pre></td></tr></table></div></figure>


<h3>区间运算符</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">.</span><span class="mf">.5</span> <span class="p">{}</span> <span class="c1">// 闭区间运算符</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Anna&quot;</span><span class="p">,</span> <span class="s">&quot;Alex&quot;</span><span class="p">,</span> <span class="s">&quot;Brian&quot;</span><span class="p">,</span> <span class="s">&quot;Jack&quot;</span><span class="p">]</span>
</span><span class='line'><span class="k">let</span> <span class="n">count</span> <span class="o">=</span> <span class="n">names</span><span class="p">.</span><span class="n">count</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.</span><span class="o">&lt;</span><span class="n">count</span> <span class="p">{}</span> <span class="c1">// 半开区间运算符</span>
</span></code></pre></td></tr></table></div></figure>


<h3>恒等运算符</h3>

<p>Swift 提供了恒等 <code>===</code> 和不恒等 <code>!==</code> 两个比较符来判断类的两个对象是否引用同一个实例，而 <code>==</code> 则是用来比较两个实例的值是否相同。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">if</span> <span class="n">tenEighty</span> <span class="o">===</span> <span class="n">alsoTenEighty</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>溢出运算符</h3>

<p>Swift 会在数值溢出时报错，也可以通过溢出运算符在数值溢出的时候采取截断处理。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="n">upOverflow</span> <span class="o">=</span> <span class="kt">UInt8</span><span class="p">.</span><span class="n">max</span> <span class="o">&amp;+</span> <span class="mi">1</span> <span class="c1">// 上溢运算 0</span>
</span><span class='line'><span class="k">var</span> <span class="n">downOverflow</span> <span class="o">=</span> <span class="kt">UInt8</span><span class="p">.</span><span class="n">min</span> <span class="o">&amp;-</span> <span class="mi">1</span> <span class="c1">// 下溢运算 255</span>
</span></code></pre></td></tr></table></div></figure>


<h2>控制流</h2>

<h3>if-else</h3>

<p>条件语句中的小括号可以省略，并加强了类型安全检查，不能够再用整型参与 Bool 判断</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">if</span> <span class="mi">1</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>guard</h3>

<p>当 guard 语句为真时执行 guard 语句下面的代码，使用 guard 做基本的安全检查能有效减少函数中的嵌套数量，并提高代码可读性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">hello</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">guard</span> <span class="n">name</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello \(name!)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>switch</h3>

<p>Swift 中的 switch 语句在进行数值匹配时除了支持整型和字符，还支持浮点数、字符串、元组、枚举等类型，并且 case 语句不能有遗漏，如果不愿写太多 case 可用 default 分支满足需求。当匹配的 case 分支中的代码执行完毕后，程序会终止 switch 语句，避免了因忘记写 break 而产生的错误，break 语句可以用于逻辑性的跳出 switch。如果希望能够在执行完 case 中的代码后向下掉落则需要使用 fallthrough。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&quot;e&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">switch</span> <span class="n">str</span> <span class="p">{</span>
</span><span class='line'><span class="k">case</span> <span class="s">&quot;a&quot;</span><span class="o">:</span>
</span><span class='line'>    <span class="k">break</span>
</span><span class='line'><span class="k">case</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;B&quot;</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;b or B&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">case</span> <span class="s">&quot;c&quot;</span><span class="p">...</span><span class="s">&quot;e&quot;</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;c - e&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">fallthrough</span>
</span><span class='line'><span class="k">default</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;default...&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>用 switch 语句匹配元组的值</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">somePoint</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">switch</span> <span class="n">somePoint</span> <span class="p">{</span>
</span><span class='line'><span class="k">case</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;(0, 0)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">case</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="c1">// 只匹配 y，x 可以是任何值</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;(\(somePoint.0), 0)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">case</span> <span class="p">(</span><span class="o">-</span><span class="mf">2.</span><span class="p">.</span><span class="mf">.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">.</span><span class="mf">.2</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;(\(somePoint.0), \(somePoint.1))&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">case</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">let</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span> <span class="c1">// 只匹配 x，并且将 y 的值赋给常量 y</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;0, \(y)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">case</span> <span class="k">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">where</span> <span class="n">x</span> <span class="o">==</span> <span class="nl">y</span><span class="p">:</span> <span class="c1">// 通过 where 来进行匹配</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;\(x) == \(y)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">case</span> <span class="k">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;(\(x), \(y))&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>for-in</h3>

<p>如果不需要区间序列内每一项的值，可以使用下划线 _ 替代变量名来忽略这个值</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;apple&quot;</span><span class="p">,</span> <span class="s">&quot;pen&quot;</span><span class="p">,</span> <span class="s">&quot;apple-pen&quot;</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="n">array</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>while</h3>

<p>while 条件语句中的小括号可以省略，do-while 变成 repeat-while</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">repeat</span> <span class="p">{}</span> <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure>


<h2>函数与闭包</h2>

<h3>函数</h3>

<p>Swift 是类型安全的，所以支持参数个数相同但类型不同的函数重载</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="n">hello</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s">&quot;Hello, &quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">func</span> <span class="n">hello</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s">&quot;Hello, &quot;</span> <span class="o">+</span> <span class="n">String</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">hello</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Lee&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">hello</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>没有返回值的函数其实是返回了一个特殊的 Void 值，它是一个空的元组，可用()表示</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">greet</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="k">func</span> <span class="nf">greet</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="k">func</span> <span class="n">greet</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Void</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p>参数名称默认作为参数标签来使用，我们可以自定义参数标签，也可以用 _ 来忽略参数标签，Swift 支持为参数指定默认值，为了代码可读性考虑，一般将带默认值的参数放在参数列表的最后面</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="n">say</span><span class="p">(</span><span class="n">_</span> <span class="nl">prefixStr</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">parameterLabel</span> <span class="nl">parameterName</span><span class="p">:</span> <span class="n">String</span> <span class="o">=</span> <span class="s">&quot;lijingcheng&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">prefixStr</span> <span class="o">+</span> <span class="n">parameterName</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">say</span><span class="p">(</span><span class="s">&quot;hello, &quot;</span><span class="p">,</span> <span class="nl">parameterLabel</span><span class="p">:</span> <span class="s">&quot;lijingcheng&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">say</span><span class="p">(</span><span class="s">&quot;hello, &quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>一个函数最多只能拥有一个可变参数，可变参数可以接受零个或多个值</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="n">total</span><span class="p">(</span><span class="n">_</span> <span class="nl">numbers</span><span class="p">:</span> <span class="n">Double</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Double</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">total</span><span class="p">:</span> <span class="n">Double</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">numbers</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">total</span> <span class="o">+=</span> <span class="n">number</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">total</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">total</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>函数参数默认是常量，如果要修改参数的值，可以将参数定义为输入输出参数。输入输出参数不能有默认值，而且可变参数不能用 inout 标记。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">swapTwoInts</span><span class="p">(</span><span class="n">_</span> <span class="nl">a</span><span class="p">:</span> <span class="k">inout</span> <span class="n">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nl">b</span><span class="p">:</span> <span class="k">inout</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">temporaryA</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">temporaryA</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">someInt</span> <span class="o">=</span> <span class="mi">3</span>
</span><span class='line'><span class="k">var</span> <span class="n">anotherInt</span> <span class="o">=</span> <span class="mi">107</span>
</span><span class='line'><span class="n">swapTwoInts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">someInt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anotherInt</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;someInt is now \(someInt), and anotherInt is now \(anotherInt)&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>Swift 支持我们用函数式思维来写代码，函数也作为语言的一等公民，函数其实也是一种值，Swift 支持函数类型的变量或常量，可以将函数以参数的形式传给其它函数，并且可以将一个函数作为返回值使用，还支持嵌套函数，通常称这种函数为高阶函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">addTwoInts</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="nl">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">addMathFunction</span> <span class="o">=</span> <span class="n">addTwoInts</span> <span class="c1">// 类型为：(Int, Int) -&gt; Int</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">addMathFunction</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">// print: 5</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">func</span> <span class="n">printMathResult</span><span class="p">(</span><span class="n">_</span> <span class="nl">mathFunction</span><span class="p">:</span> <span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nl">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nl">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="n">mathFunction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">printMathResult</span><span class="p">(</span><span class="n">addMathFunction</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// print: 8</span>
</span></code></pre></td></tr></table></div></figure>


<p>把函数定义在别的函数体中称作嵌套函数，下面例子中 incrementBySeven 和 incrementByTen 都是常量，但是他们指向的函数仍然可以增加其捕获的变量的值。这是因为函数和闭包都是引用类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="n">makeIncrementer</span><span class="p">(</span><span class="n">forIncrement</span> <span class="nl">amount</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">runningTotal</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="k">func</span> <span class="n">incrementer</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">runningTotal</span> <span class="o">+=</span> <span class="n">amount</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">runningTotal</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">incrementer</span> <span class="c1">// 返回内部函数</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">incrementByTen</span> <span class="o">=</span> <span class="n">makeIncrementer</span><span class="p">(</span><span class="nl">forIncrement</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">// incrementByTen 为函数类型变量，并且无参，返回 Int</span>
</span><span class='line'><span class="n">incrementByTen</span><span class="p">()</span> <span class="c1">// return 10</span>
</span><span class='line'><span class="n">incrementByTen</span><span class="p">()</span> <span class="c1">// return 20</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//如果你创建了另一个 incrementer，它会有属于自己的引用，指向一个全新、独立的 runningTotal 变量：incrementBySeven 和 incrementByTen 没有任何联系</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">incrementBySeven</span> <span class="o">=</span> <span class="n">makeIncrementer</span><span class="p">(</span><span class="nl">forIncrement</span><span class="p">:</span> <span class="mi">7</span><span class="p">)</span>
</span><span class='line'><span class="n">incrementBySeven</span><span class="p">()</span> <span class="c1">// return 7</span>
</span><span class='line'><span class="n">incrementBySeven</span><span class="p">()</span> <span class="c1">// return 14</span>
</span><span class='line'>
</span><span class='line'><span class="n">incrementByTen</span><span class="p">()</span> <span class="c1">// return 30</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>闭包</h3>

<p>闭包是自包含的函数代码块，可以在代码中被传递和使用，闭包可以捕获和存储其所在上下文中任意常量和变量的引用，即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p>

<p>全局函数和嵌套函数实际上也是特殊的闭包，全局函数是一个有名字但不会捕获任何值的闭包，嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包。闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Chris&quot;</span><span class="p">,</span> <span class="s">&quot;Alex&quot;</span><span class="p">,</span> <span class="s">&quot;Ewa&quot;</span><span class="p">,</span> <span class="s">&quot;Barry&quot;</span><span class="p">,</span> <span class="s">&quot;Daniella&quot;</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">names</span><span class="p">.</span><span class="n">sorted</span><span class="p">(</span><span class="nl">by</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="nl">s1</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">s2</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="k">in</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">s1</span> <span class="o">&lt;</span> <span class="n">s2</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift 可以根据闭包接收的参数和返回值推断出参数和返回值的类型，所以可以简写为下面形式，很短的函数体可以写成一行，单行表达式闭包可以省略 return，不过完整形式的闭包具有更好的代码可读性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">names</span><span class="p">.</span><span class="n">sorted</span><span class="p">(</span><span class="nl">by</span><span class="p">:</span> <span class="p">{</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="k">in</span> <span class="n">s1</span> <span class="o">&lt;</span> <span class="n">s2</span> <span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>闭包的参数列表也可以省略，可以用 $0，$1，$2 来顺序调用闭包的参数</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">names</span><span class="p">.</span><span class="n">sorted</span><span class="p">(</span><span class="nl">by</span><span class="p">:</span> <span class="p">{</span><span class="err">$</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="err">$</span><span class="mi">1</span><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>Swift 的 String 重载了 > 用于比较两个字符串并返回大小，所以 sorted 函数还可以直接将 &lt; 当作闭包处理</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">names</span><span class="p">.</span><span class="n">sorted</span><span class="p">(</span><span class="nl">by</span><span class="p">:</span> <span class="o">&lt;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果闭包表达式是函数的唯一参数，则可以作为尾随闭包来使用，以增强函数的可读性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">names</span><span class="p">.</span><span class="n">sorted</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="k">in</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">s1</span> <span class="o">&lt;</span> <span class="n">s2</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>当定义接受闭包作为参数的函数时，可以用 @escaping 来标注参数名称，用来指明这个闭包是允许“逃逸”出这个函数的，这样我们就可以用一个变量或常量来接收闭包，并在适当的时候调用它，如果将一个闭包标记为 @escaping 意味着你必须在闭包中显式地引用 self。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="n">closures</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="k">func</span> <span class="n">someFunctionWithEscapingClosure</span><span class="p">(</span><span class="nl">completionHandler</span><span class="p">:</span> <span class="p">@</span><span class="n">escaping</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">closures</span> <span class="o">=</span> <span class="n">completionHandler</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">customersInLine</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Chris&quot;</span><span class="p">,</span> <span class="s">&quot;Alex&quot;</span><span class="p">,</span> <span class="s">&quot;Ewa&quot;</span><span class="p">,</span> <span class="s">&quot;Barry&quot;</span><span class="p">,</span> <span class="s">&quot;Daniella&quot;</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">someFunctionWithEscapingClosure</span> <span class="p">{</span> <span class="n">customersInLine</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="nl">at</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">customersInLine</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="c1">// print: 5</span>
</span><span class='line'><span class="n">closures</span><span class="p">()</span> <span class="c1">// 执行闭包</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">customersInLine</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="c1">// print: 4</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>枚举</h2>

<p>Swift 的枚举成员在被创建时不会被赋予一个默认的整型值，枚举成员本身就是完备的值，多个成员值可以用逗号分隔并定义在一行上</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">enum</span> <span class="n">CompassPoint</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">north</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">west</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">directionToHead</span> <span class="o">=</span> <span class="n">CompassPoint</span><span class="p">.</span><span class="n">west</span>
</span><span class='line'><span class="n">directionToHead</span> <span class="o">=</span> <span class="p">.</span><span class="n">east</span> <span class="c1">// 当 directionToHead 的类型已知时，再次为其赋值可以省略枚举类型名</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>枚举成员虽然没有默认值，但是可以给它指定原始值，类型可以是字符串、字符、整型、浮点数，这些原始值一旦设置了就不能再改变，并且值在枚举声明中必须是唯一的而且类型必须相同，使用枚举成员的 rawValue 属性可以访问该成员的原始值。在使用原始值为整数或者字符串类型的枚举时，通常不需要显式地为每一个枚举成员设置原始值，Swift 会自动赋值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">enum</span> <span class="nl">CompassPoint2</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">north</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">west</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">sunsetDirection2</span> <span class="o">=</span> <span class="n">CompassPoint2</span><span class="p">.</span><span class="n">west</span><span class="p">.</span><span class="n">rawValue</span> <span class="c1">// “west”</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>当使用整数作为原始值时，隐式赋值的值依次递增1。如果第一个枚举成员没有设置原始值，其原始值将为0。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">enum</span> <span class="nl">CompassPoint3</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">north</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">west</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">earthsOrder</span> <span class="o">=</span> <span class="n">CompassPoint3</span><span class="p">.</span><span class="n">east</span><span class="p">.</span><span class="n">rawValue</span> <span class="c1">// 3</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个叫做 rawValue 的参数，参数类型即为原始值类型，返回值则是枚举成员或 nil。</span>
</span><span class='line'><span class="k">let</span> <span class="n">possiblePlanet</span> <span class="o">=</span> <span class="n">CompassPoint3</span><span class="p">(</span><span class="nl">rawValue</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// south</span>
</span><span class='line'><span class="k">let</span> <span class="n">possiblePlanet2</span> <span class="o">=</span> <span class="n">CompassPoint3</span><span class="p">(</span><span class="nl">rawValue</span><span class="p">:</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">// nil</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>如果不为枚举成员指定原始值，那么就可以指定任意类型的关联值存储到枚举成员中，每个枚举成员都可以有不同类型的关联值，并且关联值可以修改。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">enum</span> <span class="n">Barcode</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">upc</span><span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="n">Int</span><span class="p">,</span> <span class="n">Int</span><span class="p">,</span> <span class="n">Int</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">qrCode</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">productBarcode</span> <span class="o">=</span> <span class="n">Barcode</span><span class="p">.</span><span class="n">upc</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">85909</span><span class="p">,</span> <span class="mi">51226</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// .upc关联的元组值为(8, 85909, 51226, 3)。</span>
</span><span class='line'><span class="n">productBarcode</span> <span class="o">=</span> <span class="p">.</span><span class="n">qrCode</span><span class="p">(</span><span class="s">&quot;ABCDEFGHIJKLMNOP&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//关联值可以被提取出来作为 switch 语句的一部分。你可以在switch的 case 分支代码中提取每个关联值作为一个常量（用let前缀）或者作为一个变量（用var前缀）来使用：</span>
</span><span class='line'><span class="k">switch</span> <span class="n">productBarcode</span> <span class="p">{</span>
</span><span class='line'><span class="k">case</span> <span class="p">.</span><span class="n">upc</span><span class="p">(</span><span class="k">let</span> <span class="n">numberSystem</span><span class="p">,</span> <span class="k">let</span> <span class="n">manufacturer</span><span class="p">,</span> <span class="k">let</span> <span class="n">product</span><span class="p">,</span> <span class="k">let</span> <span class="n">check</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;UPC: \(numberSystem), \(manufacturer), \(product), \(check).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">case</span> <span class="p">.</span><span class="n">qrCode</span><span class="p">(</span><span class="k">let</span> <span class="n">productCode</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;QR code: \(productCode).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，你可以只在成员名称前标注一个let或者var：</span>
</span><span class='line'><span class="k">switch</span> <span class="n">productBarcode</span> <span class="p">{</span>
</span><span class='line'><span class="k">case</span> <span class="k">let</span> <span class="p">.</span><span class="n">upc</span><span class="p">(</span><span class="n">numberSystem</span><span class="p">,</span> <span class="n">manufacturer</span><span class="p">,</span> <span class="n">product</span><span class="p">,</span> <span class="n">check</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;UPC: \(numberSystem), \(manufacturer), \(product), \(check).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">case</span> <span class="k">let</span> <span class="p">.</span><span class="n">qrCode</span><span class="p">(</span><span class="n">productCode</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;QR code: \(productCode).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>类和结构体</h2>

<p>Swift 中的所有的基本类型和枚举都是值类型，它们在底层都是以结构体的形式所实现，所以结构体也是值类型，类是引用类型。值类型数据在进行函数传递时会被拷贝，引用类型不会。当定义数据结构的目的是用来封装简单的数据值，并且希望该数据结构在被赋值或传递时，封装的数据及其内部存储的属性也能够通过值传递，那么适合用结构体来定义它。</p>

<p>Swift 中类和结构体都支持属性、方法、下标、构造器、扩展和协议，与结构体相比，类还支持继承、多态、用析构器释放所分配资源以及用引用计数对一个类进行多次引用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">struct</span> <span class="n">Range</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Objective-C 和 Swift 中的属性定义其实都是 setter/getter 方法的声明，其背后还对应一个实例变量，但是在 Swift 中不能直接访问。在 Swift 中属性默认为 nonatomic 和 strong，可改用 weak var ...</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">location</span><span class="p">:</span> <span class="n">Int</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">length</span><span class="p">:</span> <span class="n">Int</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 函数与某个类型相关联后通常称为方法，结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改。但是可以为这个方法选择可变(mutating)行为，然后就可以从其方法内部改变它的属性，甚至修改 self</span>
</span><span class='line'>    <span class="kr">mutating</span> <span class="k">func</span> <span class="n">moveBy</span><span class="p">(</span><span class="n">_</span> <span class="nl">step</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">location</span> <span class="o">+=</span> <span class="n">step</span> <span class="c1">// 通常只有当属性和参数名称一样时才用 self. 方式进行赋值</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">range</span> <span class="o">=</span> <span class="n">Range</span><span class="p">(</span><span class="nl">location</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nl">length</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// 所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性，类实例没有。因为结构体属于值类型。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量，并且 mutating 方法也不可以被调用。</span>
</span><span class='line'><span class="n">range</span><span class="p">.</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1">// Swift 允许直接设置结构体属性的子属性，Objective-C 不可以（例:self.frame.size.width = 10）</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">location</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">range</span><span class="p">.</span><span class="n">moveBy</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">location</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>存储属性可存储常量或变量作为实例的一部分，只能用于类和结构体。计算属性提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值，计算属性可以用于类、结构体和枚举。</p>

<p>可以通过重写属性的方式为继承的属性添加属性观察器，但不包括常量存储型属性和只读计算型属性。父类的属性在子类的构造器中被赋值时，父类会先响应。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="p">{</span> <span class="c1">// 直接赋值或通过构造器赋值时不会触发 KVO，弱引用对象变成 nil 时也不会触发 KVO，并且不能对延迟存储做 KVO</span>
</span><span class='line'>        <span class="kr">willSet</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">print</span><span class="p">(</span><span class="n">newValue</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="kr">didSet</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">print</span><span class="p">(</span><span class="n">oldValue</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Size</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">width</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Rect</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">origin</span> <span class="o">=</span> <span class="n">Point</span><span class="p">()</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">size</span> <span class="o">=</span> <span class="n">Size</span><span class="p">()</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">center</span><span class="p">:</span> <span class="n">Point</span> <span class="p">{</span> <span class="c1">// 必须用 var 定义，因为值不是固定的</span>
</span><span class='line'>        <span class="kr">get</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">let</span> <span class="n">centerX</span> <span class="o">=</span> <span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>            <span class="k">let</span> <span class="n">centerY</span> <span class="o">=</span> <span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="n">centerX</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="n">centerY</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="kr">set</span><span class="p">(</span><span class="n">newCenter</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称 newValue</span>
</span><span class='line'>            <span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">newCenter</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>            <span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">newCenter</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// 只读计算属性，只有 get，并且可以去掉 get 关键字</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">width</span><span class="p">:</span> <span class="n">Double</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">var</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">(</span><span class="nl">origin</span><span class="p">:</span> <span class="n">Point</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">),</span> <span class="nl">size</span><span class="p">:</span> <span class="n">Size</span><span class="p">(</span><span class="nl">width</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="nl">height</span><span class="p">:</span> <span class="mi">10</span><span class="p">))</span>
</span><span class='line'><span class="n">frame</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 Objective-C 中，与类关联的静态常量或静态变量是全局的，但在 Swift 中，它的作用范围就在类型支持的范围内。</p>

<p>下标可以定义在类、结构体和枚举中，是访问集合，列表或序列中元素的快捷方式。一个类型可以定义多个下标，并通过不同索引类型进行重载。下标不限于一维，可以定义具有多个入参的下标满足自定义类型的需求。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">struct</span> <span class="n">Tyre</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">let</span> <span class="nl">row</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="nl">column</span><span class="p">:</span> <span class="n">Int</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="n">Car</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">tyre</span> <span class="o">=</span> <span class="p">[</span><span class="n">Tyre</span><span class="p">(</span><span class="nl">row</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nl">column</span><span class="p">:</span> <span class="mi">0</span><span class="p">),</span> <span class="n">Tyre</span><span class="p">(</span><span class="nl">row</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nl">column</span><span class="p">:</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Tyre</span><span class="p">(</span><span class="nl">row</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nl">column</span><span class="p">:</span> <span class="mi">0</span><span class="p">),</span> <span class="n">Tyre</span><span class="p">(</span><span class="nl">row</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nl">column</span><span class="p">:</span> <span class="mi">1</span><span class="p">)]</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">lazy</span> <span class="k">var</span> <span class="n">allComponentNames</span> <span class="o">=</span> <span class="n">Car</span><span class="p">.</span><span class="n">getAllComponentName</span><span class="p">()</span> <span class="c1">// 必须将延迟存储属性声明成变量，因为属性的初始值可能在实例构造完成之后才会得到，全局的常量或变量都是延迟计算的。</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">static</span> <span class="k">var</span> <span class="n">description</span> <span class="o">=</span> <span class="s">&quot;Car&quot;</span> <span class="c1">// 类属性无法被子类重写，class 修饰的属性可以被子类重写，但是只能用来修饰计算属性。</span>
</span><span class='line'>    <span class="k">static</span> <span class="k">func</span> <span class="n">getAllComponentName</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">String</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[]</span> <span class="p">}</span> <span class="c1">// static 换成 class 则子类可以重写该方法</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">subscript</span><span class="p">(</span><span class="nl">row</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="nl">column</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tyre</span> <span class="p">{</span> <span class="c1">// car[0, 1]</span>
</span><span class='line'>        <span class="kr">get</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">tyre</span><span class="p">[(</span><span class="n">row</span> <span class="o">*</span> <span class="n">column</span><span class="p">)</span> <span class="o">+</span> <span class="n">column</span><span class="p">]</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="kr">set</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">tyre</span><span class="p">[(</span><span class="n">row</span> <span class="o">*</span> <span class="n">column</span><span class="p">)</span> <span class="o">+</span> <span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">newValue</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">car</span> <span class="o">=</span> <span class="n">Car</span><span class="p">()</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">car</span><span class="p">.</span><span class="n">tyre</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'><span class="n">car</span><span class="p">.</span><span class="n">tyre</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tyre</span><span class="p">(</span><span class="nl">row</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nl">column</span><span class="p">:</span> <span class="mi">100</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">car</span><span class="p">.</span><span class="n">tyre</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。如果结构体或类的所有属性都有默认值，同时没有自定义的构造器，那么 Swift 会提供一个默认构造器。与 Objective-C 中的构造器不同，Swift 的构造器无需返回值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">class</span> <span class="n">User</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">10</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">var</span> <span class="n">item</span> <span class="o">=</span> <span class="n">User</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>可以将继承来的只读属性通过提供 getter/setter 重写为一个读写属性，但是不可以将继承来的读写属性重写为一个只读属性。</p>

<p>如果为值类型定义了构造器，将无法访问到他的默认构造器。这种限制可以防止你为值类型增加了一个额外的且十分复杂的构造器之后，仍然有人错误的使用自动生成的构造器，如果希望他们能同时使用，可以将自定义的构造器写到扩展中。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">// Swift 中的类没有通用基类</span>
</span><span class='line'><span class="k">class</span> <span class="n">Person</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">age</span><span class="p">:</span> <span class="n">Int</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">gender</span> <span class="o">=</span> <span class="s">&quot;male&quot;</span> <span class="c1">// 尽量为属性设置默认值，不仅代码可读性好，还可以在属性很多时减少构造器参数的个数</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span> <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">func</span> <span class="n">sayHello</span><span class="p">()</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;person: hello!&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">deinit</span> <span class="p">{</span> <span class="c1">// 析构器只适用于类类型，用法与 ARC 下的 dealloc() 一样 }</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 用 final 修饰的类不能被继承，用 final 修饰方法、属性、下标，则它们不能被重写。</span>
</span><span class='line'><span class="n">final</span> <span class="k">class</span> <span class="nl">Employee</span><span class="p">:</span> <span class="n">Person</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">company</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">position</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 重写父类的指定构造器</span>
</span><span class='line'>    <span class="kr">override</span> <span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">company</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
</span><span class='line'>
</span><span class='line'>        <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 指定构造器将初始化类中提供的所有属性，并必须调用其直接父类的的指定构造器来实现父类的初始化。每一个类都必须拥有至少一个指定构造器。</span>
</span><span class='line'>    <span class="k">init</span><span class="p">(</span><span class="nl">company</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">position</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">company</span> <span class="o">=</span> <span class="n">company</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">position</span>
</span><span class='line'>
</span><span class='line'>        <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 当参数很多时可用便利构造器辅助指定构造器初始化对象，它必须调用同类中的其它构造器，并必须最终导致一个指定构造器被调用</span>
</span><span class='line'>    <span class="n">convenience</span> <span class="k">init</span><span class="p">(</span><span class="nl">company</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">company</span><span class="p">:</span> <span class="n">company</span><span class="p">,</span> <span class="nl">position</span><span class="p">:</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 缺少 override 的重写会在编译时报错，这样可以避免意外重写。</span>
</span><span class='line'>    <span class="kr">override</span> <span class="k">func</span> <span class="n">sayHello</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">super</span><span class="p">.</span><span class="n">sayHello</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;employee: hello!&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">var</span> <span class="n">item2</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;xx&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>可以用非可失败构造器重写可失败构造器，但反过来不行。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">struct</span> <span class="n">Animal</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">let</span> <span class="nl">species</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// init? 表示可能会构造失败返回 nil</span>
</span><span class='line'>    <span class="k">init</span><span class="o">?</span><span class="p">(</span><span class="nl">species</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">species</span><span class="p">.</span><span class="n">isEmpty</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nb">nil</span> <span class="c1">// 通常构造函数不用 return，唯一用到的情景就是表示构造失败</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">species</span> <span class="o">=</span> <span class="n">species</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">someCreature</span> <span class="o">=</span> <span class="n">Animal</span><span class="p">(</span><span class="nl">species</span><span class="p">:</span> <span class="s">&quot;Giraffe&quot;</span><span class="p">)</span> <span class="c1">// someCreature 的类型是 Animal? 而不是 Animal</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="k">let</span> <span class="n">giraffe</span> <span class="o">=</span> <span class="n">someCreature</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;An animal was initialized with a species of \(giraffe.species)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>在类的构造器前添加 required 修饰符表明所有该类的子类都必须实现该构造器</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">class</span> <span class="n">SomeClass5</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">required</span> <span class="k">init</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nl">SomeSubclass</span><span class="p">:</span> <span class="n">SomeClass5</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">required</span> <span class="k">init</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 必须也用 required 应用于继承链后面的子类</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>访问控制</h3>

<p>Swift 中的访问控制模型基于模块和源文件这两个概念，并为代码中的实体提供了五种不同的访问级别。</p>

<ul>
<li>open：可以被任何模块访问、继承和重写。</li>
<li>public：可以被任何模块访问，但只能被所定义模块中的类继承和重写。</li>
<li>internal(默认)：只能被所定义的模块内部访问。</li>
<li>fileprivate：只能被所定义的文件内部访问。</li>
<li>private：只能在所定义的作用域内使用。</li>
</ul>


<p>类的访问级别会影响到类成员的默认访问级别，不可以在某个实体中定义访问级别更低的东西。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">public</span> <span class="k">var</span> <span class="nl">xx</span><span class="p">:</span> <span class="n">SomePrivateClass</span><span class="o">?</span> <span class="c1">// xx 虽然可以被外界访问，但类是私有的，所以没意义</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果想要在测试 target 中访问模块中所有内部级别的实体，可以在导入模块前使用 @testable，然后修改模块的编译设置项 Build Options -> Enable Testability。</p>

<h3>元类型</h3>

<p>元类型是指类型的类型，类、结构体或枚举类型的元类型是相应的类型名后紧跟 <code>.Type</code>，协议的元类型是该协议名字紧跟 <code>.Protocol</code>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">class</span> <span class="n">AnotherSubClass</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">let</span> <span class="nl">str</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">required</span> <span class="k">init</span><span class="p">(</span><span class="nl">str</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">str</span> <span class="o">=</span> <span class="n">str</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="nl">metatype</span><span class="p">:</span> <span class="n">AnotherSubClass</span><span class="p">.</span><span class="kt">Type</span> <span class="o">=</span> <span class="n">AnotherSubClass</span><span class="p">.</span><span class="nb">self</span>
</span><span class='line'><span class="k">let</span> <span class="n">anotherInstance</span> <span class="o">=</span> <span class="n">metatype</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">str</span><span class="p">:</span> <span class="s">&quot;some string&quot;</span><span class="p">)</span> <span class="c1">// 用元类型来 init 实例，init 必须是 required 或类是 final 的。</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">type</span><span class="p">(</span><span class="nl">of</span><span class="p">:</span> <span class="n">anotherInstance</span><span class="p">))</span> <span class="c1">// type(of:) 表达式来获取该实例在运行阶段的类型</span>
</span></code></pre></td></tr></table></div></figure>


<h3>嵌套类型</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">struct</span> <span class="n">BlackjackCard</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">enum</span> <span class="n">Suit</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">Spades</span> <span class="o">=</span> <span class="s">&quot;♠&quot;</span><span class="p">,</span> <span class="n">Hearts</span> <span class="o">=</span> <span class="s">&quot;♡&quot;</span><span class="p">,</span> <span class="n">Diamonds</span> <span class="o">=</span> <span class="s">&quot;♢&quot;</span><span class="p">,</span> <span class="n">Clubs</span> <span class="o">=</span> <span class="s">&quot;♣&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">BlackjackCard</span><span class="p">.</span><span class="n">Suit</span><span class="p">.</span><span class="n">Hearts</span><span class="p">.</span><span class="n">rawValue</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>运算符重载</h3>

<p>类和结构体可以为现有的运算符提供自定义的实现，这通常被称为运算符重载。只有组合赋值运算符可以被重载，不能对默认的赋值运算符 <code>=</code> 和三目条件运算符 <code>? :</code> 进行重载。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">struct</span> <span class="n">Vector2D</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 中缀运算符</span>
</span><span class='line'>    <span class="k">static</span> <span class="k">func</span> <span class="o">+</span> <span class="p">(</span><span class="nl">left</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">,</span> <span class="nl">right</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector2D</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="kr">left</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="kr">right</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="kr">left</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="kr">right</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 重载前缀或后缀运算符时需要在 func 前指定 prefix 或 postfix 修饰符</span>
</span><span class='line'>    <span class="k">static</span> <span class="kr">prefix</span> <span class="k">func</span> <span class="o">-</span> <span class="p">(</span><span class="nl">vector</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector2D</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="o">-</span><span class="n">vector</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="o">-</span><span class="n">vector</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">combinedVector</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">)</span>
</span><span class='line'><span class="k">let</span> <span class="n">negativeVector</span> <span class="o">=</span> <span class="o">-</span><span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>内存管理</h2>

<p>Swift 使用 ARC 机制来跟踪和管理内存，并且只针对拥有引用计数的类实例，在 ARC 中有 strong、weak、unnowned 三个关键字，默认为 strong。Swift 可以通过弱引用和无主引用来解决循环引用问题，它们都允许循环引用中的一个实例强引用而另外一个实例不保持强引用。</p>

<p>当可能造成循环引用的两个实例中的其中一个为可选类型，那么就将这个可能为 nil 的属性声明为弱引用</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">weak</span> <span class="k">var</span> <span class="nl">delegate</span><span class="p">:</span> <span class="n">XXX</span><span class="o">?</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>当可能造成循环引用的两个实例有着几乎相同的生命周期，并且都不希望值为 nil 时，将有着强制依赖性的那个实例对另一个实例持有无主引用。ARC 无法在实例被销毁后将无主引用设为 nil，所以要小心无主引用实例释放后再次使用它时出现的运行时错误。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="kr">unowned</span> <span class="k">let</span> <span class="nl">timer</span><span class="p">:</span> <span class="n">Timer</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift 提供了闭包捕获列表来解决闭包引起的循环引用。捕获列表定义了闭包体内捕获一个或者多个引用类型的规则，跟解决两个类实例间的循环引用一样。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">__weak</span> <span class="k">typeof</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="n">weakSelf</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="nb">self</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="k">__strong</span> <span class="k">typeof</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="n">strongSelf</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">strongSelf</span> <span class="n">doSomething</span><span class="p">];</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="nb">self</span><span class="p">.</span><span class="n">closure</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="kr">unowned</span> <span class="nb">self</span><span class="p">]</span> <span class="k">in</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">doSomething</span><span class="p">()</span> <span class="c1">// 必须用 self 引用属性或方法</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>扩展</h2>

<p>Swift 的扩展没有名字，可以为已有的类、结构体、枚举和协议添加方法、下标、嵌套类型、计算型属性以及确认某个协议，还可以为类添加新的便利构造器，但是不能为类添加新的指定构造器或析构器，也不可以为已有属性添加属性观察器和重写已有功能。如果要添加存储型属性也要像 Objective-C 中的方式去添加。（<a href="http://stackoverflow.com/questions/25426780/how-to-have-stored-properties-in-swift-the-same-way-i-had-on-objective-c%EF%BC%89">http://stackoverflow.com/questions/25426780/how-to-have-stored-properties-in-swift-the-same-way-i-had-on-objective-c%EF%BC%89</a></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">extension</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">mutating</span> <span class="k">func</span> <span class="n">square</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span> <span class="o">=</span> <span class="nb">self</span> <span class="o">*</span> <span class="nb">self</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>协议</h2>

<p>类、结构体或枚举都可以遵循协议，协议里的东西都是 requied 的，但是可以通过协议扩展来提供默认实现，默认实现可以被遵循协议的类型提供的实现所替代。在扩展协议的时候，还可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">protocol</span> <span class="n">Named</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span> <span class="kr">get</span> <span class="kr">set</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">protocol</span> <span class="n">Aged</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">age</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="n">TestClass</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="k">extension</span> <span class="n">Aged</span> <span class="k">where</span> <span class="nl">Self</span><span class="p">:</span> <span class="n">TestClass</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">age</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 父类名放在协议名之前</span>
</span><span class='line'><span class="k">class</span> <span class="nl">Person</span><span class="p">:</span> <span class="n">TestClass</span><span class="p">,</span> <span class="n">Named</span><span class="p">,</span> <span class="n">Aged</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// celebrator 的类型为 Named &amp; Aged，这意味着它不关心参数的具体类型，只要参数符合这两个协议即可，这称为协议合成。</span>
</span><span class='line'><span class="k">func</span> <span class="n">wishHappyBirthday</span><span class="p">(</span><span class="n">to</span> <span class="nl">celebrator</span><span class="p">:</span> <span class="n">Named</span> <span class="o">&amp;</span> <span class="n">Aged</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Happy birthday, \(celebrator.name), you&#39;re \(celebrator.age)!&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">birthdayPerson</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;xx&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">wishHappyBirthday</span><span class="p">(</span><span class="nl">to</span><span class="p">:</span> <span class="n">birthdayPerson</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>添加 class 关键字来限制协议只能被类类型遵循</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">protocol</span> <span class="nl">SomeProtocol</span><span class="p">:</span> <span class="k">class</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>使用 @objc 修饰后的类型，可以供 Objective-C 调用,标记 @objc 特性的协议只能被继承自 Objective-C 类的类或者 @objc 类遵循，以下代码是错的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="p">@</span><span class="n">objc</span> <span class="k">class</span> <span class="n">test</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 使用@objc修饰的类，必须继承自NSObject</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="p">@</span><span class="n">objc</span> <span class="k">protocol</span> <span class="n">AnotherProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">@</span><span class="n">objc</span> <span class="n">optional</span> <span class="k">func</span> <span class="n">incrementForCount</span><span class="p">(</span><span class="nl">count</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span>
</span><span class='line'>    <span class="p">@</span><span class="n">objc</span> <span class="n">optional</span> <span class="k">var</span> <span class="nl">fixedIncrement</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>泛型</h2>

<p>泛型能够减少重复代码，用一种清晰和抽象的方式来表达代码的意图。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">// 没用到泛型，它只能交换 Int 值</span>
</span><span class='line'><span class="k">func</span> <span class="nf">swapTwoInts</span><span class="p">(</span><span class="n">_</span> <span class="nl">a</span><span class="p">:</span> <span class="k">inout</span> <span class="n">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nl">b</span><span class="p">:</span> <span class="k">inout</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">temporaryA</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">temporaryA</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 用了泛型可以交换任意类型的值，T 的具体类型可以由传入的值的类型推断出来。</span>
</span><span class='line'><span class="k">func</span> <span class="n">swapTwoValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nl">a</span><span class="p">:</span> <span class="k">inout</span> <span class="n">T</span><span class="p">,</span> <span class="n">_</span> <span class="nl">b</span><span class="p">:</span> <span class="k">inout</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">temporaryA</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">temporaryA</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>泛型还可以添加类型约束，用来指定一个类型参数必须继承自指定类，或者符合一个特定的协议或协议组合。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="n">findIndex</span><span class="o">&lt;</span><span class="nl">T</span><span class="p">:</span> <span class="n">Equatable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">of</span> <span class="nl">valueToFind</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="k">in</span> <span class="nl">array</span><span class="p">:[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Int</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="n">array</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">valueToFind</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">index</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">doubleIndex</span> <span class="o">=</span> <span class="n">findIndex</span><span class="p">(</span><span class="nl">of</span><span class="p">:</span> <span class="mf">9.3</span><span class="p">,</span> <span class="k">in</span><span class="o">:</span> <span class="p">[</span><span class="mf">3.14159</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">])</span>
</span><span class='line'><span class="k">let</span> <span class="n">stringIndex</span> <span class="o">=</span> <span class="n">findIndex</span><span class="p">(</span><span class="nl">of</span><span class="p">:</span> <span class="s">&quot;Andrea&quot;</span><span class="p">,</span> <span class="k">in</span><span class="o">:</span> <span class="p">[</span><span class="s">&quot;Mike&quot;</span><span class="p">,</span> <span class="s">&quot;Malcolm&quot;</span><span class="p">,</span> <span class="s">&quot;Andrea&quot;</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift 还允许定义泛型类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">struct</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Element</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">Element</span><span class="p">]()</span>
</span><span class='line'>    <span class="kr">mutating</span> <span class="k">func</span> <span class="n">push</span><span class="p">(</span><span class="n">_</span> <span class="nl">item</span><span class="p">:</span> <span class="n">Element</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">items</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="kr">mutating</span> <span class="k">func</span> <span class="n">pop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Element</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">items</span><span class="p">.</span><span class="n">removeLast</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">stackOfStrings</span> <span class="o">=</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">()</span>
</span><span class='line'><span class="n">stackOfStrings</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="s">&quot;apple&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>错误处理</h2>

<p>和其他语言中的异常处理不同的是，Swift 中的错误处理并不涉及展开调用栈，所以对性能影响不大。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">enum</span> <span class="nl">StringError</span><span class="p">:</span> <span class="n">Error</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">StringisEmpty</span><span class="p">,</span> <span class="n">OtherError</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">func</span> <span class="n">canThrowAnError</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="n">throws</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">guard</span> <span class="o">!</span><span class="n">name</span><span class="p">.</span><span class="n">isEmpty</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">throw</span> <span class="n">StringError</span><span class="p">.</span><span class="n">StringisEmpty</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="s">&quot;no error&quot;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">do</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">str</span> <span class="o">=</span> <span class="n">try</span> <span class="n">canThrowAnError</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="c1">// 如果写成 try?，那么方法在抛出错误时，会将 nil 赋给 str，如果认为方法不可能抛出错误，可以用 try!</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;没有错误&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="n">catch</span> <span class="n">StringError</span><span class="p">.</span><span class="n">StringisEmpty</span> <span class="k">where</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;字符串不能为空&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="n">catch</span> <span class="k">let</span> <span class="n">error</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;其它错误: \(error)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>其它</h2>

<h3>给类型起别名</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">typealias</span> <span class="n">MyInt</span> <span class="o">=</span> <span class="n">Int</span>
</span></code></pre></td></tr></table></div></figure>


<h3>注释</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="cm">/* </span>
</span><span class='line'><span class="cm">    ...</span>
</span><span class='line'><span class="cm">    /* 支持多行注释嵌套 */</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="err">*/</span>
</span></code></pre></td></tr></table></div></figure>


<h3>断言</h3>

<p>一般用于在函数中对参数进行有效性验证，以避免非法的参数值导致函数不能正常执行，Xcode 在用 Release 配置项编译项目时，断言会被禁用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">age</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span>
</span><span class='line'>
</span><span class='line'><span class="n">assert</span><span class="p">(</span><span class="n">age</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;A person&#39;s age cannot be less than zero&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>编译配置语句</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="cp">#if arch(i386) || arch(x86_64)</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="cp">#if swift( &gt;=3.0.0 )</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">if</span> <span class="err">#</span><span class="n">available</span><span class="p">(</span><span class="n">iOS</span> <span class="mf">9.1.0</span><span class="p">,</span> <span class="o">*</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 使用 iOS 9.1.0+ 的 API</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">print</span><span class="p">(</span><span class="err">#</span><span class="n">file</span><span class="p">,</span> <span class="err">#</span><span class="n">function</span><span class="p">,</span> <span class="err">#</span><span class="n">line</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>标注命令</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">// MARK: - Section mark with a separator line</span>
</span><span class='line'><span class="c1">// TODO: Do something soon</span>
</span><span class='line'><span class="c1">// FIXME: Fix this code</span>
</span></code></pre></td></tr></table></div></figure>


<h3>@discardableResult</h3>

<p>如果没有使用方法返回的对象，编译器会有一个警告，有两种方法可以解决。</p>

<ul>
<li>如果是自己写的方法，在 func 前加 @discardableResult 修饰符，代表可以不使用返回值</li>
<li>对于第三方库中的方法：_ = navigationController?.popViewController(animated: true)</li>
</ul>


<h3>defer 语句</h3>

<p>defer语句在即将离开当前代码块时（throw、return 等）执行一系列语句，可用于执行一些必要的清理工作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">test</span><span class="p">(</span><span class="n">_</span> <span class="nl">param</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">guard</span> <span class="n">param</span><span class="p">.</span><span class="n">isEmpty</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">defer</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;我一定会被执行&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">test</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2><a href="https://github.com/github/swift-style-guide">代码规范</a></h2>

<ul>
<li>声明变量或常量时不用指定类型，利用类型推断方式指定类型。</li>
<li>Swift 编译器可以优化常量，所以尽可能的多用常量来增强代码的不可变性，可以让代码更加安全并提高可读性。</li>
<li>常量或变量的名字可以使用中文和 Unicode 字符，甚至可以用 Swift 关键字，但不要这样用。</li>
<li>在同一行写多条独立的语句时必须在语句后写分号，不建议这样写代码，并且只有一行代码时不要写分号</li>
<li>当确定可选类型变量有值的情况下，可以用隐式解析可选类型来定义这个变量来避免每次使用前的 if 判断，以提高效率。</li>
<li>在定义数据结构时，如果该类型不希望出现值被意外修改的情况，优先考虑用 struct 而不是 class，值类型也是线程安全的，而且是以栈的形式分配的，所以速度上会比 class 快很多，还会自动生成默认构造器。</li>
<li>尽量避免混合使用 Swift 类型和 NSObject 子类，这样会造成大量的类型转换，对性能有影响。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Carthage 做依赖管理]]></title>
    <link href="http://lijingcheng.github.io/blog/2016/12/23/shi-yong-carthage-zuo-yi-lai-guan-li/"/>
    <updated>2016-12-23T19:18:47+08:00</updated>
    <id>http://lijingcheng.github.io/blog/2016/12/23/shi-yong-carthage-zuo-yi-lai-guan-li</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/Carthage.png" width="190" height="190"  >
<strong><a href="https://github.com/Carthage/Carthage">Carthage</a> - <em>A simple, decentralized dependency manager for Cocoa.</em></strong></p>

<p>Carthage 会用最简单的方式来管理第三方库，它会在下载完第三方库代码后，通过 xcodebuild 将其编译成动态库，但它不会像 CocoaPods 那样去修改你的项目文件和编译设置，这些都需要你自己去完成。</p>

<!-- more -->


<p><br></p>

<h2>Carthage VS CocoaPods</h2>

<ul>
<li><p>CocoaPods 需要我们在本地维护第三方库依赖的 podspec 文件，大部分 pod 命令执行时都会去读取此文件，Carthage 则是去中心化的管理方式，不需要维护这种说明文件，它会去直接下载项目并编译成动态库使用，所以对使用 Carthage 的项目来说，最低系统适配要求 iOS8+</p></li>
<li><p>CocoaPods 在执行 pod install 后会帮我们做好所有配置工作，我们只需要用它提供的 workspace 文件打开项目即可，使用 Carthage 的话需要我们自己到项目中进行动态库以及打包资源的配置，但是好处是项目配置信息相对 CocoaPods 来说较干净</p></li>
<li><p>Carthage 使用的是动态库方式，所以无法进行调试，看不到源码，但带来的好处是编译速度的提高</p></li>
<li><p>Carthage 的下载源目前仅支持 GitHub（GitHub.com 和 GitHub Enterprise），CocoaPods 除了 GitHub，还支持我们托管在公司的 Git 仓库，还有本地路径</p></li>
<li><p>目前支持 CocoaPods 的第三方库比 Carthage 要多一些</p></li>
</ul>


<p>我们可以在一个项目里同时使用 CocoaPods 和 Carthage，可以用 Carthage 管理比较成熟并且不需要调试的第三方库，用来提高编译速度，再用 CocoaPods 管理其它有可能需要进行代码调试的第三方库，还可以用来在组件化开发中做依赖设置。</p>

<h2>安装 Carthage</h2>

<p>建议通过 HomeBrew 安装</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>brew update
</span><span class='line'>
</span><span class='line'>brew install carthage</span></code></pre></td></tr></table></div></figure>


<p>如果在 brew update 时提示权限问题 Error: The /usr/local directory is not writable，可以执行 sudo chown -R $(whoami):admin /usr/local 进行授权</p>

<h2>使用 Carthage</h2>

<ul>
<li>在项目目录下创建 <a href="https://github.com/Carthage/Carthage/blob/master/Documentation/Artifacts.md">Cartfile</a> 文件，并写入想要使用的第三方库</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>github "lijingcheng/FMDBHelper" == 1.0.0</span></code></pre></td></tr></table></div></figure>


<ul>
<li>获取/更新 第三方库</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>carthage update --platform iOS</span></code></pre></td></tr></table></div></figure>


<p>执行完成后，本地目录下会新增以下文件及目录</p>

<ul>
<li>Cartfile.resolved 作用同 CocoaPods 中的 Podfile.lock 文件，用来跟踪项目当前使用的第三方库版本，此文件需要提交到 Git</li>
<li>Carthage/Checkouts 第三方库的项目代码会存放在这里</li>
<li><p>Carthage/Build 用于存储根据第三方库的项目代码打包后的动态库以及 .dSYM 文件</p></li>
<li><p>将动态库添加到项目中</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Target -&gt; General -&gt; Embedded Binaries</span></code></pre></td></tr></table></div></figure>


<ul>
<li>将资源文件添加到项目中</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Target -&gt; Build Phases -&gt; Copy Bundle Resources</span></code></pre></td></tr></table></div></figure>


<ul>
<li>针对由 universal binaries 引起的 App Store submission bug，还需要添加角本，如图：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Target -&gt; Build Phases -&gt; Add -&gt; New Run Script Phase</span></code></pre></td></tr></table></div></figure>


<p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/carthage_script.png" width="1000" height="1000"  ></p>

<ul>
<li>根踪第三方库的 Crash 信息</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Target -&gt; Build Phases -&gt; Add -&gt; New Copy Files Phase</span></code></pre></td></tr></table></div></figure>


<p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/carthage_copyFiles.png" width="1000" height="1000"  ></p>

<p>进行上面操作后，在生成 .xcarchive 时也会将 .dSYM 文件复制到包里</p>

<ul>
<li>导入第三方库</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;FMDBHelper/FMDBHelper.h&gt;</span></code></pre></td></tr></table></div></figure>


<p>完成了上述步骤并提交后，其他开发人员只需要用 carthage boostrap 来将第三方库下载到本地就可以了，以后还可以通过 carthage outdated 来检查依赖的第三方库是否有更新。</p>

<h2>carthage boostrap VS carthage update</h2>

<ul>
<li>carthage update 会去读 Cartfile 文件，如果添加了新的第三方库，或更新了版本号，则需要用这个命令去下载更新，执行完成后 Cartfile.resolved 文件也会同步更新</li>
<li>carthage boostrap 会去读 Cartfile.resolved 文件，并根据指定版本号进行下载，所以如果只是为了下载则可以使用这个命令</li>
</ul>


<h2>让自己的开源项目支持 Carthage</h2>

<p>Carthage 仅支持动态库，所以你的开源项目也只能支持 iOS8 及以上版本</p>

<ul>
<li><p>Carthage 提供给用户的动态库是根据项目中的 <code>动态库 Target</code> 编译打包后生成的，所以首先我们需要新建一个 Target，选择 Cocoa Touch Framework（动态库），并设置 Deployment Target</p></li>
<li><p>添加 .h 文件到 Build Phases -> Headers -> Public</p></li>
<li><p>添加 .m 文件到 Build Phases -> Compile Sources</p></li>
<li><p>添加其它资源文件到 Build Phases -> Copy Bundle Sources</p></li>
<li><p>Carthage 只构建从 .xcodeproj 分享出来的 scheme，所以需要我们在 Manage Schemes 中将新生成的 scheme 设置为 shared</p></li>
<li><p>通过 <code>carthage build --no-skip-current</code> 来检测 scheme 是否能够构建成功，然后检查 Carthage/Build 目录</p></li>
<li><p>Carthage 通过搜索 Git tag 来决定用户可以下载哪个版本的项目资源，所以还需要在提交代码后添加 tag 并 push 到 GitHub，格式建议写成 1.2.0 或 v1.2</p></li>
<li><p>通过添加下面内容，用来在项目 Readme.md 文件上显示 <img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat" alt="Carthage compatible" /></p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[![Carthage compatible](https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat)](https://github.com/Carthage/Carthage)</span></code></pre></td></tr></table></div></figure>


<p><br></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Xcodebuild 打包 IPA 并上传蒲公英]]></title>
    <link href="http://lijingcheng.github.io/blog/2016/12/05/tong-guo-xcodebuildda-bao-ipabing-shang-chuan-pu-gong-ying/"/>
    <updated>2016-12-05T18:49:45+08:00</updated>
    <id>http://lijingcheng.github.io/blog/2016/12/05/tong-guo-xcodebuildda-bao-ipabing-shang-chuan-pu-gong-ying</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/xcodebuild.jpg" width="200" height="200"  >
 xcodebuild - 是苹果提供的项目自动构建工具，包含在 Command Line Tools 中，可以完成 iOS 项目的编译、打包和签名等工作。<br/>
 <br/>
 shell script - 是一种命令语言，有点像 Windows 下的批处理，但更强大，它可以跑在 Linux/Unix 系统的 shell 程序中。</p>

<!-- more -->


<p><br/></p>

<h2>为什么要用 xcodebuild</h2>

<p>通过 Xcode 对项目进行编译打包，并将 IPA 分发给测试人员这一过程操作步骤多并繁琐，而在 shell 脚本中使用 xcodebuild 命令执行这一过程便会非常方便快捷，特别是当项目进入测试阶段，每天都会打一个或多个测试包时，使用脚本进行自动化打包能够大大提高我们的工作效率。</p>

<h2>以前的作法</h2>

<p>AFNetworking 的作者 mattt 曾经提供了一个名为 <a href="https://github.com/nomad/shenzhen">shenzhen</a> 的打包服务，使用起来非常简单方便，并且能够在打包后上传到很多分发平台上，可惜已经有两年多没有再维护了。</p>

<h2>造个轮子</h2>

<p>因为打包脚本写起来比较简单，并且它也会随着 Xcode 的发展而改变，所以在这里我们还是选择自己写一个脚本使用并维护，下面的介绍不会太详细，如果有更多需求可以使用以下命令来查看帮助，并修改脚本。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xcodebuild --help</span></code></pre></td></tr></table></div></figure>


<p>完成打包并分发这一过程通常分为四个步骤： &ldquo;build 工程 -> 生成 xcarchive 文件 -> 生成 ipa 文件 -> 上传到分发平台&rdquo;</p>

<h2>完整脚本</h2>

<p>新建 xxx.sh 文件，然后将下面脚本复制过去，如果你也在用 CocoaPods，并且只需要打 Release 包，那么只需要用蒲公英提供给你的 userKey 和 apiKey 替换掉脚本里的就可以了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#!/bin/sh</span>
</span><span class='line'>
</span><span class='line'><span class="cp">##########################################################################</span>
</span><span class='line'><span class="cp">######   1.执行 chmod +x ./xxx.sh 使脚本具有执行权限                    ######</span>
</span><span class='line'><span class="cp">######   2.通过 ./xxx.sh 执行脚本，./ 不能省略                          ######</span>
</span><span class='line'><span class="cp">######   3.Xcode 需要配置好证书，并且不能连接非测试机，否则会签名失败        ######</span>
</span><span class='line'><span class="cp">######   4.将 .xcarchive 中的 .dSYM 文件备份一下                       ######</span>
</span><span class='line'><span class="cp">######   5.在蒲公英网站的应用设置中添加成员后，便会在上传成功后给他发邮件     ######</span>
</span><span class='line'><span class="cp">##########################################################################</span>
</span><span class='line'>
</span><span class='line'><span class="cp"># CocoaPods 打包需要使用 workspace 名字</span>
</span><span class='line'><span class="n">WorkSpace_Name</span><span class="o">=</span><span class="err">`</span><span class="n">find</span> <span class="p">.</span> <span class="o">-</span><span class="n">name</span> <span class="o">*</span><span class="p">.</span><span class="n">xcworkspace</span> <span class="o">|</span> <span class="n">awk</span> <span class="o">-</span><span class="n">F</span> <span class="s">&quot;[/.]&quot;</span> <span class="err">&#39;</span><span class="p">{</span><span class="n">print</span> <span class="err">$</span><span class="p">(</span><span class="n">NF</span><span class="o">-</span><span class="mi">1</span><span class="p">)}</span><span class="err">&#39;`</span>
</span><span class='line'>
</span><span class='line'><span class="cp"># 要打包的 scheme 名字，默认与 workspace 名字一样</span>
</span><span class='line'><span class="n">Scheme_Name</span><span class="o">=</span><span class="err">$</span><span class="p">{</span><span class="n">WorkSpace_Name</span><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp"># build 文件目录</span>
</span><span class='line'><span class="n">Build_File_Path</span><span class="o">=</span><span class="err">$</span><span class="p">(</span><span class="n">PWD</span><span class="p">)</span><span class="o">/</span><span class="n">build</span><span class="o">/</span><span class="n">Release</span><span class="o">-</span><span class="n">iphoneos</span>
</span><span class='line'>
</span><span class='line'><span class="cp"># build 文件名字 (archive/ipa)</span>
</span><span class='line'><span class="n">Build_File_Name</span><span class="o">=</span><span class="err">$</span><span class="p">{</span><span class="n">Build_File_Path</span><span class="p">}</span><span class="o">/</span><span class="err">$</span><span class="p">{</span><span class="n">Scheme_Name</span><span class="p">}</span><span class="err">$</span><span class="p">(</span><span class="n">date</span> <span class="o">+%</span><span class="n">Y</span><span class="o">%</span><span class="n">m</span><span class="o">%</span><span class="n">d</span><span class="o">%</span><span class="n">H</span><span class="o">%</span><span class="n">M</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="cp"># 蒲公英</span>
</span><span class='line'><span class="n">PGY_User_Key</span><span class="o">=</span><span class="s">&quot;由蒲公英提供&quot;</span>
</span><span class='line'><span class="n">PGY_API_Key</span><span class="o">=</span><span class="s">&quot;由蒲公英提供&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="cp"># 开始时间</span>
</span><span class='line'><span class="n">Start_Time</span><span class="o">=</span><span class="err">`</span><span class="n">date</span> <span class="o">+%</span><span class="n">s</span><span class="err">`</span>
</span><span class='line'>
</span><span class='line'><span class="n">echo</span> <span class="s">&quot;================= 开始编译 =================&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">xcodebuild</span> <span class="n">clean</span> <span class="o">-</span><span class="n">workspace</span> <span class="err">$</span><span class="p">{</span><span class="n">WorkSpace_Name</span><span class="p">}.</span><span class="n">xcworkspace</span> <span class="o">-</span><span class="n">scheme</span> <span class="err">$</span><span class="p">{</span><span class="n">Scheme_Name</span><span class="p">}</span> <span class="o">-</span><span class="n">configuration</span> <span class="n">Release</span> <span class="o">-</span><span class="n">sdk</span> <span class="n">iphoneos</span> <span class="n">SYMROOT</span><span class="o">=</span><span class="err">$</span><span class="p">(</span><span class="n">PWD</span><span class="p">)</span><span class="o">/</span><span class="n">build</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="o">!</span> <span class="p">[</span> <span class="err">$</span><span class="o">?</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">];</span> <span class="n">then</span>
</span><span class='line'>    <span class="n">exit</span> <span class="mi">1</span>
</span><span class='line'><span class="n">fi</span>
</span><span class='line'>
</span><span class='line'><span class="n">echo</span> <span class="s">&quot;================= 开始构建 =================&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">xcodebuild</span> <span class="n">archive</span> <span class="o">-</span><span class="n">workspace</span> <span class="err">$</span><span class="p">{</span><span class="n">WorkSpace_Name</span><span class="p">}.</span><span class="n">xcworkspace</span> <span class="o">-</span><span class="n">scheme</span> <span class="err">$</span><span class="p">{</span><span class="n">Scheme_Name</span><span class="p">}</span> <span class="o">-</span><span class="n">archivePath</span> <span class="err">$</span><span class="p">{</span><span class="n">Build_File_Name</span><span class="p">}.</span><span class="n">xcarchive</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="o">!</span> <span class="p">[</span> <span class="o">-</span><span class="n">d</span> <span class="s">&quot;${Build_File_Name}.xcarchive&quot;</span> <span class="p">];</span> <span class="n">then</span>
</span><span class='line'>    <span class="n">exit</span> <span class="mi">1</span>
</span><span class='line'><span class="n">fi</span>
</span><span class='line'>
</span><span class='line'><span class="n">echo</span> <span class="s">&quot;================= 导出ipa =================&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">xcodebuild</span> <span class="o">-</span><span class="n">exportArchive</span> <span class="o">-</span><span class="n">archivePath</span> <span class="err">$</span><span class="p">{</span><span class="n">Build_File_Name</span><span class="p">}.</span><span class="n">xcarchive</span> <span class="o">-</span><span class="n">exportPath</span> <span class="err">$</span><span class="p">{</span><span class="n">Build_File_Path</span><span class="p">}</span> <span class="o">-</span><span class="n">exportOptionsPlist</span> <span class="err">$</span><span class="p">(</span><span class="n">PWD</span><span class="p">)</span><span class="o">/</span><span class="n">exportOptions</span><span class="p">.</span><span class="n">plist</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">[</span> <span class="o">-</span><span class="n">e</span> <span class="s">&quot;${Build_File_Path}/${Scheme_Name}.ipa&quot;</span> <span class="p">];</span> <span class="n">then</span>
</span><span class='line'>    <span class="n">mv</span> <span class="s">&quot;${Build_File_Path}/${Scheme_Name}.ipa&quot;</span> <span class="s">&quot;${Build_File_Name}.ipa&quot;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>    <span class="n">exit</span> <span class="mi">1</span>
</span><span class='line'><span class="n">fi</span>
</span><span class='line'>
</span><span class='line'><span class="n">echo</span> <span class="s">&quot;================= 上传到蒲公英 =================&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">curl</span> <span class="o">-</span><span class="n">F</span> <span class="s">&quot;file=@${Build_File_Name}.ipa&quot;</span> <span class="o">-</span><span class="n">F</span> <span class="s">&quot;uKey=${PGY_User_Key}&quot;</span> <span class="o">-</span><span class="n">F</span> <span class="s">&quot;_api_key=${PGY_API_Key}&quot;</span> <span class="nl">https</span><span class="p">:</span><span class="c1">//www.pgyer.com/apiv1/app/upload</span>
</span><span class='line'>
</span><span class='line'><span class="cp"># 结束时间</span>
</span><span class='line'><span class="n">End_Time</span><span class="o">=</span><span class="err">`</span><span class="n">date</span> <span class="o">+%</span><span class="n">s</span><span class="err">`</span>
</span><span class='line'>
</span><span class='line'><span class="n">echo</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">================= 耗时: $[ End_Time - Start_Time ] 秒 =================&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在导出 ipa 文件时，需要我们提供一个 plist 文件，用于配置打包过程中所需要的参数，文件名为 exportOptions.plist，并放在项目根目录下，内容用下面提供的就可以，如果不满足需要，可通过 xcodebuild &ndash;help 查看帮助。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
</span><span class='line'><span class="cp">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span>
</span><span class='line'><span class="nt">&lt;plist</span> <span class="na">version=</span><span class="s">&quot;1.0&quot;</span><span class="nt">&gt;</span>
</span><span class='line'><span class="nt">&lt;dict&gt;</span>
</span><span class='line'>  <span class="nt">&lt;key&gt;</span>provisioningProfiles<span class="nt">&lt;/key&gt;</span>
</span><span class='line'>  <span class="nt">&lt;dict&gt;</span>
</span><span class='line'>      <span class="nt">&lt;key&gt;</span>com.xx.xx(bundleid)<span class="nt">&lt;/key&gt;</span>
</span><span class='line'>      <span class="nt">&lt;string&gt;</span>profile文件名<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/dict&gt;</span>
</span><span class='line'>  <span class="nt">&lt;key&gt;</span>teamID<span class="nt">&lt;/key&gt;</span>
</span><span class='line'>  <span class="nt">&lt;string&gt;</span>由苹果提供<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>  <span class="nt">&lt;key&gt;</span>method<span class="nt">&lt;/key&gt;</span>
</span><span class='line'>  <span class="nt">&lt;string&gt;</span>development<span class="nt">&lt;/string&gt;</span>
</span><span class='line'><span class="nt">&lt;/dict&gt;</span>
</span><span class='line'><span class="nt">&lt;/plist&gt;</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 应用的开发设计]]></title>
    <link href="http://lijingcheng.github.io/blog/2016/09/05/ios-appde-zu-jian-hua-she-ji/"/>
    <updated>2016-09-05T18:40:19+08:00</updated>
    <id>http://lijingcheng.github.io/blog/2016/09/05/ios-appde-zu-jian-hua-she-ji</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/component.jpg" width="200" height="200"  >
<strong><em>实现功能是软件开发的最低要求。</em></strong></p>

<p><br><br><br></p>

<!-- more -->


<p>2010 年初刚开始做 iOS 开发的时候，对自己的要求就是能够实现功能，随着时间和经验的累积，逐渐从各方面提高要求，包括设计易扩展的代码架构、合理的管理内存、组件化管理项目、以及 app 的安全问题。</p>

<h2>架构设计</h2>

<p>架构设计可以以业务为驱动，按照最适合自己的方式去设计，设计思路和方法尽量统一，同类型问题用同样方式去解决，下面几点是我认为比较重要的：</p>

<ul>
<li><p>关注分离<br/>
将系统分解为多个模块并各司其职，纵向分层，横向拆分业务。</p></li>
<li><p>高内聚<br/>
一个模块只完成一个功能，并合理有度的进行封装。</p></li>
<li><p>松耦合<br/>
依赖关系越少越好，尽量不横向依赖，不跨层访问。继承是紧耦合的一种操作，它通常与多态一起存在，如果仅仅是为了代码重用而做的继承还不如用组合。</p></li>
<li><p>适度设计<br/>
对业务方该限制的地方要进行限制，该灵活的地方也要给业务方创造灵活实现的条件，架构的设计要保持一定量的超前性而做到易扩展，但不要设计过度，避免多做无用功而增加框架复杂度。好的架构是随着时间而更新的，而不是一开始就设计好了一切。</p></li>
<li><p>技术选型<br/>
不要仅是为了体验新技术而改变现有架构，等别人把坑踩平后再根据团队及业务情况考虑是否使用，技术本身没有什么好不好，只有适合不适合。例如在 MVC、MVVM、MVCS 等架构模式如何选择这个问题上，我觉得可以根据业务情况选择使用，并且它们可以在项目里同时存在。</p></li>
</ul>


<h2>组件化</h2>

<p>随着 app 功能和体积的增长，也带来了一些问题，例如编译速度缓慢、commit 代码经常要 merge、业务代码混在一起、开发功能类似的新项目时需要从头搭建。组件化可以有效解决这些问题。</p>

<h3>拆分组件</h3>

<p>每个组件对应一个 project，身为组件的同时还能够独立运行，大项目可以按业务模块拆分，中小项目按框架拆分就可以了，我目前使用的拆分方式就是将 <code>底层框架代码</code> 和 <code>UI控件</code> 分别作为两个组件，再和项目工程组装在一起。</p>

<h3>组件之间的依赖关系</h3>

<p>业务模块依赖于框架、业务模块之间尽量避免横向依赖、禁止框架依赖业务模块。</p>

<h3>组件化实施</h3>

<p>如果开发人员需要维护所有组件，那么可以将它们都下载到本地，然后通过本地链接的方式去组合，如果组件数量非常多，并且开发人员不需要维护所有组件，或者对于不需要维护组件的测试人员，可以通过远程 Git 链接的方式去组合。不管哪种方式都可以通过 CocoaPods 来组装，组装的核心就是 Podfile 和 Podspec。</p>

<ul>
<li>Podfile：在项目工程中定义各组件间的依赖关系，定义方式大概如下：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source 'https://github.com/CocoaPods/Specs.git'
</span><span class='line'>
</span><span class='line'>platform :ios, '9.0'
</span><span class='line'>
</span><span class='line'>inhibit_all_warnings!
</span><span class='line'>
</span><span class='line'>target 'XXFoundation' do
</span><span class='line'>    project 'XXFoundation/XXFoundation'
</span><span class='line'>    
</span><span class='line'>    pod "SDWebImage", "4.0.1"
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>target 'TargetName' do
</span><span class='line'>    # 非开发人员，或不需要调试框架的开发人员可以直接从远端下载框架并依赖到项目中，缺点是不便于调试
</span><span class='line'>    def podRemote
</span><span class='line'>        pod 'XXFoundation', :git =&gt; 'http://gitlab.xxx.com/ios/xxfoundation.git', :branch =&gt; 'developer'
</span><span class='line'>        pod 'XXUIKit', :git =&gt; 'http://gitlab.xxxx.com/ios/xxuikit.git', :branch =&gt; 'develop'
</span><span class='line'>    end
</span><span class='line'>
</span><span class='line'>    # 开发人员可以将框架下载到项目根目录下，这种方式调试开发会方便一些
</span><span class='line'>    def podLocal
</span><span class='line'>        pod 'XXFoundation', :path =&gt; 'XXFoundation'
</span><span class='line'>        pod 'XXUIKit', :path =&gt; 'XXUIKit'
</span><span class='line'>    end
</span><span class='line'>
</span><span class='line'>    # 可以用 dev=1 pod install 来使用 podLocal 定义的方式组建工程
</span><span class='line'>    if ENV['dev']
</span><span class='line'>        podLocal
</span><span class='line'>    else
</span><span class='line'>        podRemote
</span><span class='line'>    end
</span><span class='line'>      
</span><span class='line'>    pod 'SSZipArchive', '1.8.1'
</span><span class='line'>    
</span><span class='line'>    pod 'JPush', '3.0.6'
</span><span class='line'>    
</span><span class='line'>    # 没有在 github 上维护的第三方库，可放在本地 Vendors 目录中，并通过 Podspec 定义需要打包的资源
</span><span class='line'>    pod 'WeixinSDK', :path =&gt; 'WandaFilm/Vendors/WeixinSDK/WeixinSDK.podspec'
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Podspec：各个组件在这里定义需要打包的代码及资源，资源包括 xib、国际化文件、assets 等文件。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Pod::Spec.new do |s|
</span><span class='line'>  s.name         = "XXFoundation"
</span><span class='line'>  s.version      = "0.0.1"
</span><span class='line'>  s.license      = "MIT"
</span><span class='line'>  s.summary      = 'XXFoundation for cocoapods.'
</span><span class='line'>  s.author       = { "lijingcheng" =&gt; "jingcheng.li@xx.com" }
</span><span class='line'>  s.homepage     = "http://xx.com"
</span><span class='line'>  s.platform     = :ios, "9.0"
</span><span class='line'>  s.prefix_header_file = "XXFoundationPrefixHeader.pch"
</span><span class='line'>  
</span><span class='line'>  # 如果要打包的是本地资源就用：{ :path =&gt; "." }
</span><span class='line'>  s.source       = { :git =&gt; "git@gitlab.xxx.com:ios/xxfoundation.git", :tag =&gt; '0.0.1' }
</span><span class='line'>  
</span><span class='line'>  # 需要打包的代码，** 表示会递归查找目录下的所有相关文件
</span><span class='line'>  s.source_files = ["Classes/XXFoundation.h", "Classes/**/*.{h,m}"]
</span><span class='line'>  
</span><span class='line'>  # 需要打包的资源，需要注意的是 xcassets 实际上是文件夹
</span><span class='line'>  s.resource = ["Classes/**/*.{xib,storyboard}", "*.xcassets/**/*.png", "zh-Hans.lproj", "en.lproj"]
</span><span class='line'>  
</span><span class='line'>  # 依赖了第三方库
</span><span class='line'>  s.dependency     'SDWebImage', '4.0.1'
</span><span class='line'>
</span><span class='line'>  # 依赖了系统 framework
</span><span class='line'>  s.frameworks   = "SystemConfiguration", "CoreTelephony"
</span><span class='line'>  
</span><span class='line'>  # 依赖了本地第三方 framework
</span><span class='line'>  s.vendored_frameworks = "XXFoundation/Vendors/WebP_0.6.0/WebP.framework"
</span><span class='line'>
</span><span class='line'>  # 依赖了系统 lib
</span><span class='line'>  s.libraries    = "z", "stdc++", "sqlite3"
</span><span class='line'>
</span><span class='line'>  # 依赖了本地第三方 lib
</span><span class='line'>  s.vendored_libraries = "libWeChatSDK.a"
</span><span class='line'>  
</span><span class='line'>  # 需要修改 Build Settings
</span><span class='line'>  s.xcconfig = {
</span><span class='line'>    'GCC_PREPROCESSOR_DEFINITIONS' =&gt; '$(inherited) SD_WEBP=1',
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  # 默认 ARC，由于用到的 ASIHTTPRequest 为 MRC，所以这里需要指明
</span><span class='line'>  s.subspec "ASIHTTPRequest" do |sp|
</span><span class='line'>    sp.requires_arc = false
</span><span class='line'>    sp.source_files = "Vendors/ASIHTTPRequest/*.{h,m}"
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>如果用本地链接的方式组建项目，由于各工程间的代码和资源是通过类似“快捷方式”的形式互相引用，所以需要注意下面两个问题</p>

<ul>
<li><p>当某个组件中新增或删除了类文件或资源文件，在另一个工程中想要响应此变化则需要重新执行 <code>pod update --no-repo-update</code> 来更新工程间的引用状态，如果仅是修改操作则不需要此步骤。</p></li>
<li><p>Assets.xcassets 在这时只是个文件夹，所以这里维护的图片名字和实际文件的名字必须保持一致，否则会出现找不到资源的问题。</p></li>
</ul>


<h3>编译速度优化</h3>

<p>app 组件化后，独立运行各个组件时，编译速度还是很理想的，但是运行主项目，还是会有编译速度过慢的问题，这时可以考虑将部分组件进行二进制化，也就是将依赖库中的代码打包成静态库或动态库，然后再链接到主项目中，通常可用下面几种方式实现</p>

<ul>
<li><p>Framework：在各组件工程中新建 Framework Target 并自己维护打包角本以及需要打进包的资源，当组件有变更时需要重新打包。</p></li>
<li><p><a href="https://github.com/Carthage/Carthage">Carthage</a> 同样需要在组件工程中新建 Framework Target，仅支持 GitHub 上的资源。</p></li>
<li><p><a href="https://github.com/CocoaPods/cocoapods-packager">CocoaPods Packager</a> 也是通过 podspec 来定义需要打进包的资源，并且要将 podspec 上传到 CocoaPods 的 podspec 仓库中。</p></li>
</ul>


<p>其实 Carthage 和 CocoaPods Package 也是将组件打出 Framework，然后再将他们添加到项目工程中，只是不用我们自己去维护打包角本。目前我在项目里没有做组件的二进制化，因为组件中的资源还不是很多，所以花时间和精力去维护这些操作不太值得。</p>

<h2>安全机制</h2>

<p>我们从 AppStore 下载的 app 其实都已经由苹果进行了加壳，要砸壳后才能有办法看到汇编形式的源代码，如果我们要自己再加一层壳，可以对关键代码的方法名做一些混淆，以增加别人分析代码的复杂度，不过这对于大多数 app 来说不太值得去做，我们可以把精力放在其他更易做并且更有效率的地方。</p>

<h3>本地数据</h3>

<ul>
<li>存储在沙盒里的文件是能够被拿到的，所以对于 sqlite、plist 等文件不要存储重要信息，如果一定要存，可以将信息用对称加密(AES)的方式处理后再存储，用于加密的 key 不要以名文的方式写在代码里，可以在 app 启动时，管后台要一个非对称加密过的 key，并且这个 key 后台应该定期变更。</li>
</ul>


<h3>网络数据</h3>

<ul>
<li><p>使用 Https 来保证数据传输的安全，它还可以用来确认网站的真实性，防止用户误入钓鱼网站。</p>

<ul>
<li>对称加密：文件加密和解密使用相同的密钥，AES 相对其他对称加密方式来说更安全些。</li>
<li>非对称加密：需要公钥和私钥，用公钥对数据进行加密，只有对应的私钥才能解密；如果用私钥对数据进行加密，那么只有对应的公钥才能解密。可以用 RSA 来做非对称加密，相对对称加密来说，速度较慢，但非常安全，据说还没被破解过。</li>
<li>单向认证：只要求站点部署了 SSL 证书就行，并且客户端要信任服务端证书，我们可以在代码里设置为不支持无效证书，并且对域名做验证，一般应用都是用单向认证。</li>
<li>双向认证：需要服务端与客户端都提供证书，并且他们之间相互信任，安全性相对要高一些，适合对安全性要求比较高的应用。<br/>
<br></li>
</ul>
</li>
<li><p>即使用了 Https 也要对一些关键数据再次加密，因为数据还是有可能被人拦截拿到。（当用户使用不安全的 WIFI 并且请求被代理拦截后，代理伪装用户去请求服务，并对拿到的证书进行解密骗取公钥，然后再用自己做的假证书伪装成服务器证书传递给用户骗取信任。）</p></li>
<li><p>可以对重要接口的 URL 的参数进行加密</p></li>
<li><p>通过代码签名确保 AP I的调用者来自你允许的 app</p></li>
</ul>


<h2>优化 app</h2>

<h3>数据处理</h3>

<ul>
<li>将接口数据缓存到本地，频繁使用的接口数据还可以放到内存里，可以用 NSCache 存储缓存数据，好处是它可以自动清理内存占用，并且是线程安全的。</li>
<li>缓存的接口数据要设置一个过期时间，用来及时更新数据，并且每隔一段时间还要清理下数据，例如每隔 N 天清理 N 天前缓存的数据。</li>
<li>考虑用 ProtoBuf 替代 JSON，也可以仅是个别数据量大的接口改为 ProtoBuf 格式数据</li>
<li>请求的图片格式可以由 jpg 改为 webp</li>
<li>使用 gzip 对接口数据进行压缩</li>
<li>按 UIImageView 大小取合适大小的图片，不要直接取原图</li>
<li>非关键的业务数据，可以通过合并接口的方式，减少和服务器的交互次数。</li>
<li>请求接口前客户端通过对 request params 做检查来减少不必要的网络请求</li>
<li>可以在离开页面等场景下 cancel 网络请求</li>
<li>可以用 ETag 这种服务端加本地验证的方式处理返回数据，当数据没有更新时不返回数据，而是返回 304</li>
<li>数据量大时要提示用户是否在非 wifi 环境下下载</li>
</ul>


<h3>启动时间</h3>

<p>可以通过 Instruments 的 Time Profiler 工具来查看代码耗费时间</p>

<ul>
<li>+load 方法如果做了过多耗时操作，或者过多的引用第三方 framework 都会增加 pre-main 阶段的耗费时间</li>
<li>检查 didFinishLaunchingWithOptions 方法，将部分操作改为异步执行或延迟处理</li>
</ul>


<h3>app 瘦身</h3>

<ul>
<li>将部分资源文件从工程中移除，改为从接口获取，并且可以通过给数据加版本号，避免每次重复下载。</li>
<li>清理无用的代码和资源，不要 @1x 图片，如果用到了 ProtoBuf，可以将 .proto 文件从 Compile Sources 中移除。</li>
<li>压缩图片</li>
<li>小图标可以使用 iconfont 替代，大图可以用 pdf 替代或者只留 @3x 图</li>
<li>启动图界面用 LaunchScreen.storyboard，不要用多张 Default 图。</li>
<li>用 .xcassets 来管理图片，Xcode 能够把里边的所有 png 图片压缩成一个Assets.car 文件。并且 iOS9 之后，如果是用 .xcassets 管理图片，AppStore 会根据不同设备准备不同的安装包，每个包内只有对应尺寸的图片，例如 iPhone6 下载 app 时，包里就只有 @2x 图。</li>
</ul>


<h3>其他</h3>

<ul>
<li>延迟处理不需要马上展现的视图或操作</li>
<li>不要阻塞主线程，能异步去做的就不要同步。</li>
<li>由于 UIKit 中大部分对象都不是线程安全的，所以 UI 操作都需要放在主线程做串行处理，否则可能会导致未知行为（动画异常、页面错乱、Crash）。</li>
<li>优化表格滑动

<ul>
<li>提前算 Cell 高度并缓存，如果要加载的数据也是要经过处理才展示的也提前处理好</li>
<li>异步绘制，滑动过程中不加载图片</li>
<li>当 Cell 中有很多子视图并且他们要在不同条件下展示时，考虑拆成多个 Cell</li>
<li>不要在 Cell 中频繁生成 NSDateFormatter 对象</li>
</ul>
</li>
<li>通过设置模拟器的 Debug 菜单下的几项设置来查看图层视图是否需要优化

<ul>
<li>Color Blended layers<br/>
大多情况是因为视图的 backgroundColor 与父视图颜色不一致或者是透明的，它会用红色表示有问题的视图，而绿色的表示没问题</li>
<li>Color copied images<br/>
当图片的色彩格式不能被 GPU 处理时，会交由 CPU 处理，应该尽可能避免这种问题</li>
<li>Color misaligned images<br/>
图片大小与控件不一致，会用黄色表示图片被缩放了，用紫色表示像素没对齐</li>
<li>Color offscreen-rendered<br/>
用黄色标示哪些 layer 需要做离屏渲染，多数时候离屏渲染会影响性能，应避免重写 drawRect 方法，避免使用 masksToBounds(设置圆角/模糊效果)、shouldRasterize(光栅化)、shadow(阴影)</li>
</ul>
</li>
</ul>


<p>PS：过早的优化是万恶之源！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 开发 Tips]]></title>
    <link href="http://lijingcheng.github.io/blog/2016/06/09/ioskai-fa-tips/"/>
    <updated>2016-06-09T10:58:59+08:00</updated>
    <id>http://lijingcheng.github.io/blog/2016/06/09/ioskai-fa-tips</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/tips.jpg" width="200" height="200"  >
<strong>tips - <em>记录一些东西，希望也能帮助到有需要的人。</em></strong></p>

<p><br>
<br></p>

<!-- more -->


<p><br></p>

<ul>
<li>用模拟器调试动画功能时，让动画执行的慢一些</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>模拟器菜单：Debug -&gt; Show Animations</span></code></pre></td></tr></table></div></figure>


<ul>
<li>取两位整数，不够补 0</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSLog(@"%@", [NSString stringWithFormat:@"%02d月", 3]);</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在不知道谁是第一响应者时隐藏键盘</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[[[UIApplication sharedApplication] keyWindow] endEditing:YES];</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Provisioning Profiles 所在路径</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>~/Library/MobileDevice/Provisioning Profiles</span></code></pre></td></tr></table></div></figure>


<ul>
<li>解码 cms 加密后的授权文件</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>终端：security cms -D -i example.mobileprovision</span></code></pre></td></tr></table></div></figure>


<ul>
<li>查找代码中的中文字符串，做国际化适配时会用到</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Xcode左侧导航处：Find -&gt; Regular Expression，然后输入 @"[^"]*[\u4E00-\u9FA5]+[^"\n]*?"</span></code></pre></td></tr></table></div></figure>


<ul>
<li>忽略第三方 SDK 文档中的警告</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>build settings -&gt;  Other Warning Flags -&gt; -Wno-documentation</span></code></pre></td></tr></table></div></figure>


<ul>
<li>关闭 UINavigationController 滑动返回功能</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.navigationController.interactivePopGestureRecognizer.enabled = NO;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>自定义 leftBarButtonItem 后，左滑返回手势失效</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.navigationController.interactivePopGestureRecognizer.delegate = self;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在 xib 中给 UILabel 或 UITextView 设置多行文字</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>输入文字后，用 control + enter 来插入换行符，相当于在代码中添加 \n</span></code></pre></td></tr></table></div></figure>


<ul>
<li>禁用 UIButton 并且颜色不变灰</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>button.userInteractionEnabled = NO;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>UITableView 的分割线左边顶头</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tableView.separatorInset = UIEdgeInsetsZero;
</span><span class='line'>cell.layoutMargins = UIEdgeInsetsZero;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>修改约束后，用动画展示效果</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[UIView animateWithDuration:0.3f animations:^{
</span><span class='line'>    [myView layoutIfNeeded];
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<ul>
<li>给 UIView 设置透明度后不影响 subviews</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>superView.backgroundColor = [[UIColor blackColor] colorWithAlphaComponent:0.5];</span></code></pre></td></tr></table></div></figure>


<ul>
<li>隐藏 Grouped TableView 上边多余的间隔</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.tableView.tableHeaderView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, CGFLOAT_MIN)];</span></code></pre></td></tr></table></div></figure>


<ul>
<li>编译出 error 后继续编译</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Xcode -&gt; preference -&gt; general -&gt; 勾选 Continue building after errors</span></code></pre></td></tr></table></div></figure>


<ul>
<li>清理 Derived Data</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Xcode -&gt; Product -&gt; 按下 option -&gt; 选择 Clean Build Folder... </span></code></pre></td></tr></table></div></figure>


<ul>
<li>自定义类后，禁止通过 init 方法初始化对象</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (instancetype)init UNAVAILABLE_ATTRIBUTE;
</span><span class='line'>或
</span><span class='line'>- (instancetype)init __attribute__((unavailable("init 方法不可用，请用 initWithName:")));</span></code></pre></td></tr></table></div></figure>


<ul>
<li>忽略可以忽略的警告，<a href="http://fuckingclangwarnings.com">更多警告</a></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#pragma clang diagnostic push
</span><span class='line'>#pragma clang diagnostic ignored "-Wdeprecated-declarations"
</span><span class='line'>
</span><span class='line'>#pragma clang diagnostic pop
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>KVC</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *numbers = @[@4, @81, @2]; // @[@{@"price": @4}, @{@"price": @81}, @{@"price": @2}]
</span><span class='line'>
</span><span class='line'>NSLog(@"max = %@", [numbers valueForKeyPath:@"@max.self"]); // @max.price
</span><span class='line'>NSLog(@"min = %@", [numbers valueForKeyPath:@"@min.self"]); // @min.price
</span><span class='line'>NSLog(@"sum = %@", [numbers valueForKeyPath:@"@sum.self"]); // @sum.price
</span><span class='line'>NSLog(@"avg = %@", [numbers valueForKeyPath:@"@avg.self"]); // @avg.price
</span><span class='line'>
</span><span class='line'>//数组去重
</span><span class='line'>NSArray *devices = @[@"iPhone6", @"iPhone5", @"iPhone6 Plus", @"iPhone6", @"iPhone5"];
</span><span class='line'>
</span><span class='line'>NSLog(@"devices = %@", [devices valueForKeyPath:@"@distinctUnionOfObjects.self"]); // iPhone5, iPhone6, iPhone6 Plus
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[代码重构]]></title>
    <link href="http://lijingcheng.github.io/blog/2016/05/09/man-chang-de-dai-ma-zhong-gou-zhi-lu/"/>
    <updated>2016-05-09T10:50:10+08:00</updated>
    <id>http://lijingcheng.github.io/blog/2016/05/09/man-chang-de-dai-ma-zhong-gou-zhi-lu</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/refactor.jpg" width="200" height="200"  >
<strong>代码重构 - <em>重构就是在不改变软件系统外部行为的前提下，改善它的内部结构。</em></strong></p>

<p>Martin Flower 在《重构》中有一句经典的话："任何一个傻瓜都能写出计算机可以理解的程序，只有写出人类容易理解的程序才是优秀的程序员。"</p>

<!-- more -->


<h1>重构原则</h1>

<p>随着时间推移，需求的频繁变化等原因都会导致代码质量逐步下降，所以持续重构就变得越来越重要，并且重构对开发人员技术水平及经验的要求会更高一些，下面列出几条重构原则：</p>

<ul>
<li><p>要充分理解旧代码后再进行修改，模块之间过度耦合导致牵一发而动全身，不易控制影响范围，有时代码摆放顺序的修改都会造成问题</p></li>
<li><p>优先重构经常修改的部分，如果代码一两年都没有修改过，那么说明改动的收益很小</p></li>
<li><p>重构可能需要很长时间，并且不是非要一次做完，主要取决于团队对于风险的容忍程度</p></li>
<li><p>删除无用代码是提高代码可维护性最有效的方式</p></li>
<li><p>小范围重构，当重构后会导致大量测试工作时，需要谨慎决定是否有必要重构</p></li>
<li><p>要构建可扩展系统，我们需要认同错误的不可避免性，有时候避免这些错误会带来高昂的成本，因此我们不妨将注意力集中在对问题的快速检测以及出现后的应对措施上</p></li>
</ul>


<p><br></p>

<h1>哪种代码需要重构</h1>

<ul>
<li><p>臃肿的类：一个类应该只做一件事，可通过一些设计模式去拆分</p></li>
<li><p>长方法：方法应尽量短小，专注一个功能点，并且要放在合适的类里</p></li>
<li><p>重复代码：往往由于开发人员对框架不熟悉，也有个别不讲究的情况</p></li>
<li><p>方法有多个参数：可通过提取成类对象或字典解决，个别情况也可拆分方法</p></li>
<li><p>魔鬼数字：尽量用常量去定义数字，或在使用处添加注释说明用意</p></li>
<li><p>模糊的命名：要做到见名知意</p></li>
<li><p>if/else 嵌套过多：尽量不超过3层，如果不能简化逻辑，可通过拆分方法或添加注释方式解决</p></li>
</ul>


<p><br></p>

<h1>Xcode 提供的重构功能</h1>

<p>跟别的开发工具相比 Xcode 提供的重构功能简直弱暴了，不过有总比没有好，Xcode 提供了以下几个重构功能，从菜单栏中进入：Edit -> Refactor，或在代码上右键，然后选择 Refactor</p>

<ul>
<li>Rename：重命名类、方法、变量</li>
<li>Extract：将方法中的一段代码抽取为一个独立的方法</li>
<li>Create Superclass：给当前选中的类创建父类</li>
<li>Move Up：将选中方法或属性移到父类中</li>
<li>Move Down：将父类中选中的属性移到子类中</li>
<li>Encapsulate：封装，生成 setter/getter，一般用不上</li>
</ul>


<p>相对来说，Rename 更常用一些，有时也会用到 Extract，最后吐槽一下</p>

<ul>
<li>Extract：使用时 Xcode 经常崩掉</li>
<li>Rename：并不能保证全部覆盖到，还需要自己再次检查</li>
</ul>


<p><br></p>

<h1>代码 Review</h1>

<p>重构的目的是保证代码质量，但是代码质量不能仅仅依靠重构，重构更多时候是一种补救措施，更多时候还是需要我们在写代码时讲究一些，适当的有一些代码洁癖，也需要通过持续的代码 Review 保证代码质量，在 Review 上需要注意：</p>

<ul>
<li><p>要有一个 CheckList，对一些代码问题进行定义，要求开发人员以此为准写代码</p></li>
<li><p>review 代码不应只是代码规范层级上的检查，这些应该是各开发人员必须做好的事情，可以用 OCLint 来做这些事情</p></li>
<li><p>review 别人代码时不要直接修改不规范的代码，可以用 #warning &hellip; 标注有问题的代码，review 的目的不仅是要保证代码质量，提高团队开发人员技术水平也是一个重要目的</p></li>
<li><p>review 时需要对代码逻辑及性能上的问题进行检查</p></li>
<li><p>对方改完代码后要进行验证</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[了解 Block]]></title>
    <link href="http://lijingcheng.github.io/blog/2015/12/03/liao-jie-block/"/>
    <updated>2015-12-03T15:09:29+08:00</updated>
    <id>http://lijingcheng.github.io/blog/2015/12/03/liao-jie-block</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/block.png" width="220" height="220"  >
<strong>block - <em>其实就是 Objective-C 对于闭包的对象实现。</em></strong></p>

<p>Block 是 Apple 为 C、C++ 以及 Objective-C 添加的特性，使得这些语言可以用类 lambda 表达式的语法来创建闭包。在适当的时候使用 block 替代 delegation 可以使代码看起来更紧凑，但也需要注意 block 带来的循环引用问题。</p>

<!-- more -->


<h1>Block</h1>

<p>block 实际上就是对象，它会被编译成 struct 并分配好空间，主要包括 isa 指针、block 对应实现函数的地址以及 block 复制过来的变量，在学习 block 的很多特性时，如果能以 &ldquo;block是对象，块中代码是函数&rdquo; 的思维去思考，很多问题就都会变得简单了。</p>

<ul>
<li>isa：指向 block 对应的 Class

<ul>
<li>_NSConcreteGlobalBlock：定义在全局区的 block 会作为代码片段存在</li>
<li>_NSConcreteStackBlock：定义在方法中的 block 会保存在栈中，当函数返回时被销毁</li>
<li>_NSConcreteMallocBlock：为了增加 block 的生命周期，可以用 copy 方法将其复制到堆中，如果 block 已经在堆里了，再次进行 copy 只会增加引用计数</li>
</ul>
</li>
<li>IMP：block 块中的代码会作为方法形式存在，IMP 指向方法地址</li>
<li>复制的变量：block 能够读取它所在函数的内部变量，该变量会被复制到 struct 中，默认是值复制，不能够修改，用 __block 修饰的是引用复制，所以可以修改</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">__block</span> <span class="bp">NSInteger</span> <span class="n">mutiplier</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="c1">// 用 __block 修饰后，在 block 里就可以修改 mutiplier 的值</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 定义名为 myBlock 的代码块，返回值类型为 NSInteger，并有一个名为 num 的 NSInteger 型参数</span>
</span><span class='line'><span class="bp">NSInteger</span> <span class="p">(</span><span class="o">^</span><span class="n">myBlock</span><span class="p">)(</span><span class="bp">NSInteger</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="bp">NSInteger</span> <span class="n">num</span><span class="p">){</span>
</span><span class='line'>    <span class="n">mutiplier</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">num</span> <span class="o">*</span> <span class="n">mutiplier</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%ld&quot;</span><span class="p">,</span> <span class="n">myBlock</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span> <span class="c1">// 像调用函数一样使用 block</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><br></p>

<h1>循环引用(retain cycle)</h1>

<p>对象之间相互持有便会造成循环引用问题，下面用一个经典例子看一下怎么解决 block 中的循环引用问题</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 因为 self 会强引用 block，所以避免 block 强引用 self 对象</span>
</span><span class='line'><span class="k">__weak</span> <span class="n">__typeof</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span><span class="n">weakSelf</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">AFNetworkReachabilityStatusBlock</span> <span class="n">callback</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">AFNetworkReachabilityStatus</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 如果有多处引用 weakSelf，则需要转成 strongSelf，避免 weakSelf 被释放后出现问题</span>
</span><span class='line'>    <span class="k">__strong</span> <span class="n">__typeof</span><span class="p">(</span><span class="n">weakSelf</span><span class="p">)</span><span class="n">strongSelf</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">strongSelf</span><span class="p">.</span><span class="n">networkReachabilityStatus</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">strongSelf</span><span class="p">.</span><span class="n">networkReachabilityStatusBlock</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">strongSelf</span><span class="p">.</span><span class="n">networkReachabilityStatusBlock</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<h1>Block 作为属性使用</h1>

<ul>
<li>将 block 定义成类型</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">^</span><span class="n">BannerViewSelectedBlock</span><span class="p">)(</span><span class="bp">NSString</span> <span class="o">*</span><span class="n">bannerId</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>然后定义相关属性，虽然 strong 和 copy 的实际效果一样，为了代码可读性还是建议用 copy</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="n">BannerViewSelectedBlock</span> <span class="n">seletedBlock</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>定义方法用来接收 block 参数并设置 block 属性，如有多个参数，block 参数应为最后一个</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setCompletionBlockWithSeleted:</span><span class="p">(</span><span class="n">BannerViewSelectedBlock</span><span class="p">)</span><span class="nv">completionBlock</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">seletedBlock</span> <span class="o">=</span> <span class="n">completionBlock</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>调用上面定义的方法，并传入 BannerViewSelectedBlock 类型的 block 代码块</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">bannerView</span> <span class="nl">setCompletionBlockWithSeleted</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="n">bannerId</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>当发生相关事件时触发 block 属性中的代码块</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">seletedBlock</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nb">self</span><span class="p">.</span><span class="n">seletedBlock</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">item</span><span class="p">][</span><span class="s">@&quot;bannerId&quot;</span><span class="p">]);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="https://github.com/lijingcheng/JCBannerView">参考代码</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C Runtime 开发]]></title>
    <link href="http://lijingcheng.github.io/blog/2015/09/21/objective-c-runtimekai-fa/"/>
    <updated>2015-09-21T14:30:27+08:00</updated>
    <id>http://lijingcheng.github.io/blog/2015/09/21/objective-c-runtimekai-fa</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/runtime.jpg" width="150" height="150"  >
<strong>Runtime - <em>使用 C 和汇编实现的运行时代码库，Objective-C 中有很多语言特性都是通过它来实现。</em></strong> <br/>
<br>
了解 Runtime 开发可以帮助我们更灵活的使用 Objective-C 这门语言，我们可以将程序功能推迟到运行时再去决定怎么做，还可以利用 Runtime 来解决项目开发中的一些设计和技术问题，使开发过程更加具有灵活性。</p>

<!-- more -->


<h1>一些关键字</h1>

<ul>
<li><p>self：类的隐藏参数变量，指向当前调用方法的对象</p></li>
<li><p>super：是编译器的标示符，通过 super 调用方法会被翻译成 objc_msgSendSuper(self, _cmd,&hellip;)</p></li>
<li><p>SEL：以方法名为内容的 C 字符串</p></li>
<li><p>IMP：指向方法实现的函数指针</p></li>
<li><p>id：指向类对象或实例对象的指针</p></li>
<li><p>isa：为 id 对象所属类型 (objc_class)，Objc 中的继承就是通过 isa 指针找到 objc_class，然后再通过 super_class 去找对应的父类</p></li>
<li><p>metaclass：在 Objc 中，类本身也是对象，实例对象的 isa 指向它所属的类，而类对象的 isa 指向元类 (metaclass)，元类的 isa 直接指向根元类，根元类的isa指向它自己，它们之间的关系如下图所示。</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/ios_runtime_class.png" width="400" height="400"  ></span></code></pre></td></tr></table></div></figure>


<p><br/></p>

<h1>消息传递 (Messaging)</h1>

<p>Objective-C 对于调用对象的某个方法这种行为叫做给对象发送消息，实际上就是沿着它的 isa 指针去查找真正的函数地址。下面我们来了解一下这个过程：</p>

<ul>
<li>我们写一个给对象发送消息的代码</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">array</span> <span class="nl">insertObject</span><span class="p">:</span><span class="n">obj</span> <span class="nl">atIndex</span><span class="p">:</span><span class="mi">5</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>编译器首先会将上面代码翻译成这种样子</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">objc_msgSend</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">insertObject</span><span class="p">:</span><span class="nl">atIndex</span><span class="p">:),</span> <span class="n">obj</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<ul>
<li>系统在运行时会通过 array 对象的 isa 指针找到对应的 class（如果是给类发消息，则找到的是metaclass）。</li>
<li>在 class 的 cache 方法列表中用 SEL 去找对应 method，如果找不到便去 class 的方法列表中去找</li>
<li>如果在方法列表中也找不对对应 method 时，便沿着继承体系继续向上查找

<ul>
<li>找到后将 method 放入 cache，以便下次能快速定位，然后再去执行 method 的 IMP</li>
<li>找不到时系统便报错：unrecognized selector sent to insertObject:atIndex:</li>
</ul>
</li>
</ul>


<p><br/>
<strong>Runtime 提供了三种方法避免因为找不到方法而崩溃</strong></p>

<ul>
<li>当找不到方法实现时，Runtime 会先发送 +resolveInstanceMethod: 或 +resolveClassMethod: 消息，我们可以重写它然后为对象指定一个处理方法。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">dynamicXXXMethod</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">_cmd</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;ok...&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">resolveInstanceMethod:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSEL</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">aSEL</span> <span class="o">==</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">xxx</span><span class="p">:))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">class_addMethod</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="n">aSEL</span><span class="p">,</span> <span class="p">(</span><span class="kt">IMP</span><span class="p">)</span><span class="n">dynamicXXXMethod</span><span class="p">,</span> <span class="s">&quot;v@:&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="nb">super</span> <span class="n">resolveInstanceMethod</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>class_addMethod 方法的最后一个参数用来指定所添加方法的参数及返回值，叫 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encodings</a>。</p></blockquote>

<ul>
<li>如果 resolve 方法返回 NO，Runtime 会发送 -forwardingTargetForSelector: 消息，允许我们将消息转发给能处理它的其它对象。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">forwardingTargetForSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">aSelector</span> <span class="o">==</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">xxx</span><span class="p">:)){</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">otherObject</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">forwardingTargetForSelector</span><span class="p">:</span><span class="n">aSelector</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>当 -forwardingTargetForSelector: 返回 nil 时，Runtime 会发送 -methodSignatureForSelector: 和 -forwardInvocation: 消息。我们可以选择忽略消息、抛出异常、将消息转由当前对象或其它对象的任意消息来处理。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//根据 SEL 生成 NSInvocation 对象，然后再由 -forwardInvocation: 方法进行转发。</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSMethodSignature</span> <span class="o">*</span><span class="p">)</span><span class="nf">methodSignatureForSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">NSMethodSignature</span> <span class="o">*</span><span class="n">signature</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">methodSignatureForSelector</span><span class="p">:</span><span class="n">aSelector</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signature</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">signature</span> <span class="o">=</span> <span class="p">[</span><span class="n">otherObject</span> <span class="nl">instanceMethodSignatureForSelector</span><span class="p">:</span><span class="n">aSelector</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">signature</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">forwardInvocation:</span><span class="p">(</span><span class="bp">NSInvocation</span> <span class="o">*</span><span class="p">)</span><span class="nv">invocation</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">SEL</span> <span class="n">sel</span> <span class="o">=</span> <span class="n">invocation</span><span class="p">.</span><span class="n">selector</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span><span class="p">([</span><span class="n">otherObject</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="n">sel</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">invocation</span> <span class="nl">invokeWithTarget</span><span class="p">:</span><span class="n">otherObject</span><span class="p">];</span> <span class="c1">// 转发消息</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">doesNotRecognizeSelector</span><span class="p">:</span><span class="n">sel</span><span class="p">];</span> <span class="c1">// 抛出异常</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><br/></p>

<h1>KVO</h1>

<p>当我们为对象添加观察者后，Runtime 会在运行时创建这个对象所在类的子类，并且将该对象的 isa 指针指向这个子类，然后重写监听属性的 set 方法并在方法中调用 -willChangeValueForKey: 和 -didChangeValueForKey: 来通知观察者，所以如果直接修改实例变量便不会触发监听方法。当移除观察者后，Runtime 便会将这个子类删除。</p>

<p>所以 isa 指针并不总是指向实例对象所属的类，也有可能指向一个中间类，所以不能依靠它来确定类型，而是应该用 class 方法来确定实例对象的类。</p>

<p><br/></p>

<h1>关联对象 (Associated Objects)</h1>

<p>在 Category 中可以为类添加实例方法或类方法，但是不支持添加实例变量，所以即使我们在 Category 中为类添加了 property，也不能直接使用它，Runtime 可以解决这个问题，我们只需要定义一个指针，然后通过 objc_setAssociatedObject 方法将指针与对象进行关联并指定内存管理方式，数据以 KeyValue 的形式存储在一个 HashMap 里。</p>

<p>注：Objc 中的类和对象都是结构体，Category 也是这样，定义的方法和属性在结构体中的存储，并在运行时按倒序添加到主类中（添加的方法会放在方法列表的上面），所以如果添加的方法与原类中的一样，那么在调用此方法时，优先找到的便是我们添加的这个方法。如果有多个 Category 添加同样名称的方法，那么这些方法在方法列表中的顺序取决于他们的编译顺序，也就是这些 Category 文件在 Compile Sources 中的顺序。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="bp">NSObject</span> <span class="nl">(JC)</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">ID</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="bp">NSObject</span> <span class="nl">(JC)</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">IDKey</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">ID</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">IDKey</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setID:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">ID</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">IDKey</span><span class="p">,</span> <span class="n">ID</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_COPY_NONATOMIC</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>
<br/></p>

<h1>AOP(Method Swizzling)</h1>

<p>我们可以通过继承、Category、AOP 方式来扩展类的功能。</p>

<ul>
<li>继承比较适合在设计底层代码架构时使用，不适当的使用会让代码看起来很啰嗦，并且增加维护难度。</li>
<li>Category 适合为现有类添加方法。</li>
<li>当需要修改现有类的方法并且拿不到源码时，继承和 AOP 都能解决问题，但是用 AOP 来解决代码耦合度更低。其实就算能拿到源码，往往直接去改源码也不是个好办法。</li>
</ul>


<p><br/>
在 Objective-C 中，可以通过 Method Swizzling 技术来实现 AOP，下面我们通过交换两个方法的实现代码来向已存在的方法中添加其它功能。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &lt;objc/runtime.h&gt; </span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="bp">UIViewController</span> <span class="nl">(Tracking)</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">load</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
</span><span class='line'>    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="kt">Class</span> <span class="n">aClass</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="k">class</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">SEL</span> <span class="n">originalSelector</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">viewWillAppear</span><span class="p">:);</span>
</span><span class='line'>        <span class="kt">SEL</span> <span class="n">swizzledSelector</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">swizzled_viewWillAppear</span><span class="p">:);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">Method</span> <span class="n">originalMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">aClass</span><span class="p">,</span> <span class="n">originalSelector</span><span class="p">);</span>
</span><span class='line'>        <span class="n">Method</span> <span class="n">swizzledMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">aClass</span><span class="p">,</span> <span class="n">swizzledSelector</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 如果要对类方法进行交换，使用下面注释的代码</span>
</span><span class='line'>        <span class="c1">// Class aClass = object_getClass((id)self);</span>
</span><span class='line'>        <span class="c1">// </span>
</span><span class='line'>        <span class="c1">// Method originalMethod = class_getClassMethod(aClass, originalSelector);</span>
</span><span class='line'>        <span class="c1">// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// 交换两个方法的实现</span>
</span><span class='line'>      <span class="c1">// 防止 aClass 不存在 originalSelector，所以添加一下试试，但指向地址为新方法地址</span>
</span><span class='line'>        <span class="kt">BOOL</span> <span class="n">didAddMethod</span> <span class="o">=</span> <span class="n">class_addMethod</span><span class="p">(</span><span class="n">aClass</span><span class="p">,</span> <span class="n">originalSelector</span><span class="p">,</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">swizzledMethod</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">swizzledMethod</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">didAddMethod</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="c1">// 添加成功，说明 aClass 不存在 originalSelector，所以替换 swizzledSelector 的 IMP 为 originalMethod，实质上它们都指向 swizzledMethod</span>
</span><span class='line'>            <span class="n">class_replaceMethod</span><span class="p">(</span><span class="n">aClass</span><span class="p">,</span> <span class="n">swizzledSelector</span><span class="p">,</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">));</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>          <span class="c1">// 添加失败，说明 aClass 存在 originalSelector，直接交换</span>
</span><span class='line'>            <span class="n">method_exchangeImplementations</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">,</span> <span class="n">swizzledMethod</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - Method Swizzling </span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 由于方法实现已经被交换，所以系统在调用 viewWillAppear: 时，实际上会调用 swizzled_viewWillAppear:</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">swizzled_viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// 下面代码表面上看起来会引起递归调用，由于函数实现已经被交换，实际上会调用 viewWillAppear:</span>
</span><span class='line'>   <span class="p">[</span><span class="nb">self</span> <span class="nl">swizzled_viewWillAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 在原有基础上添加其它功能(写日志等)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>
<br/>
需要注意一个问题，如果你用了 swizzled_viewWillAppear 作为方法名，那么如果你引用的第三方 SDK 中也用了这个方法名来做方法交换，那会造成方法的递归调用，所以你最好换一个不会被重复使用的方法名，例如 mx_swizzled_viewWillAppear。</p>

<p><br/></p>

<h1>其它</h1>

<p>我们可以通过 Runtime 特性来获得类的所有属性名称和类型，然后再通过 KVC 将 JSON 中的值填充给该类的对象。还可以在程序运行时为类添加方法或替换方法从而使对象能够更灵活的根据需要来选择实现方法。总之 Runtime 库就象一堆积木，只要发挥想象力便能实现各种各样的功能，但前提是你需要了解它。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 内存管理]]></title>
    <link href="http://lijingcheng.github.io/blog/2015/07/12/iosnei-cun-guan-li/"/>
    <updated>2015-07-12T15:07:54+08:00</updated>
    <id>http://lijingcheng.github.io/blog/2015/07/12/iosnei-cun-guan-li</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/memory.jpg" width="200" height="200"  >
<strong>内存管理 - <em>指程序在运行时申请内存，并在使用完后释放内存的过程</em></strong></p>

<p>内存管理不当造成的主要问题便是内存泄漏和过度释放，虽然 ARC 使我们可以不去关注内存管理上的一些细节问题，但掌握一些相关知识还是很有必要的。</p>

<!-- more -->


<p><br></p>

<h1>一些概念</h1>

<ul>
<li><p>MRC：manual reference counting，自己编写内存管理代码（retain、release、autorelease&hellip;）</p></li>
<li><p>ARC：automatic reference counting，编译器会在编译阶段为代码加上优化过的内存管理代码，这样就可以让我们不必花费大量时间在内存管理上面，可以将更多的精力放在业务代码上。</p></li>
<li><p>内存泄漏：不再使用的对象内存没有释放掉，将导致内存占用无限增长，即便是使用 ARC，也会因为循环引用问题而造成内存泄露，并且还要注意与 CoreFoundation 对象进行桥接时要手动释放内存。</p></li>
<li><p>内存过度释放：释放了仍在使用中的对象，将导致应用崩溃</p></li>
</ul>


<p><br></p>

<h1>内存管理规则</h1>

<p>内存管理是建立在对象的拥有关系上的，当拥有对象后就要负责释放它，并且不要释放非自己持有的对象，具体规则如下：</p>

<ul>
<li>拥有对象所有权

<ul>
<li>通过 alloc/new/copy/mutableCopy 创建对象</li>
<li>在某些场景里避免一个对象被移除，可以对它进行 retain</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">Student</span> <span class="o">*</span> <span class="n">stu1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Student</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">Student</span> <span class="o">*</span> <span class="n">stu2</span> <span class="o">=</span> <span class="p">[</span><span class="n">stu1</span> <span class="k">retain</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>放弃对象拥有权

<ul>
<li>立即释放：给对象发送一个 release 消息</li>
<li>延迟释放：给对象发送一个 autorelease 消息</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="n">Student</span> <span class="o">*</span><span class="p">)</span><span class="nf">studentWithName:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Student</span> <span class="o">*</span><span class="n">stu</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Student</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithName</span><span class="p">:</span><span class="n">name</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">stu</span> <span class="n">autorelease</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>实现 dealloc 方法来释放对象自身内存与它所持有的资源，此方法由系统在该对象被销毁时自动调用</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="n">_firstName</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">_lastName</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">[</span><span class="nb">super</span> <span class="n">dealloc</span><span class="p">];</span> <span class="c1">// 必须先释放自己占有的资源再通过此行代码释放自己</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<h3>ARC 带来的变化</h3>

<ul>
<li>不能够自己调用 retain/release/autorelease，由编译器自动插入</li>
<li>dealloc 方法中不能调用 [super dealloc] ，由系统去调用并释放实例变量和 assocate 对象，weak 对象也是在这时被设置为 nil，我们只需要释放一些资源，如通知、KVO 等</li>
</ul>


<p><br></p>

<h1>引用计数</h1>

<p>内存管理规则中的对象所有权是通过引用计数来实现，除了常量以外，每个对象都有一个引用计数。</p>

<ul>
<li>创建对象时，计数为 1</li>
<li>给对象发送 retain 消息时，计数加 1</li>
<li>给对象发送 release 消息时，计数减 1</li>
<li>给对象发送 autorelease 消息时，计数在当前自动释放池代码块结束时减 1</li>
<li>当对象的计数为 0 时将被销毁</li>
</ul>


<blockquote><p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/retaincount.png" width="700" height="700"  ></p></blockquote>

<p><br></p>

<h1>属性修饰符</h1>

<h3>MRC 中包括 assign/copy/retain</h3>

<ul>
<li>assign：表示在 setter 中仅是简单的赋值，不改变引用计数，一般用来修饰基本类型和 delegate 属性</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">)</span> <span class="bp">NSInteger</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">)</span> <span class="kt">id</span> <span class="n">delegate</span><span class="p">;</span> <span class="c1">// 避免引用循环，但要在适当时候设置为 nil</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 对应 setter 方法</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setCount:</span><span class="p">(</span><span class="bp">NSInteger</span><span class="p">)</span><span class="nv">count</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">_count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>copy：表示在 setter 中将参数进行内存 copy 后再进行赋值，一般用于不可变字符串、字典、Block</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 对应 setter 方法</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setUserName:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">userName</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">id</span> <span class="n">tempName</span> <span class="o">=</span> <span class="p">[</span><span class="n">userName</span> <span class="k">copy</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">_userName</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'>  <span class="n">_userName</span> <span class="o">=</span> <span class="n">tempName</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>retain：表示在 setter 中将参数对象 retain 后再进行赋值，一般用于可变字符串、可变字典及其他对象</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">retain</span><span class="p">)</span> <span class="bp">NSMutableString</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 对应 setter 方法</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setUserName:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">userName</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="n">userName</span> <span class="k">retain</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">_userName</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'>  <span class="n">_userName</span> <span class="o">=</span> <span class="n">userName</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<h3>ARC 中包括 assign/weak/unsafe_unretained/copy/strong</h3>

<ul>
<li>assign：同 MRC 中的 assign 一样，只是不再用来修饰 delegate 对象</li>
<li>weak：可以避免循环引用，用来修饰对象，但在 setter 中是简单赋值，不改变引用计数，和 assign 的区别在于属性被销毁后会被设置为 nil，所以能在继续使用该属性时避免程序崩溃，一般用来修饰 delegate 对象和 IBOutlet 对象。</li>
<li>unsafe_unretained：和 weak 相似，区别在于被销毁时不会置为 nil (unsafe)，它主要是为了兼容 4.0 系统而存在(iOS4 以及之前没有 weak)，由于 weak 会对性能有一点影响，因此对性能要求很高的地方可以考虑使用 unsafe_unretained 替换 weak</li>
<li>copy：同 MRC 中的 copy 一样</li>
<li>strong：同 MRC 中的 retain 一样</li>
</ul>


<h3>runtime 是如何将 weak 对象设置为 nil?</h3>

<p>weak 对象会被放入到一个 hash 表中，并用它指向的对象内存地址作为 key，当此对象的 dealloc 方法被调用时，会用这个 key 将指向它的 weak 对象数组找出来，并将里面的对象都设置为 nil，最后再从 weak hash 表中删除这条数据。</p>

<h3>列出几种有问题的写法</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 当源字符串是 NSMutableString 类型时，strong 是浅拷贝，copy 才是深拷贝，所以 str 会随着源字符串的修改而变化</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSMutableString</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 当源字符串是 NSString 类型时，不管用 strong 还是 copy 都是浅拷贝，所以这里 str 指向的仍然是 NSString 对象，当用 str 调用 NSMutableString 类的 insert 等方法时会报错&quot;找不到该方法&quot;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">)</span> <span class="kt">id</span> <span class="n">delegate</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// MRC 下需要自己在 dealloc 中将 delegate 设置为 nil， ARC 下需要用 weak 修饰 delegate 属性</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">newString</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// newString属性对应的 getter 也叫 newString，ARC下编译器不允许方法名以 alloc/init/new/copy/mutableCopy 开头，它会根据方法以什么开头来决定内存管理方式</span>
</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<h1>AutoreleasePool</h1>

<p>当不再使用一个对象时应该将其释放，但是在某些情况下，我们很难理清一个对象什么时候不再使用，Objc 提供的自动释放池可以解决这个问题，只需要给这种对象发送 autorelease 消息，就会将该对象放到池子里，当池子被清理时，会给池里所有的对象发送 release 消息。</p>

<ul>
<li>每个 RunLoop 在迭代时都会创建自动释放池，并在迭代后释放池子。如果是我们自己创建的池子，会在出了 @autoreleasepool 的大括号后进行清理。通常我们不用自己去创建池子，但是遇到循环次数较大时会导致内存占用不断增长，这时需要我们自己创建自动释放池</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>      <span class="bp">NSString</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>AutoreleasePool 由若干个 AutoreleasePoolPage 类的对象以双向链表的形式组合而成，每个 Page 对象都记录着自己所在线程、链表的 parent/child 结点，还有被添加进来的 autorelease 对象和 next 指针。Page 对象用栈的结构形式存储 autorelease 对象，next 指针会被初始化在栈底，当有对象入栈时，便会指向下一地址，直到 Page 空间被占满便指向栈顶，这时如果再添加 autorelease 对象，便会交给新建的 Page 对象存储，并连接链表。</p></li>
<li><p>每添加一个 @autoreleasepool {} 都会被编译器改成</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 会在现有 AutoreleasePoolPage 对象中添加一个哨兵对象用来标记位置</span>
</span><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="n">objc_autoreleasePoolPush</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="p">...</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 给晚于哨兵对象后加入的所有 autorelease 对象发送 release 消息，并修改 next 指针（可以跨 Page）</span>
</span><span class='line'><span class="n">objc_autoreleasePoolPop</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过下面这张图可以更好的理解这些细节</p>

<p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/autorelease_pool.jpg" width="800" height="600"  ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 多线程开发]]></title>
    <link href="http://lijingcheng.github.io/blog/2015/06/03/iosduo-xian-cheng-kai-fa/"/>
    <updated>2015-06-03T15:07:00+08:00</updated>
    <id>http://lijingcheng.github.io/blog/2015/06/03/iosduo-xian-cheng-kai-fa</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/thread.png" width="200" height="200"  >
<strong>多线程 - <em>合理的线程分配能够提高程序的执行效率和资源利用率。</em></strong></p>

<p>GCD 基于 C API，Operation Queue 是在 GCD 基础上实现的，效率上较 GCD 会差一点点，但代码可读性和易用性较高，简单的任务可用 GCD 去实现，复杂一些的还是推荐使用 Operation Queue 来处理。微小的性能提升远不如写出可维护性高的代码来的实在。</p>

<!-- more -->


<h1>一些概念</h1>

<ul>
<li>进程和线程

<ul>
<li>进程是一个可执行程序，至少有一个线程，也可以包含多个线程</li>
<li>线程是执行程序最基本的单元，在进程中负责执行任务，每个进程至少有一个线程（主线程）</li>
</ul>
</li>
<li>主线程和子线程

<ul>
<li>主线程是随着进程的创建而创建的，主线程结束，其他线程也会结束</li>
<li>子线程由其他线程创建，一般子线程退出不会影响主线程</li>
</ul>
</li>
<li>同步和异步

<ul>
<li>同步任务在执行过程中会阻塞当前线程，直到任务执行完毕</li>
<li>异步任务在执行过程中不会阻塞当前线程</li>
</ul>
</li>
<li>串行队列和并行队列

<ul>
<li>串行队列中装载的线程是按进队列顺序一个一个执行</li>
<li>并行队列中装载的线程可以一起执行，可以通过设置最大并发数，限制同时最多执行几个线程</li>
</ul>
</li>
<li>并发和并行

<ul>
<li>并发在多核设备上是真正意义上的多任务同时运行，而在单核设备上是以分时共享的方式同时执行多个任务，需要先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程，因为这个过程很快所以会给我们并发执行的错觉</li>
<li>并行是真正意义上的多任务同时运行</li>
</ul>
</li>
<li>优先级和优先级反转

<ul>
<li>正常情况下优先级高的任务会比优先级低的先执行</li>
<li>优先级反转指程序在运行时，低优先级的任务由于某种原因不能释放掉锁，所以阻塞了高优先级的任务，而其他不需要该共享资源的低优先级任务会在高优先级任务之前执行，从而反转了任务的优先级。设置任务的优先级会让本来就复杂的并行编程变得更加复杂和不可预见，所以建议只使用默认优先级。</li>
</ul>
</li>
<li>生产者和消费者模式：是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。我们还可以使用多个线程来生产数据，同样可以使用多个消费线程来消费数据。而更复杂的情况是，消费者消费的数据，有可能需要继续处理，于是消费者处理完数据之后，它又要作为生产者把数据放在新的队列里，交给其他消费者继续处理。</li>
<li>为了防止多个线程抢夺同一个资源造成数据安全问题可采取以下措施

<ul>
<li>锁：在同一时刻，只允许一个线程访问某个特定资源

<ul>
<li>NSLock：最基本的锁，通过 lock 和 unlock 加锁解锁，@synchronize 会自动加锁解锁，但性能稍差</li>
<li>NSRecursiveLock：递归锁，可以在一个线程中反复获取锁不会造成死锁，可用在循环或递归操作中</li>
<li>NSConditionLock：条件锁，为加锁/解锁设置条件</li>
</ul>
</li>
<li>信号量：和锁很像，区别在于它可以控制同时访问同一资源的线程个数</li>
<li>串行队列：一个一个执行就避免了同步问题</li>
</ul>
</li>
<li>死锁：当多个线程在相互等待对方结束时，就会发生死锁，在下面的例子中，大多数时候 swap 方法都能正常运行，但是当两个线程使用相反的值来同时调用 swap 时，程序就会很可能由于死锁而被终止。线程1 获得了 X 的一个锁，线程2 获得了 Y 的一个锁。接着它们会同时等待另外一把锁，但是永远都不会获得。所以我们要尽量减少线程间资源共享，并确保共享的资源尽量简单。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void swap(A, B)
</span><span class='line'>{
</span><span class='line'>    lock(A);
</span><span class='line'>    lock(B);
</span><span class='line'>    
</span><span class='line'>    ...
</span><span class='line'>    
</span><span class='line'>    unlock(B);
</span><span class='line'>    unlock(A);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>swap(X, Y); // 线程1
</span><span class='line'>swap(Y, X); // 线程2</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<h1>NSThread</h1>

<p>使用 NSThread 创建并操作线程在使用上相对简单一些，但是需要我们自己去管理线程的生命周期。所以总的来说易用性上不如 GCD，功能上不如 Operation Queues。</p>

<p><strong><em>创建并启动线程</em></strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSThread</span> <span class="o">*</span><span class="kr">thread</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSThread</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">run</span><span class="p">:)</span> <span class="nl">object</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="kr">thread</span> <span class="n">start</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong><em>线程通讯</em></strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelectorOnMainThread:withObject:waitUntilDone:modes:</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelectorOnMainThread:withObject:waitUntilDone:</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelector:onThread:withObject:waitUntilDone:modes:</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelector:onThread:withObject:waitUntilDone:</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// perform 方法只对拥有 RunLoop 的线程有效，如果创建的线程没有添加 RunLoop，perform 的 selector 将无法执行</span>
</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<h1>GCD（Grand Central Dispatch）</h1>

<p>GCD 是苹果为多核的并行计算提出的解决方案，它会自动地利用更多的 CPU 内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程）。同时它基于 C 语言，使用 Block 方式，使用起来更加方便灵活。</p>

<p><strong><em>最常用的使用方式</em></strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>     <span class="c1">// 异步耗时操作</span>
</span><span class='line'>     <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>          <span class="c1">// 由于 UIKit 中大部分类都不是线程安全的，所以需要在主队列中处理 UI</span>
</span><span class='line'>     <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>GCD 有 5个不同队列：主队列，3个不同优先级的全局队列，以及一个优先级更低的后台队列（用于 I/O），我们还可以自己创建队列。通常不建议给队列设置优先级，因为多任务在访问共享资源时，可能会造成优先级反转问题。</p></li>
<li><p>获取主队列：主队列是串行队列，所以比较适合处理共享资源、更新 UI 等事情</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_main_queue</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>获取不同优先级的全局队列：全局队列是并行队列，支持数百个线程执行</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_HIGH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_LOW</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>如果经常需要在后台队列上执行开销庞大的操作，可通过 dispatch_queue_create 函数创建新队列，它接收两个参数，第一个是标识符，可以在 Instruments 或 lldb 调试程序时查看队列名字，第二个参数用来表示创建的队列是串行还是并行，DISPATCH_QUEUE_SERIAL 或 NULL 表示串行，DISPATCH_QUEUE_CONCURRENT 表示并行。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">queueLabel</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;%@.%p.queue1&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="nb">self</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">([</span><span class="n">queueLabel</span> <span class="n">UTF8String</span><span class="p">],</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">([</span><span class="n">queueLabel</span> <span class="n">UTF8String</span><span class="p">],</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>创建任务并交给队列处理</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 异步任务</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 同步任务</span>
</span><span class='line'><span class="n">dispatch_sync</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>同步任务很容易造成死锁，主要发生在串行队列中，并且同步任务所在队列为当前队列</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// dispatch_sync 将任务加入到主队列后会阻塞主线程，该任务要等主线程中的其它任务执行完成后才能执行，但由于主线程已经被阻塞了，它还在等新任务执行完后才去执行其它任务，这时双方互相等待造成死锁。</span>
</span><span class='line'><span class="n">dispatch_sync</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 同上</span>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;queue1&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="p">...</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面例子会打印什么呢？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务1&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务2&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务3&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务4&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">while</span> <span class="p">(</span><span class="nb">YES</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>会先打印主线程中的 <code>任务4</code>，然后在主线程中执行 <code>while</code> 死循环，再打印新创建线程中的 <code>任务1</code>，<code>任务2</code> 是在主线程中执行，并且由于是同步操作，所以它会一直等待 <code>while</code> 结束才会执行，这时程序就卡死了。如果将 <code>任务2</code> 改成异步执行，那么 <code>任务3</code> 会先打印出来，但因为 <code>任务2</code> 是在主线程中，所以它还是会等待 <code>while</code> 结束，程序依旧会卡死。</p>

<ul>
<li>队列和线程的关系：队列可按照同步或异步的方式来组织并执行任务，同步异步的区别在于是否会阻塞当前线程，以及是否会开启新线程。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务1%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span> <span class="c1">// 在主线程中执行</span>
</span><span class='line'>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">serialQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;test.serialQueue&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">concurrentQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;test.concurrentQueue&quot;</span><span class="p">,</span><span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 同步执行的任务不管是位于串行队列还是并行队列，都是串行效果，它们都会在当前线程中执行（全局队列换成 serialQueue 或 concurrentQueue 结果是一样的）</span>
</span><span class='line'>    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务2%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 异步执行任务如果不是放在主队列中的话都会开启新的线程，如果任务位于串行队列，该队列中就算放入多个任务，也只会创建一个线程</span>
</span><span class='line'>    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">serialQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务3%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 异步执行的多个任务如果位于并行队列，会由操作系统决定要开启多少线程，有可能多个任务会共用一个线程。(全局队列换成 concurrentQueue 结果是一样的)</span>
</span><span class='line'>    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务4%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>NSTimer 在使用时会受 RunLoop 影响而导致延迟触发，当有更精准的计时需求时，可用 GCD 的计时器</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_source_t</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">dispatch_source_create</span><span class="p">(</span><span class="n">DISPATCH_SOURCE_TYPE_TIMER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</span><span class='line'><span class="n">dispatch_source_set_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">dispatch_walltime</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="c1">// 每秒触发一次</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_source_set_event_handler</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(...)</span> <span class="p">{</span>
</span><span class='line'>              <span class="n">dispatch_source_cancel</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span> <span class="c1">// 停止</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>      <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_resume</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span> <span class="c1">// 启动</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>dispatch_once 可以控制 Block 中的代码只被执行一次，通常用于创建单例，如果需要完整的单例，不被人 alloc 还需要进一步处理</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span> <span class="nf">sharedInstance</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">pred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">static</span> <span class="n">ClassName</span> <span class="o">*</span><span class="n">sharedObject</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pred</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">sharedObject</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">sharedObject</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>延迟处理，类似于 performSelector:withObject:afterDelay:，可指定时间和处理队列</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_after</span><span class="p">(</span><span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="mi">1</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">)),</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>当使用 foreach 遍历数组遇到效率问题时，可以考虑用 dispatch_apply 进行快速迭代，dispatch_apply 是 dispatch_sync 和 Dispatch Group 的关联 API，所以它会阻塞当前线程</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_apply</span><span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%zu&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span> <span class="c1">// 由于任务在并发队列中，所以 index 为乱序</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;done&quot;</span><span class="p">);</span> <span class="c1">// 由于当前线程被阻塞，所以迭代结束后，此句才会执行</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>iOS8 开始支持取消任务</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">serialQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;queue1&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">dispatch_block_t</span> <span class="n">firstBlock</span> <span class="o">=</span> <span class="n">dispatch_block_create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="kt">dispatch_block_t</span> <span class="n">secondBlock</span> <span class="o">=</span> <span class="n">dispatch_block_create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">serialQueue</span><span class="p">,</span> <span class="n">firstBlock</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">serialQueue</span><span class="p">,</span> <span class="n">secondBlock</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_block_cancel</span><span class="p">(</span><span class="n">secondBlock</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>多任务并发，都完成后触发另一个任务，可通过队列组实现，例如同时下载 2张图片，都下载完成后再将他们拼接起来</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 任务1</span>
</span><span class='line'><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 下载资源1</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 任务2</span>
</span><span class='line'><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 下载资源2</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 任务1 和任务2 都完成后会自动通知</span>
</span><span class='line'><span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 处理资源1和资源2</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>dispatch_barrier_async 在执行任务时会确保队列在此过程不会执行其它任务，可以在适当时候用来解决同步问题，它只在自己创建的队列上有这种作用，在全局并发队列和串行队列上，效果和 dispatch_sync 一样</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;queue1&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 在 dispatch_barrier_async 前面的任务执行结束后才执行，后面的任务等它执行完成后才会执行</span>
</span><span class='line'><span class="n">dispatch_barrier_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<ul>
<li>利用 dispatch_semaphore_t 信号量限制任务并发数，dispatch_semaphore_wait 函数会消耗一次这个可用数，如果可用数已满则开始等待，dispatch_semaphore_signal 函数每次执行都会将该可用计数加 1，以此来表明已经释放了资源，如果此刻有因为等待可用资源而被阻塞的任务，系统会从等待的队列中解锁一个任务来执行。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_semaphore_t</span> <span class="n">semaphore</span> <span class="o">=</span> <span class="n">dispatch_semaphore_create</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="c1">// 只有一个停车位</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">semaphore</span><span class="p">,</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">))))</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;不等了，开走&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;第一辆车来了，有位置直接停&quot;</span><span class="p">);</span> <span class="c1">// 1</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">semaphore</span><span class="p">,</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">))))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;不等了，开走&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;第二辆车,等到有位置后停车&quot;</span><span class="p">);</span> <span class="c1">// 3</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;第一辆车开走，这时第二辆车准备停车&quot;</span><span class="p">);</span> <span class="c1">// 2</span>
</span><span class='line'>    <span class="n">dispatch_semaphore_signal</span><span class="p">(</span><span class="n">semaphore</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">semaphore</span><span class="p">,</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">))))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;第三辆车不等了，开走&quot;</span><span class="p">);</span> <span class="c1">// 4</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;有位置，停车&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;第二辆车开走，第三辆车没有继续等&quot;</span><span class="p">);</span> <span class="c1">// 5</span>
</span><span class='line'>    <span class="n">dispatch_semaphore_signal</span><span class="p">(</span><span class="n">semaphore</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<h1>Operation Queues</h1>

<p>GCD 提供了更加底层的控制，而操作队列则在 GCD 之上实现了一些方便的功能，这些功能对于我们来说通常是最好最安全的选择，使用时需要将任务封装到一个 NSOperation 对象中，再将它添加到 NSOperationQueue，系统会将 NSOperationQueue 中的 NSOperation 取出并放到线程上执行。</p>

<ul>
<li>NSOperationQueue 默认是串行队列，可通过设置 maxConcurrentOperationCount 实现并发</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 获取主队列</span>
</span><span class='line'><span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">mainQueue</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSOperationQueue</span> <span class="n">mainQueue</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 创建队列</span>
</span><span class='line'><span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>NSOperation 不能够直接使用，可通过它的两个子类来封装任务，或者自定义 Operation

<ul>
<li>NSInvocationOperation：通过 SEL 方式添加任务</li>
<li>NSBlockOperation：通过 Block 方式添加任务</li>
<li>自定义 Operation：需要继承 NSOperation 类，并实现 main 方法
<br></li>
</ul>
</li>
<li>NSOperation 有一个非常实用的功能，可以添加和解除依赖。但要注意，不能相互依赖，否则会造成死锁，例如 A 依赖 B，B 依赖 A。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">operation1</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>   <span class="c1">// 下载资源1</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">operation2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 下载资源2</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">operation3</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 处理资源1和资源2</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">operation3</span> <span class="nl">addDependency</span><span class="p">:</span><span class="n">operation1</span><span class="p">];</span>      <span class="c1">// 任务三依赖任务一</span>
</span><span class='line'><span class="p">[</span><span class="n">operation3</span> <span class="nl">addDependency</span><span class="p">:</span><span class="n">operation2</span><span class="p">];</span>      <span class="c1">// 任务三依赖任务二</span>
</span><span class='line'>
</span><span class='line'><span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">mainQueue</span><span class="p">]</span> <span class="nl">addOperations</span><span class="p">:</span><span class="l">@[</span><span class="n">operation3</span><span class="p">,</span> <span class="n">operation2</span><span class="p">,</span> <span class="n">operation1</span><span class="l">]</span> <span class="nl">waitUntilFinished</span><span class="p">:</span><span class="nb">NO</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>在做多线程开发时，要合理的进行线程分配并且控制线程数量，为了追踪线程操作，每个线程还要起好名字。主线程主要用来做 UI 操作和数据处理，而日志记录，网络请求都可以安排在各自的线程中，为了检查 UI 操作是否在主线程中执行，可以 hook 掉 UIView 和 CALayer 的 <code>setNeedsDisplay</code> <code>setNeedsDisplayInRect:</code> <code>setNeedsLayout</code> 这三个方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 应用的生命周期]]></title>
    <link href="http://lijingcheng.github.io/blog/2015/03/28/iosying-yong-de-sheng-ming-zhou-qi/"/>
    <updated>2015-03-28T11:23:29+08:00</updated>
    <id>http://lijingcheng.github.io/blog/2015/03/28/iosying-yong-de-sheng-ming-zhou-qi</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/app-lifecycle.jpeg" width="160" height="160"  >
<strong>生命周期 - <em>程序的生命周期是指应用程序从启动到结束整个阶段的全过程.</em></strong> <br/>
<br>
点击应用图标打开程序，系统会首先通过 main 函数进行相关设置，然后通过 RunLoop 保持程序能够始终运行并监听处理分发事件，当没有事件发生时 RunLoop 便处于睡眠状态，节省资源。当发生事件后，RunLoop 将事件对象分发给相应视图处理。当用户按下 Home 键，应用会在进入后台后短暂运行，直到被系统挂起。</p>

<!-- more -->


<h1>main 函数</h1>

<p>main 函数是 app 的入口函数</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">UIApplicationMain</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">AppDelegate</span> <span class="k">class</span><span class="p">]));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<ul>
<li>在进入 main 函数之前，系统会由 dyld（the dynamic link editor）加载相关动态链接库，然后再初始化 runtime 环境，并由 runtime 触发 + load 方法，所以不要在 load 方法里执行耗时任务，否则会影响启动时间。</li>
<li>@autoreleasepool 用来管理主线程中标记为自动释放的对象。</li>
<li>UIApplicationMain 根据传入参数以及 info.plist 文件来初始化 app

<ul>
<li>argc 和 argv 参数在 iOS 应用中用不到</li>
<li>第三个参数为 app 的首要类名，用来监听并管理应用的生命周期，默认使用 UIApplication</li>
<li>最后一个参数为 app 首要类的代理类，它负责实际处理 UIApplication 监听到的应用程序生命周期事件，具体参考 UIApplicationDelegate</li>
<li>main 函数会在初始化 app 后启动主线程及 RunLoop</li>
</ul>
</li>
</ul>


<h1>RunLoop</h1>

<p>RunLoop 能够保持程序始终运行并监听处理分发事件，当没有事件发生时进入休眠状态，有事件发生时系统会将接收到的事件放在一个队列里，然后唤醒 RunLoop 依次处理事件，使用队列不仅可以解决线程同步问题也促使我们要把更新 UI 的代码放在主线程中运行，以免由于多个线程抢占资源产生奇怪的问题。RunLoop 可以接收的事件来自两种不同的来源，分别是输入源和定时源，输入源传递异步事件，事件通常来自于其他线程或程序，如一些 UI 事件等。定时源则传递同步事件，发生在特定时间或者重复的时间间隔，如 NSTimer。RunLoop 会在接收到事件时创建新的自动释放池，并在处理完事件后释放它。</p>

<p>每个线程都有自己的 RunLoop, 主线程是默认开启的，子线程需要手动开启，并且在开启后必须至少添加一个事件源，否则 RunLoop 在启动后会立即结束。那么什么情况下需要我们在子线程中开启并使用 RunLoop 呢？</p>

<ul>
<li>在线程中需要持续监测某个事件。例如使用 NSURLConnection 异步请求数据，如果没有开启 RunLoop，会因为子线程的结束导致相关 delegate 方法不会被触发。</li>
<li>线程间需要持续交互，例如当多个线程之间产生同步问题时，可以根据情况考虑将多个线程定义成多个事件源，然后让它们运行在同一线程的 RunLoop 下。</li>
<li>使用 NSTimer 或 performSelector 系列方法。

<ul>
<li>performSelecter:afterDelay: 会创建 timer 并添加到当前线程的 RunLoop 中，如果当前线程没有 RunLoop，此方法失效。</li>
<li>performSelector:onThread: 会创建 timer 并添加到指定线程的 RunLoop 中，如果指定线程没有 RunLoop，此方法失效。</li>
</ul>
</li>
</ul>


<p><br/>
不同的事件源会运行在 RunLoop 的不同模式中，它们只有在相匹配的情况下才会被处理。这种工作方式利于 RunLoop 更好的管理和处理事件，使它们之间不相互影响。</p>

<ul>
<li>NSTimer 运行在 NSDefaultRunLoopMode 模式下。</li>
<li>列表滚动事件运行在 UITrackingRunLoopMode 模式下。</li>
<li>NSRunLoopCommonModes 包含 NSDefaultRunLoopMode 和 UITrackingRunLoopMode。</li>
</ul>


<p>我们在 Cell 上放置一个 timer，然后在滚动表格时会发现 timer 没有正常执行，要解决这个问题，只要将 timer 运行在 NSRunLoopCommonModes 模式下，便可以在表格静止以及滚动时都能够正常运行。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">addTimer</span><span class="p">:</span><span class="n">timer</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">NSRunLoopCommonModes</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是 NSTimer 并不是以子线程的方式运行，它只是在 RunLoop 里注册了一下，RunLoop 会根据 timer 的设置情况去检测并触发，所以任务在执行过程中一旦出现延迟，那么会丢失执行次数，如果对精确度有要求的话，可以使用 dispatch_time，GCD 不受 RunLoop 影响。</p>

<blockquote><p>关于 RunLoop 的具体使用方法详见<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">官方文档</a></p></blockquote>

<p><br/></p>

<h1>事件传递&amp;事件响应</h1>

<p>当发生触摸操作后，系统会将这一事件封装成 UIEvent 对象并放到由 UIApplication 管理的事件队列中，再由 RunLoop 接收事件并传递给触摸点所在的视图，该视图即为 &ldquo;hit-test视图"，而查找这一视图的过程就叫做 "hit-testing"。hit-testing 过程大致如下:</p>

<ul>
<li>RunLoop 将接收到的事件分发给 UIWindow。</li>
<li>UIWindow 通过 hitTest:withEvent: 方法在视图树中递归查找触摸点所在的视图。</li>
<li>当前视图通过 hitTest 方法调用 pointInside:withEvent: 来判定触摸点是否在当前视图，如果不在 hitTest 返回 nil，在的话则从当前视图的 subViews 末尾向前遍历，依次向每个 subView 发送 hitTest 消息，以此规则一直到某个 subView 不再返回 nil 或遍历完成。</li>
<li>最终由最后一个遍历到并且不返回 nil 的视图作为 hit-test视图。</li>
</ul>


<p>在这过程中如果视图不具备响应事件的条件(userInteractionEnabled 或 enabled 为 NO，hidden=YES 或 alpha=0)，那么 hitTest 就不会调用 pointInside 方法，会直接返回 nil，该视图的子视图也就不会被遍历到，如果我们想改变这一点，或者有别的需求需要改变事件传递的规则，那么需要自定义父视图并重写以下方法来控制子视图。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nf">hitTest:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">point</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">pointInside:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">point</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><br/>
如果想在某种情况下不响应事件，可以在适当时调用 UIApplication 的以下方法停止和恢复事件接收和分发。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">beginIgnoringInteractionEvents</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">endIgnoringInteractionEvents</span>
</span></code></pre></td></tr></table></div></figure>


<p><br/>
如果 hit-test 视图不处理收到的事件（没有重写 touches 方法，或者只是在 touches 方法里调用 [super touches..]），则通过响应者链机制寻找其它响应者来处理。</p>

<p>响应链由一系列链接在一起的响应者组成。如果一个响应者不能处理事件，则会将事件沿着响应链传到下一响应者。下一响应者有可能是它的父视图也可能是它所在的 ViewController，系统会以此类推一直传递到 UIApplication。如果整个过程都没有响应者响应事件，该事件就会被丢弃。否则事件便会停止传递交由响应者处理。</p>

<p><br/>
在开发过程中，有时我们不得不定义一个很小的按钮，为了避免发生用户点不到按钮的事情发生，可以利用上面的知识，扩大按钮的有效范围，只要触碰到按钮附近就使按钮响应事件。解决办法就是自定义继承 UIButton 的视图，并重写 pointInside:withEvent 方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">pointInside:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">point</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">CGRect</span> <span class="n">bounds</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">widthDelta</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="mf">44.0</span> <span class="o">-</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">heightDelta</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="mf">44.0</span> <span class="o">-</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectInset</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">widthDelta</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">heightDelta</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">CGRectContainsPoint</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">point</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><br/>
当子视图添加到父视图后，其响应事件的范围就是父视图的 bounds，如果部分界面超出了这个范围，则超出部分无法响应事件，未超出部分仍然可以响应事件，为了使超出父视图范围的子视图也能响应事件，需要实现主视图的 <code>- hitTest:withEvent:</code> 方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nf">hitTest:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">point</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">UIView</span> <span class="o">*</span><span class="n">view</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">hitTest</span><span class="p">:</span><span class="n">point</span> <span class="nl">withEvent</span><span class="p">:</span><span class="n">event</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">view</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="bp">UIView</span> <span class="o">*</span><span class="n">subView</span> <span class="k">in</span> <span class="nb">self</span><span class="p">.</span><span class="n">subviews</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="bp">CGPoint</span> <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">subView</span> <span class="nl">convertPoint</span><span class="p">:</span><span class="n">point</span> <span class="nl">fromView</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">CGRectContainsPoint</span><span class="p">(</span><span class="n">subView</span><span class="p">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">view</span> <span class="o">=</span> <span class="n">subView</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">view</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><br/></p>

<h1>前后台切换</h1>

<p>在程序进入后台后仍然能够在短时间里执行一些代码，然后便进入挂起状态，程序在挂起后仍然会驻留在内存中，但是不能执行代码，直到 iOS 系统内存降低发出警告后才会把相对耗内存的挂起程序清除掉。</p>

<p>当程序在前后台切换时，系统会调用 UIApplicationDelegate 的相关代理方法并发送通知，我们可以在不同情况下做出不同处理，例如在进入后台时暂停某些操作或存储某些数据，当恢复到前台时再恢复之前的暂停操作或读取之前存储的数据。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在 Git 环境下维护多个 SSH Keys]]></title>
    <link href="http://lijingcheng.github.io/blog/2015/03/01/zai-githuan-jing-xia-wei-hu-duo-ge-ssh-keys/"/>
    <updated>2015-03-01T18:11:42+08:00</updated>
    <id>http://lijingcheng.github.io/blog/2015/03/01/zai-githuan-jing-xia-wei-hu-duo-ge-ssh-keys</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/ssh_key.jpg" width="220" height="220"  >
 SSH Key - 通过 SSH 密钥登录服务器，可以避免密码在网络中传输，也就保证了登录过程的安全，也不会因此受到中间人攻击，如果在 SSH 密钥登录基础上再加上密码短语 （passphrase）的使用，安全性便会再次提高。</p>

<p><br/></p>

<!-- more -->


<p>作为一个程序猿，我们经常会往公司的 Git 服务器上提交代码，还有很多猿在 GitHub 上也有自己的开源项目，不管是公司的服务器还是 GitHub 服务器都会在你提交代码时通过维护在服务器上的公钥进行验证，如果你希望能够以不同身份向不同服务器提交代码，那么你需要在机器上维护多个 SSH Key，并且将不同的公钥添加到不同的服务器中。</p>

<p>下面介绍下在已经拥有一个用于公司服务器的 SSH Key 后，如何再添加一个用于 GitHub 的 SSH Key。</p>

<p>首先进入 .ssh 目录</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd ~/.ssh</span></code></pre></td></tr></table></div></figure>


<p>创建用于 GitHub 的 SSH Key，根据提示将名字设置为 id_rsa_github</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh-keygen -t rsa -C "注册 GitHub 时用的 Email"</span></code></pre></td></tr></table></div></figure>


<p>因为 Git 默认只读取 id_rsa，为了让 SSH 识别新的私钥，需将 id_rsa_github 添加到 SSH Agent 中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh-add id_rsa_github</span></code></pre></td></tr></table></div></figure>


<p>将 id_rsa_github.pub 中的公钥复制到 GitHub 帐户中，并为 GitHub 项目指定提交代码时使用哪个用户</p>

<pre><code>- 通过 SourceTree 设置：项目 -&gt; 设置 -&gt; 高级 -&gt; 直接修改用户名和邮箱
- 进入项目根目录，然后打开 .git 目录下的 config 文件，修改 [user] 部分
</code></pre>

<p>如果 .ssh 目录下没有 config 文件，便新增一个</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>touch config</span></code></pre></td></tr></table></div></figure>


<p>配置 config 文件，指明服务器及所使用的密钥</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Host github.com
</span><span class='line'>IdentityFile ~/.ssh/id_rsa_github
</span><span class='line'>
</span><span class='line'>Host gitlab.xxx.com
</span><span class='line'>IdentityFile ~/.ssh/id_rsa</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<blockquote><p>如果你使用 SourceTree 的话，也可以在添加 GitHub 帐户时直接生成密钥，它会帮你配置好一切并上传，这样就省去了上面一切操作步骤，但仅支持添加 GitHub 和 BitBucket 账号。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 CocoaPods 做依赖管理]]></title>
    <link href="http://lijingcheng.github.io/blog/2015/02/11/yong-cocoapodswei-iosxiang-mu-zuo-yi-lai-guan-li/"/>
    <updated>2015-02-11T15:10:58+08:00</updated>
    <id>http://lijingcheng.github.io/blog/2015/02/11/yong-cocoapodswei-iosxiang-mu-zuo-yi-lai-guan-li</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/cocoapods.png" width="190" height="190"  >
<strong><a href="http://www.cocoapods.org">CocoaPods</a> - <em>Get on with building your app, not duplicating code.</em></strong> <br/>
<br>
可以为 Cocoa 和 Swift 项目使用的第三方类库和我们自己的私有类库提供依赖管理，我们只需要告诉它要使用的类库名称和版本，然后再执行一条命令，它就会自动将这个类库的源码从 GitHub 上下载到本地，并且为工程设置好相应的系统依赖和编译项。使用 CocoaPods 可以大大节省我们在设置和更新类库时所花的时间。</p>

<!-- more -->


<p><br/></p>

<h1>准备工作</h1>

<p>由于 CocoaPods 是用 Ruby 写的，并且主要用于管理 GitHub 上的第三方类库，所以在安装前需要有 Ruby 环境和 Git 环境。Git 环境可以通过下载 Xcode 中的 Command Line Tools 建立。Ruby 环境可以使用 Mac 系统默认提供的版本，也可以通过以下命令将它更新至最新版。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo gem update –system</span></code></pre></td></tr></table></div></figure>


<p>
<br/>
为了提高下载速度，还需要将 Ruby 的源更改为 ruby-china</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem sources -a https://gems.ruby-china.org/  (添加)
</span><span class='line'>gem sources -r https://rubygems.org/  (删除)
</span><span class='line'>gem sources -l  (检查一下)</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><br/></p>

<h1>安装并使用 CocoaPods</h1>

<ul>
<li>安装 CocoaPods</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo gem install cocoapods (更新命令也是这个)
</span><span class='line'>
</span><span class='line'>// 新版 OSX 安装时会报下面这个错，可另外指定 CocoaPods 的安装目录
</span><span class='line'>ERROR:  While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/xcodeproj
</span><span class='line'>
</span><span class='line'>sudo gem install -n /usr/local/bin cocoapods
</span><span class='line'>或者安装 pre release 版本
</span><span class='line'>sudo gem install -n /usr/local/bin cocoapods --pre</span></code></pre></td></tr></table></div></figure>


<ul>
<li>下载 CocoaPods 维护的所有 podspec 文件到"~/.cocoapods/repos/master/Specs"</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod setup</span></code></pre></td></tr></table></div></figure>


<blockquote><p>更新 spec 也用这个命令，podspec 文件主要用来描述依赖库的名称、版本、作者、下载地址等信息。通过 CocoaPods 下载第三方类库，其实就是根据我们指定的类库名称找到相关的 podspec，然后再根据 podspec 文件中指定的地址去下载。</p></blockquote>

<ul>
<li>查看 CocoaPods 管理的依赖库信息</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod search 依赖库的名字</span></code></pre></td></tr></table></div></figure>


<ul>
<li>新建 Podfile 文件，此文件用于配置项目所需要使用的依赖库</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd "项目根目录"
</span><span class='line'>pod init</span></code></pre></td></tr></table></div></figure>


<ul>
<li>打开 Podfile 文件，按下面内容配置依赖关系，Podfile 的更详细配置方法可参照<a href="http://guides.cocoapods.org/syntax/podfile.html">官方文档</a></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source 'https://github.com/CocoaPods/Specs.git'
</span><span class='line'>
</span><span class='line'>platform :ios, '7.0'
</span><span class='line'>inhibit_all_warnings!
</span><span class='line'>
</span><span class='line'>pod 'AFNetworking', '2.5.1' </span></code></pre></td></tr></table></div></figure>


<blockquote><p>上面内容的意思是，specs 文件由 CocoaPods 提供，项目需要使用支持 ios7.0 及以上的依赖库，并且为主 target 配置了 2.5.1 版本的 AFNetworking，并忽略依赖库中的所有警告。依赖库的版本号建议明确指定，这样可以避免更新依赖库后对现有工程造成影响，而且可以保证团队所有开发人员使用的版本一致。</p></blockquote>

<p>如果你的项目有多个 target，那么需要按下面的方式配置 pod，否则依赖关系只能作用于主 target。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#Tests target 不仅使用主 target 的依赖库还需要添加自己的
</span><span class='line'>target 'Tests' do
</span><span class='line'>  pod "Tests 需要的依赖库"
</span><span class='line'>end
</span><span class='line'>或
</span><span class='line'>#Tests target 不需要主 target 的依赖库
</span><span class='line'>target 'Tests', :exclusive =&gt; true do
</span><span class='line'>  pod "Tests 需要的依赖库"
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<ul>
<li>根据 Podfile 下载安装依赖库</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod install (添加或删除依赖库后也是通过此命令更新)</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>CocoaPods 会先更新相关 podspec 文件，然后自动为项目工程设置好相应的系统依赖和编译参数，当依赖库安装完成后，打开项目根目录，会发现多了以下文件及文件夹</strong></p>

<ol>
<li>&ldquo;.xcworkspace"，以后必须通过此 workspace 打开项目。</li>
<li>&ldquo;Pods"，CocoaPods 将 Profile 中配置的所有依赖库都下载到这里，并且将所有依赖库打包成单独的静态库供主项目使用。</li>
<li>&ldquo;Podfile.lock"，用于保存已经安装的依赖库版本信息。如果在配置依赖库时没有明确指定版本，那么必须将此文件加入到版本控制中，否则有可能造成团队开发中不同成员使用的依赖库版本不一致。</li>
</ol>
</blockquote>

<ul>
<li>查看所下载的依赖库是否有新版本</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod outdated</span></code></pre></td></tr></table></div></figure>


<ul>
<li>下载新版本（1.0版本前默认会更新本地 podspec 仓库）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod update</span></code></pre></td></tr></table></div></figure>


<ul>
<li>下载新版本，且不更新本地 podspec 仓库（速度会快很多）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod update --no-repo-update</span></code></pre></td></tr></table></div></figure>


<ul>
<li>将 CocoaPods 从项目中移除，并还原其对 Xcode 的配置修改（1.0 版本开始支持，以前需要用第三方提供的方式）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod deintegrate</span></code></pre></td></tr></table></div></figure>


<p>PS: 如果你使用的是 CocoaPods 1.0+，那么你可以下载 CocoaPods app 试一下，可以省去一些命令操作，并且在修改 Podfile 文件时，会有代码提示。</p>

<p><br/></p>

<h1>让自己的开源项目支持 CocoaPods</h1>

<h4>通过 CocoaPods 创建项目会让整个事情变的简单一些</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod lib create FMDBHelper</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>创建完成后项目根目录会包含以下文件及文件夹</strong></p>

<ol>
<li>&ldquo;.travis.yml"，通过 travis-ci 做持续集成要用到的配置文件，一般情况下使用默认配置就可以，如果需要使用持续集成服务，还需要以 GitHub 帐号登录 <a href="https://travis-ci.org">travis-ci</a>，并打开对应项目开关。</li>
<li>&ldquo;.gitignore"，建议将 Pods 目录也加入到忽略范围</li>
<li>&ldquo;LICENSE"，默认为 MIT</li>
<li>&ldquo;FMDBHelper.podspec"，通过 Cocoapods 下载项目时要用到的项目配置文件。</li>
<li>&ldquo;README.md"，通过 markdown 语法编写此文件，用于在 GitHub 上显示项目介绍。</li>
<li>&ldquo;Pod"，将自己的开源代码和资源文件放到这里</li>
<li>&ldquo;Example"，demo 工程，包含测试用的 target。</li>
</ol>
</blockquote>

<h4>在 demo 工程中开发并测试</h4>

<ul>
<li>将源代码和资源文件分别放到 Pod/Classes 和 Pod/Assets 目录下</li>
<li>用 pod install 命令为 demo 工程安装依赖库，以后只要新增依赖库的代码或资源文件都需要更新</li>
<li>开发测试完成后还需要修改 podspec 文件</li>
</ul>


<h4>将 podspec 发布到 CocoaPods 的 Git 库中</h4>

<ul>
<li>向 CocoaPods 注册你的信息，需要输入邮箱(与 podspec 中写的一致)和名字，稍后还需要验证 email</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod trunk register bj_lijingcheng@163.com "lijingcheng"</span></code></pre></td></tr></table></div></figure>


<ul>
<li>登录 GitHub，release 一版项目并打上标签，标签要与 podspec 中定义的一致</li>
<li>检查 spec 文件是否合格</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod spec lint FMDBHelper.podspec</span></code></pre></td></tr></table></div></figure>


<ul>
<li>检查并发布 spec 文件，以后需要升级也是用这个命令</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod trunk push FMDBHelper.podspec</span></code></pre></td></tr></table></div></figure>


<ul>
<li>更新本地 spec</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod setup (稍后便可以在 ~/.cocoapods/repos/master/Specs 下看到你的开源项目了)</span></code></pre></td></tr></table></div></figure>


<p><br/></p>

<h1>通过 CocoaPods 安装私有库</h1>

<p>可以按<a href="https://guides.cocoapods.org/making/private-cocoapods.html">官方指导</a>来做，大致步骤与在 GitHub 上维护开源项目相似，区别如下：</p>

<ul>
<li>需要通过 Git 建立自己的 spec 仓库，并在 Podfile 文件中填加 source</li>
<li>通过 pod repo add repo_name source_url 在 ~/.cocoapods/repos/ 目录下新建自己的 spec 仓库</li>
<li>通过 pod repo push 命令将已经写好的 podspec 文件填加到 spec 仓库中</li>
<li>在 Podfile 中可直接通过 pod repo_name 安装私有库</li>
<li>以后私有库新增版本后需要打 tag 并修改 podspec 文件中的 version，然后再次更新 spec 仓库</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GitHub Pages + Octopress 搭博客]]></title>
    <link href="http://lijingcheng.github.io/blog/2015/01/04/zai-macxia-tong-guo-github-pages-plus-octopressda-jian-bo-ke/"/>
    <updated>2015-01-04T14:51:02+08:00</updated>
    <id>http://lijingcheng.github.io/blog/2015/01/04/zai-macxia-tong-guo-github-pages-plus-octopressda-jian-bo-ke</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/github-octopress.png" width="200" height="200"  >
<strong><a href="https://pages.github.com">Github Pages</a> - <em>Websites for you and your projects.</em></strong> <br/>
可用来搭建静态网站，提供免费的域名、空间、无限流量，并且在世界各地都有较好的访问速度。不过网站也会轻易被人 clone，如果在意的话可以付费给 GitHub，然后将版本库建成私有的。
<br/><br/>
<strong><a href="http://octopress.org">Octopress</a> - <em>A blogging framework for hackers.</em></strong><br/>
开源的静态博客系统，可用来为我们的静态网站提供所需的 HTML。</p>

<!-- more -->


<p><br/></p>

<h1>准备工作</h1>

<ul>
<li>需要有 Git 环境，最好为 GitHub 另外维护一个 SSH Key</li>
<li>在 GitHub 上新建名为 yourname.github.io 的版本库，之后可通过 yourname.github.io 域名来访问博客，如果你有自己的域名，可通过配置 Octopress 的 CNAME 文件进行关联</li>
<li>需要有 1.9.3 及以上版本的 ruby 环境。(通过 ruby &ndash;version 查看，如需升级可用 rvm 或 rbenv)</li>
<li>更改 ruby 的源，可提高下载速度</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem sources -a https://gems.ruby-china.org/  (添加)
</span><span class='line'>gem sources -r https://rubygems.org/  (删除)
</span><span class='line'>gem sources -l  (检查一下)</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><br/></p>

<h1>Octopress 环境搭建</h1>

<ul>
<li>安装 Octopress</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone git://github.com/imathis/octopress.git octopress</span></code></pre></td></tr></table></div></figure>


<ul>
<li>clone 完成后 cd octopress，然后安装所需依赖</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo gem install bundler 
</span><span class='line'>rbenv rehash 
</span><span class='line'>bundle install</span></code></pre></td></tr></table></div></figure>


<ul>
<li>安装默认模板</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake install</span></code></pre></td></tr></table></div></figure>


<ul>
<li>关联 GitHub Pages</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake setup_github_pages
</span><span class='line'>git@github.com:yourname/yourname.github.io.git</span></code></pre></td></tr></table></div></figure>


<ul>
<li>配置 <a href="http://octopress.org/docs/configuring">Octopress</a>，建议同时删除 HTML 和 CSS 中用不到的东西，可提高访问速度</li>
</ul>


<p><br/></p>

<h1>写博客并发布</h1>

<ul>
<li>新建文章（博客存储为 markdown 文件，位于 \octopress\source\_posts 目录下）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_post["new_blog_title"]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>生成静态网站</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake generate</span></code></pre></td></tr></table></div></figure>


<ul>
<li>通过 <a href="http://localhost:4000">http://localhost:4000</a> 预览静态网站，之后修改 markdown 后直接刷新即可</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake preview</span></code></pre></td></tr></table></div></figure>


<ul>
<li>部署并将 Octopress 生成的 HTML 等文件提交到 master 分支</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>


<blockquote><p>如果提交失败，提示让先 pull 文件，但是本地文件已经是最新的，可按下面方式解决：进入 _deploy 目录，执行 git reset –hard origin/master 将本地状态回退到和远程一样，然后回到根目录下重新 generate 并 deploy。</p></blockquote>

<ul>
<li>将 Octopress 修改过的 markdown 等资源文件提交到 source 分支</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add .
</span><span class='line'>git commit -m ‘your commit message’
</span><span class='line'>git push origin source</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<h2>如果更换了电脑或希望多台电脑能够写博客</h2>

<ul>
<li>首先需要下载 source 分支到你的电脑上</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone -b source git@github.com:lijingcheng/lijingcheng.github.io.git</span></code></pre></td></tr></table></div></figure>


<ul>
<li>然后进入下载目录</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd lijingcheng.github.io</span></code></pre></td></tr></table></div></figure>


<ul>
<li>下载 master 分支到 _deploy 目录</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone -b master git@github.com:lijingcheng/lijingcheng.github.io.git _deploy</span></code></pre></td></tr></table></div></figure>


<ul>
<li>生成网站并部署</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake generate
</span><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>
