<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[风行的博客]]></title>
  <link href="https://lijingcheng.github.io/atom.xml" rel="self"/>
  <link href="https://lijingcheng.github.io/"/>
  <updated>2019-10-16T16:11:01+08:00</updated>
  <id>https://lijingcheng.github.io/</id>
  <author>
    <name><![CDATA[风行]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS 应用的启动任务设计]]></title>
    <link href="https://lijingcheng.github.io/blog/2019/08/29/ios-app-start/"/>
    <updated>2019-08-29T15:18:55+08:00</updated>
    <id>https://lijingcheng.github.io/blog/2019/08/29/ios-app-start</id>
    <content type="html"><![CDATA[<p>从点击 app 图标到看到首页内容就算是一次启动过程，在这个短则一两秒的过程中 app 要做的事情却有很多，本文主要介绍如何管理这些任务的执行方式和优先级问题。</p>

<!-- more -->


<p>下面列出 app 启动过程中会去执行的一些主要任务：</p>

<ul>
<li>设置 app UI 样式</li>
<li>开启定位、埋点、网络状态、通知监听等服务</li>
<li>初始化一些第三方服务</li>
<li>如果是通过点击推送通知进入的 app 还会去存储相关数据用于在进入首页后跳转页面或弹框</li>
<li>访问一些接口并处理返回结果</li>
</ul>


<p>上面列出的大部分任务都不需要我们主动去管理，只要在处理过程中注意不要影响启动速度就可以了，需要我们去管理的任务主要是对于一些接口返回数据的处理，像 <code>升级检查</code>、<code>换肤</code>、<code>弹窗广告</code> 这类接口在拿到返回数据后不能够马上处理，而是需要先保存数据然后等待首页展示出来后再做 UI 效果处理，并且这些任务通常还需要考虑优先级问题，例如当需要展示升级提示时就不应该再展示弹窗广告。</p>

<p>我目前的处理方案是基于 RxSwift 响应式编程框架实现，每项任务都是可以被订阅的，订阅者可以监听任务状态并作出响应，每项任务的最初状态是<code>unknown</code>未知的，也就是接口还未返回数据时的状态，当接口返回数据后，再根据情况将状态改为<code>need</code>或<code>noneed</code>，也就是需要处理或不需要处理，我们可以让接口调用处只将关注点放在改变任务状态上，不同状态时该如何处理是由该任务的管理类决定，具体什么时候以及是否需要处理则是由该任务的订阅者去决定。</p>

<p>下面以<code>检查升级</code>任务为主线看下具体代码实现，首先在 app 启动后发起异步接口调用，并根据返回数据修改任务状态，此时不用考虑 app 是否已经进入首页，以及如果弹框提示用户等功能</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">NetworkService</span><span class="p">.</span><span class="kr">get</span><span class="p">(</span><span class="s">&quot;xxx.api&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="nb">self</span><span class="p">]</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span> <span class="k">in</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">...</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Task</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">upgrade</span><span class="p">.</span><span class="n">accept</span><span class="p">(.</span><span class="n">need</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Task</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">upgrade</span><span class="p">.</span><span class="n">accept</span><span class="p">(.</span><span class="n">noneed</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当 app 进入首页后，会在 viewDidAppear 方法中发出 Notification 用来触发任务订阅管理功能</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">NotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">rx</span><span class="p">.</span><span class="n">notification</span><span class="p">(</span><span class="n">Notification</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">appDidAppear</span><span class="p">).</span><span class="n">subscribe</span><span class="p">(</span><span class="nl">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="n">notification</span> <span class="k">in</span>
</span><span class='line'>    <span class="n">Task</span><span class="p">.</span><span class="n">shared</span><span class="p">.</span><span class="n">subscribe</span><span class="p">()</span>
</span><span class='line'><span class="p">}).</span><span class="n">disposed</span><span class="p">(</span><span class="nl">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后我们再来看下 Task 的具体实现，在下面例子中列出了七个需要处理的任务，其中<code>换肤</code>、<code>小红点</code>、<code>过期提醒</code>这三个任务是进入首页后就可以直接执行，不用考虑优先级问题，而<code>升级提示</code>、<code>切换城市</code>、<code>弹窗广告</code>、<code>推送跳转</code>这四个任务之间有优先级关系，需要特殊处理一下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">struct</span> <span class="n">Task</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="k">let</span> <span class="n">shared</span> <span class="o">=</span> <span class="n">Task</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">private</span> <span class="k">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">enum</span> <span class="nl">Status</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">unknown</span><span class="p">,</span> <span class="n">need</span><span class="p">,</span> <span class="n">noneed</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// BehaviorRelay 类型的任务在被订阅后，订阅者会先收到最近一次的事件或初始事件</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">upgrade</span> <span class="o">=</span> <span class="n">BehaviorRelay</span><span class="p">(</span><span class="nl">value</span><span class="p">:</span> <span class="n">Status</span><span class="p">.</span><span class="n">unknown</span><span class="p">)</span> <span class="c1">// 升级弹框</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">switchCity</span> <span class="o">=</span> <span class="n">BehaviorRelay</span><span class="p">(</span><span class="nl">value</span><span class="p">:</span> <span class="n">Status</span><span class="p">.</span><span class="n">unknown</span><span class="p">)</span> <span class="c1">// 切换城市弹框</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">popAdvertise</span> <span class="o">=</span> <span class="n">BehaviorRelay</span><span class="p">(</span><span class="nl">value</span><span class="p">:</span> <span class="n">Status</span><span class="p">.</span><span class="n">unknown</span><span class="p">)</span> <span class="c1">// 弹窗广告</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">apns</span> <span class="o">=</span> <span class="n">BehaviorRelay</span><span class="p">(</span><span class="nl">value</span><span class="p">:</span> <span class="n">Status</span><span class="p">.</span><span class="n">unknown</span><span class="p">)</span> <span class="c1">// 推送跳转</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">skin</span> <span class="o">=</span> <span class="n">BehaviorRelay</span><span class="p">(</span><span class="nl">value</span><span class="p">:</span> <span class="n">Status</span><span class="p">.</span><span class="n">unknown</span><span class="p">)</span> <span class="c1">// 换肤</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">trackPoint</span> <span class="o">=</span> <span class="n">BehaviorRelay</span><span class="p">(</span><span class="nl">value</span><span class="p">:</span> <span class="n">Status</span><span class="p">.</span><span class="n">unknown</span><span class="p">)</span> <span class="c1">// 用于 tabBarItem 等地方的小红点提醒</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">remind</span> <span class="o">=</span> <span class="n">BehaviorRelay</span><span class="p">(</span><span class="nl">value</span><span class="p">:</span> <span class="n">Status</span><span class="p">.</span><span class="n">unknown</span><span class="p">)</span> <span class="c1">// 以气泡视图形式展示的过期提醒</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">private</span> <span class="k">let</span> <span class="n">disposeBag</span> <span class="o">=</span> <span class="n">DisposeBag</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">func</span> <span class="n">subscribe</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 升级弹框的优先级最高，不管当前在干什么都会直接弹框</span>
</span><span class='line'>        <span class="n">upgrade</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="nl">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="n">status</span> <span class="k">in</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="p">.</span><span class="n">need</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">NotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="bp">NSNotification</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">hidePopAdvertise</span><span class="p">,</span> <span class="nl">object</span><span class="p">:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>                <span class="c1">// 取消切换城市等弹框，显示升级提示弹框</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}).</span><span class="n">disposed</span><span class="p">(</span><span class="nl">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 切换城市弹框优先级仅次于升级提示</span>
</span><span class='line'>        <span class="n">switchCity</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="nl">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="n">status</span> <span class="k">in</span>
</span><span class='line'>            <span class="n">guard</span> <span class="nb">self</span><span class="p">.</span><span class="n">upgrade</span><span class="p">.</span><span class="n">value</span> <span class="o">!=</span> <span class="p">.</span><span class="n">need</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="p">.</span><span class="n">need</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">NotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="bp">NSNotification</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">hidePopAdvertise</span><span class="p">,</span> <span class="nl">object</span><span class="p">:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>                <span class="c1">// 显示切换城市弹框</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}).</span><span class="n">disposed</span><span class="p">(</span><span class="nl">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 弹窗广告优先级次于升级提示和切换城市</span>
</span><span class='line'>        <span class="n">popAdvertise</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="nl">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="n">status</span> <span class="k">in</span>
</span><span class='line'>            <span class="n">guard</span> <span class="nb">self</span><span class="p">.</span><span class="n">upgrade</span><span class="p">.</span><span class="n">value</span> <span class="o">!=</span> <span class="p">.</span><span class="n">need</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">switchCity</span><span class="p">.</span><span class="n">value</span> <span class="o">!=</span> <span class="p">.</span><span class="n">need</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="p">.</span><span class="n">need</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">NotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="bp">NSNotification</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">showPopAdvertise</span><span class="p">,</span> <span class="nl">object</span><span class="p">:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}).</span><span class="n">disposed</span><span class="p">(</span><span class="nl">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 推送跳转优先级在这个例子里排最后</span>
</span><span class='line'>        <span class="n">apns</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="nl">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="n">status</span> <span class="k">in</span>
</span><span class='line'>            <span class="c1">// 当需要考虑优先级的任务非常多时，下面的 guard 语句就会显得比较难看，并且其他任务的处理方式也会变得复杂，所以目前实现方式更适用于中小项目</span>
</span><span class='line'>            <span class="n">guard</span> <span class="nb">self</span><span class="p">.</span><span class="n">upgrade</span><span class="p">.</span><span class="n">value</span> <span class="o">!=</span> <span class="p">.</span><span class="n">need</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">switchCity</span><span class="p">.</span><span class="n">value</span> <span class="o">!=</span> <span class="p">.</span><span class="n">need</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">popAdvertise</span><span class="p">.</span><span class="n">value</span> <span class="o">!=</span> <span class="p">.</span><span class="n">need</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="p">.</span><span class="n">need</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">NotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="bp">NSNotification</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">apns</span><span class="p">,</span> <span class="nl">object</span><span class="p">:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}).</span><span class="n">disposed</span><span class="p">(</span><span class="nl">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 需要换肤时直接通知相关服务</span>
</span><span class='line'>        <span class="n">skin</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="nl">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="n">status</span> <span class="k">in</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="p">.</span><span class="n">need</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">NotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="bp">NSNotification</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">skin</span><span class="p">,</span> <span class="nl">object</span><span class="p">:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}).</span><span class="n">disposed</span><span class="p">(</span><span class="nl">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 需要展示小红点提醒时直接通知相关服务</span>
</span><span class='line'>        <span class="n">trackPoint</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="nl">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="n">status</span> <span class="k">in</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="p">.</span><span class="n">need</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">NotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="bp">NSNotification</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">trackPoint</span><span class="p">,</span> <span class="nl">object</span><span class="p">:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}).</span><span class="n">disposed</span><span class="p">(</span><span class="nl">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 需要展示过期提醒时直接通知相关服务</span>
</span><span class='line'>        <span class="n">remind</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="nl">onNext</span><span class="p">:</span> <span class="p">{</span> <span class="n">status</span> <span class="k">in</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="p">.</span><span class="n">need</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">NotificationCenter</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="bp">NSNotification</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">remind</span><span class="p">,</span> <span class="nl">object</span><span class="p">:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}).</span><span class="n">disposed</span><span class="p">(</span><span class="nl">by</span><span class="p">:</span> <span class="n">disposeBag</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面介绍的方案应该能够满足大部分 app 的需求，如果你的 app 在使用组件化的同时业务也超鸡儿复杂，有很多需要考虑优先级的任务，则需要另外考虑实现方案或者对上面方案进行扩展，比如在 Task 中增加一个队列，用于存储当前需要执行的所有任务，并且任务可根据设置的优先级调整其在队列中的顺序，并支持挂起、执行中、已完成等状态，就像 NSOperationQueue 那样。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何做好技术管理]]></title>
    <link href="https://lijingcheng.github.io/blog/2019/06/12/tech-manage/"/>
    <updated>2019-06-12T19:18:55+08:00</updated>
    <id>https://lijingcheng.github.io/blog/2019/06/12/tech-manage</id>
    <content type="html"><![CDATA[<p>好的技术管理者应该是一名情商高、会沟通并且懂业务的技术人员，如果再懂一点管理，就能够胜任大部分工作。</p>

<!-- more -->


<h2>情商高</h2>

<p>要能够控制情绪，遇事不抱怨，懂得在适当的时候和场景下如何夸奖和批评别人，争论事情时要注意对事不对人，更重要的是要能够做到换位思考。</p>

<h2>会沟通</h2>

<p>沟通能力是每一个技术人员都需要具备的基本能力，技术管理者在这方面应该做的更好。在沟通环节中有两个问题很重要，聆听和表达，其中懂得聆听尤为重要，先让别人把话说完！除此之外还需要注意的是如果在 QQ 或其它工具上沟通不清楚的问题一定要当面沟通，这样效率高而且不容易造成双方误解。</p>

<h2>懂业务</h2>

<p>只有对业务具有较深入的了解才能综合技术和业务角度去思考问题并做出适合的架构设计。</p>

<h2>有技术</h2>

<p>在技术方面要具有一定的判断力和技术视野，不需要对各种技术都很精通，但必须有所了解，要能够对技术在该领域的发展趋势和应用场景有所了解，做产品技术架构的设计要有足够的弹性，既能够保证当前开发效率，又能够对未来产品技术架构的演进留出扩展的余地。除此之外还需要具要有较强的解决问题能力，当团队遇到技术困难时能够站出来解决它，否则很难在团队中建立威信。</p>

<h2>会管理</h2>

<h3>对事管理</h3>

<p>做事前要先明确工作目标和优先级，重要并且着急的事情要先做，重要但是不着急的其次，然后是着急不重要的，最后是不重要也不着急的，当项目时间非常紧时，要懂得适当降级。</p>

<p>任务分配前要先了解每个任务以及团队每个成员的情况，包括能力、性格、当前工作状态等，然后才能够将任务分配给合适的人，分配工作时要讲清楚目标和标准，否则完成效果出了问题后要先反思是不是自己的问题，leader 要勇于替下属承担责任，但是如果自己做的都没有问题，并且下属多次出现同样过错，就要看下是否是其态度出了问题</p>

<p>PS：过程重要但结果更重要，失败了就要把该背的锅背起来</p>

<h3>对人管理</h3>

<p>对上要完成给予的任务，对下要帮助解决问题并协调资源，还要帮助下属成长和提升，对于管理者来说对下管理是否能做好更重要一些。</p>

<h4>对上要注意反馈</h4>

<p>对上要注意信息对等，及时反应问题，不要让领导啥也不知道，出了问题后让别人告诉领导后就晚了，多沟通、多了解整体方向，好及时调整和应对，并且该争取的资源要争取，该背的锅要自己背上，少解释，多想想怎么解决，同样的错误不要犯两次。对于还没有解决的问题，要反馈出解决问题大概需要的时间及目前状态，对于已经解决的问题，要反馈出现问题的原因以及怎么避免再次发生，并且预计该问题造成的影响范围，不要一味的甩锅。</p>

<p>PS：尽量不去做越级沟通的事</p>

<h4>对下要注意授权和培养</h4>

<p>要注重对成员的培养，培养他们的学习能力，思考能力和解决问题的能力，同时要授权组员去做事情，而不是怕他们做不好就自己做了，但授权不是放任不管，而是要针对不同员工类型做不同管理动作，对于新人要有人带，对于有初级经验的人可以讲完再让他做，经验丰富的人他做的时候可以关注下，并给出建议和要求，同时关注工作成果并帮他完善，能力强积极性高的，可分配更重要的工作，并让他参与设计决策中来。</p>

<p>组员做的时候还要给予技术以及资源等方面的支持，并定期评估结果给予反馈，当任一环节出现 delay 时要想办法及时补救，避免积少成多造成项目进度失控。进度把控上需要时刻监督执行的效果，但不是靠天天问进度来了解，也不要完全不管不问，对不熟悉的团队要把重点放在人身上，对熟悉并靠谱的团队要把重点放在事上，当事情结束后对做的好的经予鼓励，做的不好的要指出错误，并且错误的指出要明确和及时，要对事不对人，有些事情可能还需要小范围或单独去沟通。</p>

<p>PS：要保护成员不被部门间其他乱七八糟的事情干扰，团队气氛还是很重要的</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[了解一点互联网架构]]></title>
    <link href="https://lijingcheng.github.io/blog/2019/04/12/app-kai-fa-xu-yao-liao-jie-de-hou-duan-zhi-shi/"/>
    <updated>2019-04-12T17:28:16+08:00</updated>
    <id>https://lijingcheng.github.io/blog/2019/04/12/app-kai-fa-xu-yao-liao-jie-de-hou-duan-zhi-shi</id>
    <content type="html"><![CDATA[<p>早期互联网应用通常用户少、并发低、数据量也比较小，所以将应用程序、文件服务、数据库服务都集中部署在一台服务器上就能够满足需求，这种方式易于开发和部署，但它做不到高可用和高并发，当服务器出现故障或项目升级时需要停止服务。</p>

<!-- more -->


<p>随着时代发展，用户量及数据量快速膨胀，访问量也越来越多，于是对系统的高可用和高并发等方面都有了更高要求，互联网应用架构逐渐发展成需要集群部署以及分布式部署来满足需求。</p>

<ul>
<li><p>集群部署可以简单理解成多台机器部署相同服务，它是用来解决高可用、高并发以及海量数据问题的常用手段，在使用时需要考虑负载均衡、异地多活、容灾备份、以及熔断隔离等问题。</p></li>
<li><p>分布式部署可以简单理解成多台机器部署不同服务，使用时需要考虑各服务间的通信等问题，如 RPC，消息队列以及分布式事务和分布式锁。</p></li>
</ul>


<p><strong> 下图为58架构师沈剑画的互联网应用分层架构图（侵删），将互联网架构分为以下几层：客户端层、反向代理层、Web应用层、服务层和数据层</strong></p>

<p><img src="https://lijingcheng.github.io/images/backend.png" height="500" width="500" alt="" /></p>

<h2>客户端层</h2>

<p>客户端层的主体通常是浏览器、app 和小程序，它们的主要任务就是向用户展示数据并提供所需的数据交互功能，它会频繁的与Web应用层交换数据，在这过程中客户端会向 DNS 服务器发起域名解析请求，如果 DNS 服务器指向了某个 CDN 服务，则会将域名解析操作交给 CDN 中的 DNS 负载均衡系统处理，在识别出访问者是北京某联通用户后，会根据用户 IP 将离用户最近的联通机房中部署的反向代理服务集群中的某个服务器外网地址返回，该地址在被访问时会实施负载均衡策略并将请求转发给内网中Web应用集群中的某一台服务器。</p>

<p><img src="https://lijingcheng.github.io/images/dns.png" height="500" width="500" alt="" /></p>

<p><code>当系统遇到性能问题时，通常会对Web服务器做集群，然后通过反向代理去做负载均衡，当系统吞吐超过反向代理的性能极限并且难以扩容时，可以在 DNS 服务器上对同一个域名配置多个反向代理服务器 IP，然后每次 DNS 解析请求时通过轮询或其他方式返回不同 IP，从而达到负载均衡目的，大型网站通常会使用 DNS 来做一级负载均衡，然后再在内部做第二级负载均衡。</code></p>

<p>一些访问量较高的网站、直播、视频平台都会利用 CDN 来解决不同地域不同网络访问静态资源的速度问题，当用户就近的缓存服务器没有相关资源时才会访问源服务器获取资源，并且根据策略决定是否更新缓存数据。</p>

<p><img src="https://lijingcheng.github.io/images/cdn.png" height="500" width="500" alt="" /></p>

<h2>反向代理层</h2>

<p>通常代理服务器是相对于用户来说的，它可以代替用户去获取网络信息，从而隐藏真实的客户端信息（VPN），而反向代理的目的是为了隐藏Web服务器，它以代理服务器的身份来接受网络连接请求，然后根据负载均衡策略将请求转发给内网上的某台服务器上，以解决系统面临大量用户访问时负载过高的问题，在转发过程中负载均衡技术能够提供服务器的失效检测功能，然后将用户请求转发到可用节点上，从而保证所有服务持续可用</p>

<p><img src="https://lijingcheng.github.io/images/reverseproxy.jpg" height="500" width="500" alt="" /></p>

<p>负载均衡技术包括 DNS 负载均衡、硬件负载均衡和软件负载均衡，其中硬件负载均衡是通过网络设备硬件来抗压力，虽然性能好但是太贵，很多公司负担不起，基于软件做的负载均衡只需要在正常服务器上部署软件即可，它还分为四层协议和七层协议两种：</p>

<ul>
<li>基于第四层传输层来做流量分发的称为四层负载均衡，例如 LVS（Linux Virtual Server），四层负载均衡服务器在接受到客户端请求后通过修改数据包的地址信息（IP + 端口号）将流量转发出去</li>
<li>基于第七层应用层来做流量分发的称为七层负载均衡，例如 Nginx 反向代理软件，它通过代理方式实现负载均衡</li>
</ul>


<blockquote><p>第四层的负载均衡性能相对来说要高一些，但对于一般应用来说七层就够用了，一些大型网站通常会采用 DNS + 四层 + 七层负载的方式进行多层次负载均衡</p></blockquote>

<p>常用负载均衡策略包括：</p>

<ul>
<li>轮询：将请求轮流发送到每个服务器上，这适合每台服务器性能差不多的场景，如果有性能差异，那么性能较差的服务器可能无法承担所分配的负载</li>
<li>加权轮询：在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权重，性能高的服务器分配更高的权重</li>
<li>最少连接：由于每个请求的连接时间不一样，使用轮询或者加权轮询方式可能会使某个服务器当前连接数过大，而有的服务器连接过小造成负载不均衡，最少连接策略就是将请求发送给当前最少连接数的服务器上</li>
<li>加权最少连接：在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数</li>
<li>源地址哈希：通过对客户端 IP 计算哈希值后，再对服务器数量取模得到目标服务器的序号，这样可以保证同一 IP 的客户端的请求会转发到同一台服务器上</li>
</ul>


<h2>Web应用层</h2>

<p>Web应用层通常由多个服务器形成一个或多个集群来向客户端提供服务，当请求量非常大时便要求系统具有处理高并发的能力，并且能够保障一定的高可用性，在高可用上可通过异地多活、容灾备份、以及熔断隔离等方式来保障，高并发上可通过服务降级、限流降级等方式处理。</p>

<ul>
<li><p>服务降级：系统为了应对大量请求会主动关闭部分功能或者降低功能，从而保证核心功能可用，例如电商网站在流量高峰时可以将修改收货地址、退单等非核心功能禁用，还可以限制爬虫流量，对其返回空数据或跳转到某静态页面</p></li>
<li><p>限流降级：当瞬间并发非常高时可以进行限流处理，例如秒杀服务开始时会根据令牌桶算法来控制流量，当数量超过商品数量时便可以向后续访问用户提示需要排队等待或者拒绝服务</p></li>
<li><p>异地多活：大公司通常会把服务部署在不同地区的多个机房中，当某个机房发生例如停电等故障导致服务不能正常使用时，DNS 负载均衡服务会将请求全部切到另一个机房</p></li>
<li><p>熔断：在家里使用电时当线路电压过高，保险丝会自己熔断以防止火灾，映射到软件系统中指的是当某个服务调用慢或发生大量请求超时后对于新的调用请求不在继续调用该服务，当情况好转后并且过了静默期后再恢复调用</p></li>
<li><p>隔离：造船行业有一个专业术语叫做<code>舱壁隔离</code>，是指利用舱壁将不同的船舱隔离起来，如果某一个船舱进水，这时可以立即封闭舱门，可以做到只损失那一个船舱，保障其他船舱不受影响，所以整个船只还是可以正常航行。映射到软件系统中指的是当服务熔断或者发生其它故障时，能够限制问题的影响范围，从而保证只有出问题的业务不可用，其他服务可以正常使用，例如当网站的秒杀系统因抗不住挂了后，其他服务仍然可以继续使用</p></li>
</ul>


<p> <img src="https://lijingcheng.github.io/images/boat.jpg" height="500" width="500" alt="" /></p>

<blockquote><p>熔断和隔离都属于问题后的容错处理机制，而服务降级和限流降级则是一种预防模式。</p></blockquote>

<h2>服务层</h2>

<p>RPC 与消息队列都是分布式系统中服务之间的通信方式，RPC 可以像调用本地函数一样调用网络中另一台服务器提供的服务，消息队列是基于发布订阅模式，消息队列服务器将接收到的消息写入本地内存队列后立即返回成功给消息生产者，然后再根据消息订阅列表查找订阅该消息的订阅者后按照先进先出的原则将队列中的消息发送出去，消息队列具有以下优点</p>

<ul>
<li><p>应用解耦：发送者将消息发送至消息队列即结束对消息的处理，订阅者从消息队列获取该消息后进行后续处理，并不需要知道该消息的来源</p></li>
<li><p>异步处理：发送者将消息发送给消息队列后不需要同步等待订阅者处理完毕，而是立即返回并进行其它操作</p></li>
<li><p>流量削锋：在访问高峰时，可以将消息暂存于消息队列中，从而减轻了数据库的存储负载压力，服务器按照其处理能力从消息队列中订阅消息并进行处理</p></li>
</ul>


<p><img src="https://lijingcheng.github.io/images/mq.jpg" height="500" width="500" alt="" /></p>

<blockquote><p>当调用方需要关心执行结果时通常使用 RPC，不关心执行结果仍使用 RPC 调用会造成服务之间耦合以及响应速度慢等问题，这时比较适合使用消息队列，例如用户注册账户后的发送验证邮件问题，如果必须完成验证邮件中的提示操作才算完成注册则需要在注册操作后通过 RPC 来调用发邮件服务，否则应该使用消息队列。</p></blockquote>

<h2>数据层</h2>

<p>数据层作为系统的核心，在设计时需要考虑高并发和大数据的查询效率问题，在做优化时可先考虑加缓存，然后才是数据库的读写分离和分库分表。</p>

<h3>缓存</h3>

<p>大部分互联网业务都是读多写少，数据库的读操作往往会成为性能瓶颈，引入缓存层后如果用户在访问时能够命中缓存，便能够减小数据库的访问压力又可以提高访问速度，所以优化缓存命中率以及缓存与数据的一致性就变的很重要，一般可通过淘汰过期缓存以及命中率低的缓存数据来提高命中率。</p>

<p><img src="https://lijingcheng.github.io/images/cache.jpeg" height="300" width="300" alt="" /></p>

<p>使用缓存还需要考虑当发生缓存穿透以及缓存雪崩时的处理办法，缓存穿透指的是对缓存中不存在的数据进行请求，该请求将会穿透缓存到达数据库，当相关流量非常大或有人故意攻击时会造成缓存雪崩，从而导致数据库无法处理这么大的请求而崩溃。</p>

<h3>读写分离</h3>

<p>系统在使用缓存后仍然会有一部分请求因缓存没命中而将读操作直接操作在数据库上，在数据库读写并发量高时，数据库便会因负载压力过大而影响性能，所以一般会将业务数据库做读写分离，即分为一个主库以及一个或多个从库，写请求访问主数据库，读请求访问从数据库，从而改善数据库负载压力，主数据库会通过主从复制机制将数据更新同步到从数据库。</p>

<p><img src="https://lijingcheng.github.io/images/rw.jpg" height="500" width="500" alt="" /></p>

<h3>分库分表</h3>

<p>分库分表即是把原本存储于一个库的数据按业务分库后存储到多个服务器上，把原本存储于一个表的数据分块存储到多个表上，常见的分表方式：</p>

<ul>
<li><p>垂直切分：当单个表中的字段非常多时可以按表中字段的访问频率高低来拆表，此方式通常与业务结合比较紧密，并不是所有业务都适合垂直切分</p></li>
<li><p>水平切分：当单个表中的数据量非常大时可以在数据库中创建多个相同结构的表，然后按<code>范围法</code>或<code>哈希法</code>将原表中的数据拆分后填充进去</p>

<ul>
<li>范围法：order_0 表存储 id 范围 1-1kw，order_1 表存储 id 范围 1kw-2kw，以此类推</li>
<li>哈希法：存储某个 key 值 hash 后的部分数据， order_0 表存储 id % 4 = 0 的数据，order_1 表存储 id % 4 = 1 的数据，以此类推</li>
</ul>
</li>
</ul>


<p><code>范围法对于数据库扩展性上较好，可以随时加一个 order_3 用来存储 2kw-3kw 的数据，缺点是负载不一定均衡，新订单所在的表被访问的频率会非常高，哈希法相对来说负载较均衡，使用较广泛</code></p>

<p><img src="https://lijingcheng.github.io/images/fb.jpeg" height="500" width="500" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学习骑摩托〜]]></title>
    <link href="https://lijingcheng.github.io/blog/2019/03/28/an-quan-xing-che-zhi-mo-tuo-che-pian/"/>
    <updated>2019-03-28T15:02:12+08:00</updated>
    <id>https://lijingcheng.github.io/blog/2019/03/28/an-quan-xing-che-zhi-mo-tuo-che-pian</id>
    <content type="html"><![CDATA[<p>总结了一些骑车时需要注意的事情，也许能帮助到新手。</p>

<!-- more -->


<h2>起步</h2>

<ul>
<li>上车后首先确认车辆处于空挡，然后打侧踢，通电后拉住离合再打火（养成这个习惯可避免因车辆误挂在空档外的其他档位上而导致在打火后窜出去）</li>
<li>捏住离合和前刹车后挂一档，然后再换脚踩后刹松开前刹（高档位停车时要注意把档位放回一档，高档位起步很容易烧离合，或者熄火）</li>
<li>打左转向，观察后视镜并回头确认安全后慢松离合，松快了会熄火，如果希望起步能快点，可以先加一点点油，然后再慢松离合，松的过慢对离合不好，松太快并且油门给的很大时车会前冲，甚至翘头（找到离合咬合点的位置后，可快速松到咬合点位置再慢松）</li>
</ul>


<h2>行车</h2>

<h3>姿势</h3>

<ul>
<li>用前脚掌踩脚踏，避免车辆颠簸时误踩刹车或档杆，脚要直踩不要八字，避免转弯倾角低时磨到脚而倒致摔车</li>
<li>用腿夹住油箱从而把自己固定在车上，手轻搭在车把上，不要把身体重量压上去</li>
<li>右手掌要注意姿势，不要因不小心而拧大油门，捏离合和刹车用两个指头，好处是遇到阻力时不容易脱手</li>
<li>加速时身体往前弯些，减速相反，刹车时腿要紧贴油箱</li>
</ul>


<h3>换档</h3>

<ul>
<li>加档操作：收油 - 捏离合 - 加档 - 松离合 - 加油 （收油是指用手将油门转回去，而不是让油门自己弹回去）</li>
<li>减档操作与加档几乎一样，需要注意的是高速行驶时减档会引起车辆顿挫，避免出现这种情况的方法就是减档补油，即指减档后松离合前就快速给一点点油（减档补油可避免因减档操作造成发动机转速与后轮转速有差异而产生后轮打滑问题，有滑动离合的车可省去此操作）</li>
<li>一档二档间的更换建议稍微用些力，避免挂入空档，万一挂了空档，那就捏住离合再挂一下</li>
<li>一档二档间的更换离合都建议慢放，这样顿挫感会小些，高档之间的升降可快放离合</li>
<li>把握好加减档时机，低档位高转速时车辆引擎会发热并产生震动，声音也会变得高亢，这时便需要加档，而高档位低转速车会有加油没力要熄火的感觉，这时便需要减档并补油，如果是连降两档，要补的油也要稍微多一点（高档位低转速通常发生在刹车减速拐弯忘了降档）</li>
</ul>


<h3>转弯</h3>

<ul>
<li>打转向灯后，除了看后视镜，最好也快速转头看一下，这样死角会少一些</li>
<li>一定要在进弯道前通过刹车和降档来控制好速度，进入弯道后便松开刹车，但是油门要保持住，不要突然加油或收油，否则影响车辆重心而产生危险</li>
<li>转弯时走路外侧，然后切进去，出弯后车回正后再加油</li>
<li>转弯时不要用前刹，容易抱死倒致原地倒车，用后刹的话也只能一点点踩，避免后轮锁死</li>
<li>行车时视线要小心，因为车子会随着目光而前进，所以在山路出弯，或者要撞上东西时，眼睛要注意避开</li>
<li>逆操舵通常在速度较快时才可以用，左转往右轻推车把，这时车会往左倾，右转往左轻推，车会往右倾，当车发生倾斜时再往想转的方向转龙头（推把越快倾斜的就越快，所以速度快并且弯比较急时可以用下，如果速度只有30以下就没必要使用这种方式了）</li>
</ul>


<h3>行驶</h3>

<ul>
<li>注意横风，远离大车，从大车边上超车时也要注意气流变化</li>
<li>摩托车制动距离比汽车长，跟车时要加大距离，并且不要跟在前车的正后方，马路中间相对脏一些，例如机油、垃圾等，优先跟左后侧，可以降低左侧车强行并线概率</li>
<li>在车道上行驶时要跟上汽车的速度，不要过快或过慢，并且要明白自己是弱势群体，不要和汽车较劲</li>
<li>换线时一定要转头看一下，并且要注意其他汽车是否也要换线</li>
<li>超车要从左边超，因为路的最右边会有很多杂东西，可能会倒致滑倒或扎胎，而且会有风的力把人吸过去</li>
<li>车流速度快时不要钻车缝，堵车或速度很慢时可以考虑，钻车缝时要随时准备刹车，相对来说走内车道好些，因为内侧车换线机率小</li>
<li>堵车时要注意半离合行驶，不能拧大油门，否则毁离合器，如果要减速最好用后刹，用前刹的话车反应大，有可能就会停下来</li>
</ul>


<h2>停车</h2>

<h3>刹车</h3>

<ul>
<li>前刹的主要作用是停止车辆，后刹的主要作用是减速</li>
<li>刹车前一定要放开油门，刹车时不用捏离合，速度降到快要停下来时再捏以免发动机被憋熄火</li>
<li>跟开车一样，要根据情况备刹车放油门，放油门时会通过档刹减速，这时如果捏离合的话，车辆会处于滑行状态，没法利用引擎的档刹减速</li>
<li>通常需要减速时可以先用后刹减速（由浅入深），然后同时捏前刹，并配合降档，降档是为了保持足够的扭力让你有充足的准备做其他事情</li>
<li>刹车时车头一定要摆正，否则可能会因为车身倾斜并且车太重而倒车（过弯时不要用刹车）</li>
<li>遇到障碍物要躲时，千万不要边刹车边躲，否则会打滑，可以先刹车减速然后放开刹车后再躲</li>
<li>紧急刹车时要先松油门，腿部要夹紧油箱，否则重心会往前甩，然后再大力踩后刹并捏前刹，两者要同时做，并且是逐渐加力，刹车时如果感觉轮子锁死可适当松一下刹车，然后再捏死或踩死（有 ABS 的车遇到紧急情况时可直接捏死前刹，并且脚踩后刹）</li>
<li>冬天没有暖胎（胎比较硬时）急刹车的话，很容易摔倒，所以要骑一会才可以提高速度</li>
</ul>


<h3>停车</h3>

<ul>
<li>等红灯停车时，通过刹车减速到车辆要停止时捏住离合并降档到一档，不要挂空档，这样有特殊情况时好处理</li>
<li>路边停车时要先打右转向，看后视镜并回头观察情况后靠边停车，然后挂空挡，放车柱，再将转向灯回位及熄火</li>
<li>空档时车辆可前后推动，所以在有坡路段要注意，停车时用一档，并且要推车或倒车时应该用空档，要是在上坡路推不上去，就只能骑上去</li>
<li>如果车辆意外倒地，要挂空档并熄火，最好再放下车柱，避免扶起时，车子继续倒</li>
</ul>


<h2>安全</h2>

<ul>
<li>头盔、手套、护膝是必备的，其它装备根据自己经济情况去选择</li>
<li>怕丢车的话可以选择上防盗险，要不然就要多注意停车位置以及车锁的选择</li>
<li>要小心路边的车突然开门，以及送外卖的</li>
<li>过任何路口，都要松油门，待刹车，过了再加速别怕麻烦</li>
<li>后座人上下车，司机一定要放下车柱，避免倒车</li>
<li>要注意能够导致轮胎打滑的东西，例如雨水、落叶、砂石、坑洼、斑马线</li>
</ul>


<blockquote><p><strong>控制右手</strong></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 应用的开发设计]]></title>
    <link href="https://lijingcheng.github.io/blog/2018/09/05/ios-appde-zu-jian-hua-she-ji/"/>
    <updated>2018-09-05T18:40:19+08:00</updated>
    <id>https://lijingcheng.github.io/blog/2018/09/05/ios-appde-zu-jian-hua-she-ji</id>
    <content type="html"><![CDATA[<p>一个 app 从设计到发布应用商店会经历需求设计、UI设计、架构设计、开发、优化、测试等流程，每个环节做的好与坏都会影响到整个 app 的质量，作为开发人员，不仅要对需求以及 UI 的合理性进行评审，还要保证提供给测试的代码是经过自测并且覆盖了相关测试用例，更重要的是要做好架构设计、开发以及优化这三个环节。</p>

<!-- more -->


<h1>架构设计</h1>

<p>架构设计可以以业务为驱动，按照最适合自己的方式去设计，设计思路和方法尽量统一，同类型问题用同样方式去解决，下面几点是我认为比较重要的：</p>

<ul>
<li><p>关注分离<br/>
将系统分解为多个模块并各司其职，纵向分层，横向拆分业务。</p></li>
<li><p>高内聚<br/>
一个模块只完成一个功能，并合理有度的进行封装。</p></li>
<li><p>松耦合<br/>
依赖关系越少越好，尽量不横向依赖，不跨层访问。继承是紧耦合的一种操作，它通常与多态一起存在，如果仅仅是为了代码重用而做的继承还不如用组合。</p></li>
<li><p>适度设计<br/>
对业务方该限制的地方要进行限制，该灵活的地方也要给业务方创造灵活实现的条件，架构的设计要保持一定量的超前性而做到易扩展，但不要设计过度，避免多做无用功而增加框架复杂度。好的架构是随着时间而更新的，而不是一开始就设计好了一切。</p></li>
<li><p>技术选型<br/>
不要仅是为了体验新技术而改变现有架构，等别人把坑踩平后再根据团队及业务情况考虑是否使用，技术本身没有什么好不好，只有适合不适合。</p></li>
</ul>


<blockquote><p>框架是服务开发人员的，需要满足通用性和易用性两个要求，其中易用性更重要</p></blockquote>

<p><br></p>

<h1>开发</h1>

<h2>MVVM</h2>

<p>MVVM 相对 MVC 来说最大的优点是，ViewModel 是独立的，可复用到别的模块，并且更易于做单元测试，而 View 和 ViewController 仅用来做 UI 展示，它与 ViewModel 之间是相互影响的，ViewModel 处理过的数据要能够及时响应到 View，而用户在 View 中做了修改数据的操作后，ViewModel 中对应的数据也应该及时更新，响应式编程方式能够更容易的处理这个过程</p>

<h2>响应式编程</h2>

<p>响应式编程是一种面向数据及其变化响应的编程方式，它能够将数据、UI事件和异步操作更方便的进行序列化处理，相比传统编程方式来说，它可以使逻辑相关的代码能够紧凑的聚在一起，它通过信号机制来实现，用信号来记录值的变化，并通过信号绑定的方式来响应变化，下面这个例子很好的描述了响应式编程的作用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = 2 // signal
</span><span class='line'>b = 2 // signal
</span><span class='line'>c = a + b // signal binding c = 4 
</span><span class='line'>b = 3 // c = 5</span></code></pre></td></tr></table></div></figure>


<p>目前我们在 Swift 项目中选择使用 RxSwift + MVVM 的方式进行开发，使用 RxSwift 需要掌握以下几个概念：</p>

<ul>
<li><p>Observable（被观察者）：相当于一个事件序列，它会主动向订阅者发送新产生的事件内容，包括 onNext、onError、onCompleted()</p></li>
<li><p>Subscribe（订阅者）：订阅后便可以根据事件产生的数据进行操作</p></li>
<li><p>Scheduler（调度器）：可分别通过 subscribeOn 和 observeOn 指定 Observable 或 Subscribe 在哪个线程上执行，默认是当前线程。</p></li>
<li><p>Operator（<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree.html">操作符</a>）：RxSwift 提供了很多操作符，合理运用便会极大提高开发效率</p></li>
<li><p>Subject：既可以作为 Observable 发送事件也可以作为 Subscribe 监听事件，它包括以下几种：</p>

<ul>
<li>PublishSubject：订阅者只会接收到订阅操作之后的事件，也就是所说的热信号。</li>
<li>ReplaySubject：订阅者会接受到订阅之前的事件（可根据 bufferSize 指定数量）以及订阅之后的事件，类似于冷信号。</li>
<li>BehaviorSubject：订阅之后首先会接收到最近一次发送的事件，如果最近没有发送，那么发送一个初始事件。</li>
<li>AsyncSubject：订阅者只有在 Observable 发送 onCompleted() 时才能够收到它之前发送的最后一个事件，即使是在这之后的新订阅者也能够收到。</li>
</ul>
</li>
</ul>


<h2>跨平台开发</h2>

<p>跨平台开发的方式很多，做技术选型时要根据业务及团队情况去选择</p>

<h3>Hybrid（H5 + Native）</h3>

<p>使用 WebView 承载 H5 页面并通过 JSBridge 实现交互，性能略差，可通过预下载资源等方式进行优化。</p>

<h3>Reatct Native</h3>

<p>RN 中虚拟 DOM 会通过 JavaScriptCore 映射为原生控件，性能比 H5 高一些，但由于渲染时需要 JS 和Native 通信，在有些场景（拖动）可能会因为通信频繁导致卡顿，可以通过延迟渲染方式解决，但更重要的问题是维护成本大。</p>

<h3>Flutter</h3>

<p>Flutter 使用 Skia 2D 渲染引擎来绘制 UI，采用 Dart 语言开发，Dart 是类型安全的语言，比 JS 运行速度快也更安全一些，它支持 AOT(Ahead of time 提前编译) 和 JIT(Just-in-time 即时编译) 两种运行方式，在开发阶段采用 JIT 来实现热重载，在发布时采用 AOT 来生成高效的 ARM 代码以保证应用性能，所以 Flutter 应用发布后不能像 Hybrid 和 RN 那些使用 JS 作为开发语言的框架去动态下发代码。</p>

<h3>SwiftUI</h3>

<p>SwiftUI 使用 DSL 声明式 UI、跨自家平台、Xcode 通过单独编译我们当前操作的视图文件，利用 Swift dynamic repacement 特性将更新内容注入到正在运行的程序中来实现热重载。</p>

<h2>组件化开发</h2>

<p>随着 app 功能和体积的增长，也带来了一些问题</p>

<ul>
<li>编译速度缓慢</li>
<li>commit 代码经常要 merge</li>
<li>业务代码混在一起、开发功能类似的新项目时需要从头搭建</li>
</ul>


<h3>拆分组件</h3>

<p>组件即功能组件，模块即业务模块，拆分时要把握好粒度，要考虑到维护成本</p>

<ul>
<li>每个组件对应一个 project，身为组件的同时还能够独立运行和打测试包</li>
<li>大点的项目除了按框架分层拆分还可以按业务模块拆分，需要把握好拆分粒度</li>
<li>小项目按框架分层拆分就可以了</li>
</ul>


<h3>组件之间的依赖关系</h3>

<ul>
<li>业务模块依赖于框架</li>
<li>业务模块之间避免横向依赖（可适当的有些重复代码或存放重复资源）</li>
<li>禁止框架依赖业务模块</li>
</ul>


<h3>组件化实施</h3>

<p>通过 CocoaPods 来实现组件化</p>

<ul>
<li>Podfile：定义私有库地址和需要依赖的组件及版本</li>
<li>Podspec：定义组件的依赖库、编译设置、以及需要打包的资源及代码，资源包括 xib、国际化文件、assets 等</li>
</ul>


<h3>组件中的资源访问</h3>

<p>访问 image、xib、storyboard 时需要指定 bundle，如果项目中使用了 R.swift，可以在各组件中通过以下角本来修改 R.generated.swift 中设置的 bundle，修改后在组件中使用 R.image.xxx()，此代码在组件中是指 main bundle，在主工程中会将其认定为 core bundle。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$PODS_ROOT/R.swift/rswift" generate "$SRCROOT" --accessLevel public
</span><span class='line'>sed -i '' -e "s/Bundle(for: R.Class.self)/Bundle.core/g" “$SRCROOT/</span></code></pre></td></tr></table></div></figure>


<blockquote><p>还需要在各组件中正确使用 open、public、private</p></blockquote>

<h3>组件之间的路由跳转</h3>

<p>网上有很多关于这方面的文章，我们使用的是一种较简单比较适合我们的方式：Router.open 跳转方法需要传入几个比较重要的参数：name、storyboard、bundle，如果要打开的 ViewController 是通过代码或 xib 实现的，需要在这里指定 name，然后会通过 viewControllerWithClassName 方法得到 VC 对象，如果 ViewController 是定义在 storyboard 里的，那么在跳转时需要指定 storyboard，如果要打开的是别的组件中的 ViewController，还需要指定对应 bundle。</p>

<p>通过上面方式实现组件间的路由跳转需要对 ViewController 和 params 有以下要求</p>

<ul>
<li>ViewController 的类名要与 xib 名或 storyboard 中的 id 相同，如果要支持被其他组件使用并且是通过 xib 画的 UI，还需要重写 init() 并调用 super.init(nibName: nil, bundle: Bundle.xxx) 设置 nibName 和 bundle</li>
<li>跳转页面传参通过 KVC 方式实现，所以要求 ViewController 的相关参数要加上 @objc，还需要加上注释说明属性用途</li>
<li>ViewControllerName 和 propertyName 尽量不去变更，如有变更需要让别人知道</li>
</ul>


<p>下面代码描述了 open 方法的定义和如果根据 ViewController 名字得到其对象</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static func open(_ name: String, storyboard: String = "", bundle: Bundle = Bundle.main, params: [String: Any] = [:], needLogin: Bool = false, animated: Bool = true, present: Bool = false, completion: (() -&gt; Void)? = nil) {
</span><span class='line'>    let viewController = RouterService.viewControllerWithClassName(name, storyboard: storyboard, bundle: bundle)
</span><span class='line'>    
</span><span class='line'>    RouterService.open(viewController, params: params, needLogin: needLogin, animated: animated, present: present, completion: completion)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public static func viewControllerWithClassName(_ name: String, storyboard: String = "", bundle: Bundle) -&gt; UIViewController? {
</span><span class='line'>    var viewController: UIViewController?
</span><span class='line'>    
</span><span class='line'>    if storyboard.isEmpty {
</span><span class='line'>        var bundleName: String?
</span><span class='line'>        
</span><span class='line'>        if bundle == Bundle.main {
</span><span class='line'>            bundleName = (Bundle.main.infoDictionary!["CFBundleExecutable"] as! String).replacingOccurrences(of: "-", with: "_")
</span><span class='line'>        } else {
</span><span class='line'>            bundleName = bundle.infoDictionary!["CFBundleName"] as? String
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        if let vc = NSClassFromString((bundleName! + "." + name)) as? UIViewController.Type {
</span><span class='line'>            viewController = vc.init()
</span><span class='line'>        }
</span><span class='line'>    } else {
</span><span class='line'>        try? ObjC.catchException {
</span><span class='line'>            viewController = UIStoryboard(name: storyboard, bundle: bundle).instantiateViewController(withIdentifier: name)
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return viewController
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>再介绍几个小功能和需要注意的地方</p>

<ul>
<li><p>打开页面时指定是否需要登录，然后将原本想要跳转的页面信息及参数传递给登录页，当登录成功后直接跳转到该页面，并将登录页本身从导航堆栈中移除</p></li>
<li><p>pop 页面时除 navigation 的三种方式外，增加锚点方式返回，例如在购买商品页面填加锚点，然后当页面流转到购买成功时，可将导航堆栈反转过来，pop 到最近的一个锚点页面或指定锚点页面</p></li>
<li><p>页面跳转如果设置了使用动画，在动画结束前不会响应其它跳转任务</p></li>
<li><p>pop 时要考虑到导航堆栈里不存在指定页面的场景，还要确定当前 VC 是否是 navigationController</p></li>
<li><p>传参使用字典还是 Model 也是需要注意的问题，虽然用字典代替 Model 存储数据对于组件化架构来说是解决组件之间数据传递参数的好办法，并且可以做到组件间的松耦合，但使用起来较麻烦，容易出错，所以建议简单的数据模型可以不定义成 Model，复杂模型还是有必要使用 Model，代码清楚，复用性好，有维护多组件能力的团队可以将多个业务组件共用的 Model 单独以组件形式维护，或者像我们一样允许组件中存在重复 Model</p></li>
</ul>


<h3>组件的多环境打包</h3>

<p>App 运行环境通常有测试环境、预上线环境、正常环境三种，这里分别用 QA、STG、PRD 表示，有些公司还会有企业开发者账号，用来自己分发项目更方便的去做测试工作，下面针对这种情况做多环境打包设置</p>

<ul>
<li>通过 xcconfig 方式在原先的 debug、release 上扩展出 staging、enterprisePRD、production，切换环境时只要在 Scheme 中的 Build Configration 中设置一下就可以了（对于 xcconfig 这里不做详细介绍）</li>
<li>上面列出的 debug 和 release 对应 QA，enterprisePRD 和 production 对应 PRD，其中 production 作为正式打包上线的设置项</li>
<li>xcconfig 文件中可针对不同环境设置不同的 app 名字，还可以对 enterprisePRD 设置不同的微信Id 或其它内容</li>
</ul>


<p>组件在不同环境中 podspec 的内容也会不同，主要体现在 version 和 source 字段</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 开发环境
</span><span class='line'>s.version      = '6.5.5'
</span><span class='line'>s.source       = { :git =&gt;'http://gitlab.mx.com/ios/wandafilm-card.git', :branch =&gt; "feature/#{s.version}"}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># 上线环境，需要打 git tag
</span><span class='line'>s.version      = '6.5.5.master'
</span><span class='line'>s.source       = { :git =&gt;'http://gitlab.mx.com/ios/wandafilm-core.git', :branch =&gt; 'master', :tag =&gt; s.version}</span></code></pre></td></tr></table></div></figure>


<h1>优化</h1>

<h2>线上 Bug 率</h2>

<p>处理线上 Bug 降低 Bug 率需要根据项目团队情况按优先级处理，优先级由高到低为：</p>

<ul>
<li>次数较多的 Bug 不管是否好处理都需要优先处理，并根据情况决定是否需要发版，还需要将原因及如何避免等问题分享给团队成员，避免其他人再次出现类似问题</li>
<li>次数较少但是容易处理的 Bug 修改后需要关注新版本上线后是否还会出现</li>
<li>无法复现但是有一定影响的 Bug 可根据情况添加保护性代码避免 app 崩溃，但要求能够预知是否会造成其他问题（数据异常，页面异常等）</li>
<li>次数少处理难度大的 Bug 放最后，有时间时再去调查原因</li>
</ul>


<blockquote><p>修改 Bug 或者重构优化功能后要告知测试人员影响范围，避免因没覆盖测试而上线出现问题</p></blockquote>

<h2>数据安全</h2>

<p>我们从 AppStore 下载的 app 其实都已经由苹果加壳，要砸壳后才能有办法看到汇编形式的源代码，如果我们要自己再加一层壳，可以对关键代码的方法名做一些混淆，以增加别人分析代码的复杂度，不过这对于大多数 app 来说不太值得去做，我们可以把精力放在其他更易做并且更有效率的地方，例如：</p>

<ul>
<li>不将敏感数据直接存储在沙盒里</li>
<li>使用 Https 保证数据传输安全</li>
<li>调用接口时对敏感数据进行加密</li>
</ul>


<p>加密数据通常有两种方式</p>

<ul>
<li>对称加密：文件加密和解密使用相同的密钥，AES 相对其他对称加密方式来说更安全些。</li>
<li>非对称加密：需要公钥和私钥，用公钥对数据进行加密，只有对应的私钥才能解密；如果用私钥对数据进行加密，那么只有对应的公钥才能解密。可以用 RSA 来做非对称加密，相对对称加密来说非对称加密速度较慢，但非常安全，据说还没被破解过。

<ul>
<li>苹果官方生成一对公私钥，在 iOS 系统里内置公钥，私钥由苹果后台保存，我们上传 app 到 AppStore 时，苹果后台用私钥对 app 数据进行签名，iOS 系统下载这个 app 后，用公钥验证这个签名，若签名正确，这个 app 肯定是由苹果后台认证的，并且没有被修改过。</li>
</ul>
</li>
</ul>


<p>对敏感数据进行加密通常选择对称加密，这时如何使用密钥则是一件非常重要的事，不管是 app 在代码中写死密钥还是简单的通过接口获取密钥都不安全，下面介绍一种相对更安全的方式：</p>

<ul>
<li>首先由客户端向服务端发起获取钥匙的请求</li>
<li>服务端生成公钥<code>pk1</code>和私钥<code>pk2</code>，然后将公钥<code>pk1</code>发送给客户端（假设此时黑客已经获取到了公钥<code>pk1</code>）</li>
<li>客户端这时首先生成公钥<code>pk3</code>和私钥<code>pk4</code>，然后将公钥<code>pk3</code>通过服务端返回的公钥<code>pk1</code>加密并发送给服务端（假设此时黑客截获加密后的<code>pk3</code>，虽然知道这是由<code>pk1</code>加密的，但是他不知道与其对应的私钥<code>pk2</code>，所以无法对客户端发送的公钥进行解密）</li>
<li>服务端收到加密后的<code>pk3</code>后可以通过私钥<code>pk2</code>解密，并使用<code>pk3</code>对生成的对称加密密钥<code>xxx</code>进行加密并发送给客户端（黑客这时因为不知道公钥<code>pk3</code>是什么，所以得不到对称加密的密钥）</li>
<li>客户端收到数据后，可以用自己的私钥<code>pk4</code>解密并得到对称加密用的密钥<code>xxx</code>，客户端将密钥<code>xxx</code>存储在内存中，接下来两端就可以使用<code>xxx</code>作为 key 来加密数据并进行安全的数据传输了。</li>
</ul>


<h2>启动时间</h2>

<p>可以通过 Instruments 的 Time Profiler 工具来查看耗费时间，也可以通过在 Xcode 中修改项目的 scheme，在 Run -> Auguments 增加环境变量 DYLD_PRINT_STATISTICS 并设置为 1，然后观察控制台打出的 log 来查看</p>

<ul>
<li>pre-main 阶段系统会由 dyld（the dynamic link editor）加载相关动态链接库，然后再初始化 runtime 环境，并由 runtime 触发 + load 方法，所以不要在 load 方法里执行耗时任务，否则会影响启动时间，并且用不到的代码文件要及时删除。</li>
<li>检查 didFinishLaunchingWithOptions 及启动相关的方法，将部分操作改为异步执行或延迟处理</li>
<li>首页相关 ViewController 尽量使用代码实现</li>
</ul>


<h2>App 瘦身</h2>

<ul>
<li>将部分资源文件从工程中移除，改为从接口获取，并且可以通过给数据加版本号，避免每次重复下载。</li>
<li>清理无用的代码文件和资源，不要 @1x 图片，如果用到了 ProtoBuf，可以将 .proto 文件从 Compile Sources 中移除。</li>
<li>压缩图片，目前发现 <a href="tinypng.com">tinypng.com</a> 的压缩效果最好，而且是无损的。</li>
<li>小图标可以使用 iconfont 替代，大图可以用 pdf 替代</li>
<li>启动图界面用 LaunchScreen.storyboard，不要用多张 Default 图。</li>
<li>用 .xcassets 来管理图片，Xcode 能够把里边的所有 png 图片压缩成 .car 文件。并且 iOS9 之后，如果是用 .xcassets 管理图片，AppStore 会根据不同设备准备不同的安装包，每个包内只有对应尺寸的图片，例如 iPhone6 下载 app 时，包里就只有 @2x 图。</li>
<li>放弃 iPhone5s 之前发布的 32 位手机，仅支持 arm64</li>
</ul>


<h2>流量</h2>

<ul>
<li>合理使用本地缓存数据并及时更新缓存</li>
<li>考虑用 ProtoBuf 替代 JSON，也可以仅是个别数据量大的接口改为 ProtoBuf 格式数据</li>
<li>轮询接口方式可以用 WebSocket 替代</li>
<li>请求的图片格式考虑由 jpg 改为 webp，减少图片下载时间，再想办法提高图片转码时间</li>
<li>按 UIImageView 大小取合适大小的图片，不要直接取原图，同一图片用在不同界面时，尽量要求 UI 统一视图比例，然后 app 统一获取同样大小图片，这样做的话不管对 app 还是 CDN 都能够提高缓存利用率</li>
<li>非关键的业务数据，可以通过合并接口的方式，减少和服务器的交互次数。</li>
<li>请求接口前客户端通过对 request params 做检查来减少不必要的网络请求</li>
<li>可以用 ETag 这种服务端加本地验证的方式处理返回数据，当数据没有更新时不返回数据，而是返回 304</li>
<li>数据量大时要提示用户是否在非 wifi 环境下下载</li>
<li>网络框架增加取消请求功能，避免返回用户已经不需要的数据</li>
</ul>


<h2>UI 交互</h2>

<ul>
<li>延迟处理不需要马上展现的视图或操作</li>
<li>不要阻塞主线程，能异步去做的就不要同步。</li>
<li>由于 UIKit 中大部分对象都不是线程安全的，所以 UI 操作都需要放在主线程做串行处理，否则可能会导致未知行为（动画异常、页面错乱、Crash）。</li>
<li>优化表格滑动

<ul>
<li>提前算 Cell 高度并缓存，如果要加载的数据也是要经过处理才展示的也提前处理好</li>
<li>异步绘制，滑动过程中不加载图片</li>
<li>当 Cell 中有很多子视图并且他们要在不同条件下展示时，考虑拆成多个 Cell</li>
<li>不要在 Cell 中频繁生成 NSDateFormatter 对象</li>
</ul>
</li>
<li>通过设置模拟器的 Debug 菜单下的几项设置来查看图层视图是否需要优化

<ul>
<li>Color Blended layers<br/>
大多情况是因为视图的 backgroundColor 与父视图颜色不一致或者是透明的，它会用红色表示有问题的视图，而绿色的表示没问题</li>
<li>Color copied images<br/>
当图片的色彩格式不能被 GPU 处理时，会交由 CPU 处理，应该尽可能避免这种问题</li>
<li>Color misaligned images<br/>
图片大小与控件不一致，会用黄色表示图片被缩放了，用紫色表示像素没对齐</li>
<li>Color offscreen-rendered<br/>
用黄色标示哪些 layer 做了离屏渲染（当 GPU 无法将渲染结果直接写入 frame buffer，而是将结果暂存在其他内存后再写入 frame buffer），多数时候离屏渲染会影响性能，应该尽量避免，无法避免时可通过 shouldRasterize 来缓存渲染结果，降低影响，在开发过程中需要重点关注列表中对 View 做圆角设置和添加阴影操作。

<ul>
<li>cornerRadius + clipsToBounds 设置圆角会触发离屏渲染，仅使用 cornerRadius 不会触发，但效果不好，可以用带圆角效果的 layer 盖住视图实现圆角效果，以避免离屏渲染</li>
<li>使用 shadowPath 添加阴影可以避免离屏渲染</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>PS：过早的优化是万恶之源！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安全行车注意事项]]></title>
    <link href="https://lijingcheng.github.io/blog/2017/10/19/new-driver/"/>
    <updated>2017-10-19T20:04:50+08:00</updated>
    <id>https://lijingcheng.github.io/blog/2017/10/19/new-driver</id>
    <content type="html"><![CDATA[<p>总结了一些开车时需要注意的事情，希望能帮助到刚拿到驾照的新司机。</p>

<!-- more -->


<h2>起步</h2>

<ul>
<li>不要酒后/疲劳/生气时开车</li>
<li>确认车周围有没有障碍物或人（曾顶着停车桩开了十多米）</li>
<li>车上所有人都要系安全带</li>
<li>打左转向灯提醒后方来车，并通过后视镜确认安全后再起步

<h2>行车</h2></li>
<li>要频繁看后视镜，就象打王者荣耀时看小地图一样</li>
<li>让速不让路，除非前后都是能夹死你的大车</li>
<li>养成变道打转向灯的习惯，无论后面有没有车，变道的时候对准车道后再踩油门，并且小心两边车道的人都往中间车道并</li>
<li>不要跟其他车并排行驶</li>
<li>走车道中间，否则会被挤，也不安全</li>
<li>路口减速，避免电动车、自行车和人窜出</li>
<li>转弯让直行</li>
<li>小心公交车，很多公交司机都太霸道</li>
<li>前车突然变道，最好踩下刹车并同时考虑变道，有可能前方有事故</li>
<li>遇到紧急情况先踩刹车，在看后视镜</li>
<li>在不确定要踩油门加速的情况下，把脚悬在刹车上，刹车后轻抬刹车可以不点头，油门要慢踩慢抬</li>
<li>不要开太快，十次出事九次快</li>
<li>离路边停的车远点，他们随时可能打开车门</li>
<li>经过路口有意识地放开油门或者轻踩刹车，以防有路人或车冲出来</li>
<li>视线被挡时必须慢，例如右面有公交车时，要小心有人从车前跑出来

<h2>跟车</h2></li>
<li>保持车距眼光要放远</li>
<li>不跟大车，大车档视线、货车掉东西</li>
<li>不跟出租车，因为他随时会踩刹车和变道</li>
<li>前车刹车你最好也刹</li>
<li>雨雪天气以及车上满员时要提前踩刹车</li>
<li>超车前先给信号，闪两下大灯，并且要避免前车忽然变道（遇到过两次大车故意在我变道时別我）

<h2>倒车</h2></li>
<li>方向盘调整要快，车速要慢</li>
<li>如果不是在坡路上不要踩油门，特别是方向盘不正的情况下会很危险

<h2>高速</h2></li>
<li>远离大车</li>
<li>不出高速尽量不走外侧车道，出高速下匝道时也要小心旁边车道强行并线下匝道</li>
<li>因为速度很快，不要急打方向</li>
<li>急刹车的时候看下后视镜，高速上被追尾的死亡率远远大于追尾的</li>
<li>快出高速时最后一公里左右就提前进入最外侧车道，如果路口开过了就下一个口出去再掉头，千万不要强行并线</li>
<li>冲出动物时，宁可直接撞，也别躲！</li>
<li>在高速上发生爆胎，首先稳住方向盘，千万不要猛打方向或踩死刹车</li>
<li>最内侧车道是给快车的，最外侧是给大车的

<h2>停车</h2></li>
<li>打右转向灯提示后方</li>
<li>如果路面有坡，先挂 N 档，再拉手刹，再挂 P 档。</li>
<li>路边停车时前面最好留出距离能让自己出来</li>
<li>车上所有人下车都要注意后面是否来车</li>
<li>车不要停在楼下，停在明处，不要停在角落里

<h2>其他</h2></li>
<li>少开夜车，不仅不安全，而且晚上省出的时间白天还的更多</li>
<li>别人按喇叭催你时千万别着急，否则出了事担责任的是你自己</li>
<li>永远要假设别的车或人都是不规矩的</li>
<li>跟车不要开远光，会车更不要开远光</li>
<li>紧急情况下要踩死刹车才能启动 ABS，并且不要在速度没降下来的时候急打方向</li>
<li>车里面不要摆挂一些东西，防止急刹车砸到人身上</li>
<li>遇到有陌生人询问，车窗开条缝就好</li>
<li>行至偏僻、陌生路段遇拦车的不要停车，下车</li>
<li>车内财物不要直接放在座位上，防止别人砸窗</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从 Objective-C 过渡到 Swift]]></title>
    <link href="https://lijingcheng.github.io/blog/2017/03/17/swift-base/"/>
    <updated>2017-03-17T19:10:37+08:00</updated>
    <id>https://lijingcheng.github.io/blog/2017/03/17/swift-base</id>
    <content type="html"><![CDATA[<p><strong>Swift - 不仅支持面向对象和面向协议开发，同时还支持函数式开发，在使用封装继承多态的同时，也可以用协议去组合代码，还可以利用高阶函数去简化代码、组织程序。</strong></p>

<!-- more -->


<p>面向协议开发不仅可以间接实现多继承，还可以使代码编写过程更加灵活，也能够解决面向对象开发带来的冗杂父类问题，在 Swift 中只有引用类型可以使用面向对象开发的继承功能，而引用类型的实例变量会在程序执行过程中因无意修改导致数据异常，此时可用协议替代继承，并且将引用类型改为值类型，便可以大大提高数据的安全性。</p>

<p>Swift 还是一个强类型语言，类型在运行时和编译期间是一致的，这样编译器可以得到足够的信息在生成中间码和机器码时进行优化，并在编译期间完成方法的绑定，可以直接获取方法地址并进行调用。</p>

<h2>Hello World</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello world!&quot;</span><span class="p">)</span> <span class="c1">// 打印并换行</span>
</span></code></pre></td></tr></table></div></figure>


<h2>数据类型</h2>

<h3>整数</h3>

<p>通常使用 Int 来声明整数就可以了，当为了优化内存占用或要处理接口返回的长度明确的数据等情况时可使用显式指定长度的类型，这样可以及时发现值溢出并增强代码可读性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="nl">age</span><span class="p">:</span> <span class="n">Int</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1">// 常量 age 在 32-bit 平台下为 Int32,在 64-bit 下为 Int64</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">twoThousand</span> <span class="o">=</span> <span class="mi">2</span><span class="n">_000</span> <span class="c1">// 变量 twoThousand 会被编译器自动推断为 Int 类型，并且用 _ 增强可读性</span>
</span></code></pre></td></tr></table></div></figure>


<h3>浮点数</h3>

<p>32/64 位浮点数分别用 Float 和 Double 表示，精度分别为 6/15+ 位数字。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.14159</span> <span class="c1">// 浮点数值总是会被推断为 Double</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="c1">// 自动截断，值为 3</span>
</span><span class='line'><span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="nl">exactly</span><span class="p">:</span> <span class="n">pi</span><span class="p">)</span> <span class="c1">// 要求更为精确的转换，当精度有损失，认为转换失败，值为 nil</span>
</span></code></pre></td></tr></table></div></figure>


<h3>布尔值</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="nl">isChild</span><span class="p">:</span> <span class="n">Bool</span> <span class="o">=</span> <span class="nb">true</span> <span class="c1">// or false</span>
</span></code></pre></td></tr></table></div></figure>


<h3>字符</h3>

<p>Character 类型通常由编码无关的 Unicode 字符组成</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="nl">c</span><span class="p">:</span> <span class="n">Character</span> <span class="o">=</span> <span class="s">&quot;e&quot;</span> <span class="c1">// 如果不指定类型，双引号会被推断为字符串类型</span>
</span></code></pre></td></tr></table></div></figure>


<p>Character 可以由一个或多个 Unicode 标量（Scalar）组成</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="nl">c1</span><span class="p">:</span> <span class="n">Character</span> <span class="o">=</span> <span class="s">&quot;\u{00E9}&quot;</span> <span class="c1">// é</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="nl">c2</span><span class="p">:</span> <span class="n">Character</span> <span class="o">=</span> <span class="s">&quot;\u{0065}\u{0301}&quot;</span> <span class="c1">// e +  ́ = é</span>
</span></code></pre></td></tr></table></div></figure>


<h3>字符串</h3>

<p>Swift 中的 String 是值类型，所以在进行传递时都会进行值拷贝，不用担心会被意外修改。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="nl">str</span><span class="p">:</span> <span class="n">String</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;str: \(str)&quot;</span><span class="p">)</span> <span class="c1">// Swift 会用 str 的值替换占位符 \(str)</span>
</span></code></pre></td></tr></table></div></figure>


<p>给字符串追加字符不一定会更改字符串的字符数量</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="n">word</span> <span class="o">=</span> <span class="s">&quot;cafe&quot;</span> <span class="o">+</span> <span class="s">&quot;\u{301}&quot;</span> <span class="c1">// café</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">characters</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="c1">// 有 4 个 char</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">unicodeScalars</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="c1">// 有 5 个 Unicode Scalar</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 Swift 中不同的字符以及相同字符的不同表示方式可能需要不同数量的内存空间来存储，所以要知道字符的确定位置就必须从 String 开头遍历每一个 Unicode 标量直到结尾。因此 Swift 的字符串不能用整数做索引，而是使用一个关联的索引类型 String.Index，它对应着字符串中每一个字符的位置。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;Guten Tag!&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">[</span><span class="n">greeting</span><span class="p">.</span><span class="n">startIndex</span><span class="p">])</span><span class="c1">// 值为 G，如果用 greeting[0] 会报错</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">greeting</span><span class="p">[</span><span class="n">greeting</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">greeting</span><span class="p">.</span><span class="n">startIndex</span><span class="p">,</span> <span class="nl">offsetBy</span><span class="p">:</span> <span class="mi">7</span><span class="p">)])</span> <span class="c1">// a</span>
</span></code></pre></td></tr></table></div></figure>


<h3>数组</h3>

<p>Array 使用有序列表存储同一类型的多个值，可以存储重复值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="n">array1</span> <span class="o">=</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">()</span> <span class="c1">// 字符串数组</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">array2</span> <span class="o">=</span> <span class="p">[</span><span class="n">String</span><span class="p">]()</span> <span class="c1">// 字符串数组（推荐写法）</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">array3</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="nl">repeating</span><span class="p">:</span> <span class="s">&quot;_&quot;</span><span class="p">,</span> <span class="nl">count</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// 字符串数组，包含3个元素，默认值为 _</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">array4</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;apple&quot;</span><span class="p">,</span> <span class="s">&quot;pen&quot;</span><span class="p">,</span> <span class="s">&quot;apple-pen&quot;</span><span class="p">]</span> <span class="c1">// 自动推断出数组类型为 String</span>
</span><span class='line'><span class="n">array4</span> <span class="o">+=</span> <span class="p">[</span><span class="s">&quot;Pineapple&quot;</span><span class="p">]</span> <span class="c1">// 相同类型数组可以用 + 进行组合</span>
</span><span class='line'><span class="n">array4</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Pen&quot;</span><span class="p">)</span> <span class="c1">// 添加元素</span>
</span><span class='line'><span class="n">array4</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Apple&quot;</span> <span class="c1">// 可以用下标访问和修改数组元素</span>
</span><span class='line'><span class="n">array4</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="mf">.2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Pen&quot;</span><span class="p">,</span> <span class="s">&quot;Apple-Pen&quot;</span><span class="p">]</span> <span class="c1">// 还可以利用下标来一次改变一系列数据值，尽量保证下标区间与值的个数相匹配</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用 for-in 循环来遍历数组中的数据项</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">array4</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果我们同时需要每个数据项的值和索引值，可以使用 enumerated() 来进行数组遍历。enumerated() 返回一个由每一个数据项索引值和数据值组成的元组。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="n">array4</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以嵌套多对方括号来创建多维数组</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="nl">array3D</span><span class="p">:</span> <span class="p">[[[</span><span class="n">Int</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]]</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">array3D</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">array3D</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">array3D</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<h3>集合</h3>

<p>Set 用来存储相同类型并且没有确定顺序的值，不可以存储重复值。一个类型为了存储在集合中必须是可哈希化的，需要确认 Hashable 协议并提供方法来计算它的哈希值，因为 Hashable 符合 Equatable 协议，所以还需要提供 <code>==</code> 的实现。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="n">set1</span> <span class="o">=</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">()</span> <span class="c1">// 与数组不同的是集合的声明没有简化形式</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="nl">set2</span><span class="p">:</span> <span class="n">Set</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;apple&quot;</span><span class="p">,</span> <span class="s">&quot;pen&quot;</span><span class="p">,</span> <span class="s">&quot;apple-pen&quot;</span><span class="p">]</span> <span class="c1">// 如果不指定类型就会被认为是数组</span>
</span><span class='line'><span class="n">set2</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&quot;pineapple&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>按照特定顺序来遍历一个 Set 中的值可以使用 sorted() 方法，它将返回一个有序数组。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">set2</span><span class="p">.</span><span class="n">sorted</span><span class="p">()</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>字典</h3>

<p>Dictionary 用来存储多个相同类型的值，每个值都关联唯一的 key，key 的类型必须遵循 Hashable 协议，字典中的数据项没有具体顺序。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="n">dict1</span> <span class="o">=</span> <span class="n">Dictionary</span><span class="o">&lt;</span><span class="n">Int</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;</span><span class="p">()</span> <span class="c1">// 键是Int型，值是String型</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">dict2</span> <span class="o">=</span> <span class="p">[</span><span class="nl">Int</span><span class="p">:</span> <span class="n">String</span><span class="p">]()</span> <span class="c1">//推荐写法</span>
</span><span class='line'><span class="n">dict2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;lijingcheng&quot;</span> <span class="c1">// key: 3, value: lijingcheng 字典包含 key 时此操作为修改，否则为添加</span>
</span><span class='line'><span class="n">dict2</span> <span class="o">=</span> <span class="p">[</span><span class="o">:</span><span class="p">]</span> <span class="c1">// 赋值为空字典</span>
</span></code></pre></td></tr></table></div></figure>


<p>遍历字典时每一个数据项都以 (key, value) 元组形式返回</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="n">dict2</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>元组</h3>

<p>tuples 可以把多个不同类型的值组合成一个复合值，并且值是有序的，元组不支持 add 和 remove 操作，但是支持修改。元组并不适合创建复杂的数据结构，更适合用于组合少量的多元数据，例如可以在函数中一次返回多个值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">http404Error</span> <span class="o">=</span> <span class="p">(</span><span class="mi">404</span><span class="p">,</span> <span class="s">&quot;Not Found&quot;</span><span class="p">)</span> <span class="c1">// http404Error 的类型是 (Int, String)</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;\(http404Error.0), \(http404Error.1).&quot;</span><span class="p">)</span> <span class="c1">// 用下标访问元组</span>
</span></code></pre></td></tr></table></div></figure>


<p>定义元组时给单个元素命名，然后通过名字来获取元素的值</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">http200Status</span> <span class="o">=</span> <span class="p">(</span><span class="nl">statusCode</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span> <span class="nl">description</span><span class="p">:</span> <span class="s">&quot;OK&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;\(http200Status.statusCode), \(http200Status.description).&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>将元组的内容分解为常量</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="p">(</span><span class="n">statusCode</span><span class="p">,</span> <span class="n">statusMessage</span><span class="p">)</span> <span class="o">=</span> <span class="n">http404Error</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;\(statusCode), \(statusMessage).&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>元组支持嵌套</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">userInfo</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;lijingcheng&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;male&quot;</span><span class="p">,</span> <span class="s">&quot;Mtime&quot;</span><span class="p">),</span> <span class="p">[</span><span class="s">&quot;obj1&quot;</span><span class="p">,</span> <span class="s">&quot;obj2&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s">&quot;key&quot;</span><span class="o">:</span> <span class="s">&quot;value&quot;</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>不使用额外空间就能交换两个值</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">swap</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span> <span class="k">inout</span> <span class="n">T</span><span class="p">,</span> <span class="nl">b</span><span class="p">:</span> <span class="k">inout</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Optional</h3>

<p>在声明变量时可以用可选类型来处理值可能为 nil 的情况，可选类型也可用于函数参数和函数返回值。（Swift 中 nil 不是指针，它是一个确定的值，可用来表示任何类型变量的值缺失）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="nl">possibleNumber</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span> <span class="o">=</span> <span class="s">&quot;123&quot;</span> <span class="c1">// String? 也可以写成 Optional&lt;String&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 使用可选绑定来判断可选类型是否为空</span>
</span><span class='line'><span class="k">if</span> <span class="k">let</span> <span class="n">num</span> <span class="o">=</span> <span class="n">possibleNumber</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="n">possibleNumber</span><span class="o">!</span><span class="p">)</span> <span class="c1">// 强制解析可选类型 possibleNumber，如果值为 nil 则会报错</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>当确定可选类型变量有值的情况下，可以用隐式解析可选类型来定义这个变量来避免每次使用前的 if 判断，以提高效率。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="nl">assumedString</span><span class="p">:</span> <span class="n">String</span><span class="o">!</span> <span class="o">=</span> <span class="s">&quot;An implicitly unwrapped optional string.&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">assumedString</span><span class="p">)</span> <span class="c1">// 不需要强制解析</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Any</h3>

<p>Any 相当于 Objective-C 中的 id，它可以表示任何类型，包括函数类型，AnyObject 可以表示任何类类型的实例。可以用类型检查操作符 is 来检查一个实例是否属于特定类型，就像 Objective-C 中的 isKindOf 方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="nl">things</span><span class="p">:</span> <span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">42</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="k">in</span> <span class="s">&quot;Hello, \(name)&quot;</span> <span class="p">}]</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">things</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 用 as? 进行类型转换，如果用 as! 来强制转换，当转换失败时会在运行时报错</span>
</span><span class='line'>    <span class="k">if</span> <span class="k">let</span> <span class="n">intValue</span> <span class="o">=</span> <span class="n">item</span> <span class="kt">as</span><span class="o">?</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;intValue: \(intValue)&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 因为可选值有可能为 nil，所在再往数组里放时会有警告，避免出现警告可用下面两种方式</span>
</span><span class='line'><span class="k">let</span> <span class="nl">optionalNumber</span><span class="p">:</span> <span class="n">Int</span><span class="o">?</span> <span class="o">=</span> <span class="mi">3</span>
</span><span class='line'><span class="n">things</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">optionalNumber</span> <span class="o">??</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'><span class="n">things</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">optionalNumber</span> <span class="kt">as</span> <span class="n">Any</span><span class="p">)</span> <span class="c1">// Int to Any</span>
</span></code></pre></td></tr></table></div></figure>


<h2>运算符</h2>

<p>Swift 支持大部分标准 C 语言的运算符，并改进许多特性来减少常规编码错误。</p>

<h3>赋值运算符</h3>

<p>Swift 的赋值操作不返回任何值，所以无法把 == 错写成 =，下面代码会在编译时报错</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>算术运算符</h3>

<p>没有自增和自减运算符，加法运算符可用于字符串拼接</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&quot;hello, &quot;</span> <span class="o">+</span> <span class="s">&quot;world&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>比较运算符</h3>

<p>字符、字符串、元组等值类型值可以用 <code>&lt;</code> <code>&gt;</code> <code>==</code> 和 <code>!=</code> 来进行比较</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">if</span> <span class="s">&quot;apple&quot;</span> <span class="o">==</span> <span class="s">&quot;pen&quot;</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>三目运算符</h3>

<p>不支持下面这种写法</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="n">i</span> <span class="o">=</span> <span class="n">num</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="o">?</span> <span class="o">:</span> <span class="mi">3</span>
</span></code></pre></td></tr></table></div></figure>


<h3>空合运算符</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="nl">colorName</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">colorName</span> <span class="o">??</span> <span class="s">&quot;red&quot;</span><span class="p">)</span> <span class="c1">// red</span>
</span></code></pre></td></tr></table></div></figure>


<h3>区间运算符</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">.</span><span class="mf">.5</span> <span class="p">{}</span> <span class="c1">// 闭区间运算符</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Anna&quot;</span><span class="p">,</span> <span class="s">&quot;Alex&quot;</span><span class="p">,</span> <span class="s">&quot;Brian&quot;</span><span class="p">,</span> <span class="s">&quot;Jack&quot;</span><span class="p">]</span>
</span><span class='line'><span class="k">let</span> <span class="n">count</span> <span class="o">=</span> <span class="n">names</span><span class="p">.</span><span class="n">count</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.</span><span class="o">&lt;</span><span class="n">count</span> <span class="p">{}</span> <span class="c1">// 半开区间运算符</span>
</span></code></pre></td></tr></table></div></figure>


<h3>恒等运算符</h3>

<p>Swift 提供了恒等 <code>===</code> 和不恒等 <code>!==</code> 两个比较符来判断类的两个对象是否引用同一个实例，而 <code>==</code> 则是用来比较两个实例的值是否相同。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">if</span> <span class="n">tenEighty</span> <span class="o">===</span> <span class="n">alsoTenEighty</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>溢出运算符</h3>

<p>Swift 会在数值溢出时报错，也可以通过溢出运算符在数值溢出的时候采取截断处理。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="n">upOverflow</span> <span class="o">=</span> <span class="kt">UInt8</span><span class="p">.</span><span class="n">max</span> <span class="o">&amp;+</span> <span class="mi">1</span> <span class="c1">// 上溢运算 0</span>
</span><span class='line'><span class="k">var</span> <span class="n">downOverflow</span> <span class="o">=</span> <span class="kt">UInt8</span><span class="p">.</span><span class="n">min</span> <span class="o">&amp;-</span> <span class="mi">1</span> <span class="c1">// 下溢运算 255</span>
</span></code></pre></td></tr></table></div></figure>


<h2>控制流</h2>

<h3>if-else</h3>

<p>条件语句中的小括号可以省略，并加强了类型安全检查，不能够再用整型参与 Bool 判断</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">if</span> <span class="mi">1</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>guard</h3>

<p>当 guard 语句为真时执行 guard 语句下面的代码，使用 guard 做基本的安全检查能有效减少函数中的嵌套数量，并提高代码可读性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">hello</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">guard</span> <span class="n">name</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello \(name!)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>switch</h3>

<p>Swift 中的 switch 语句在进行数值匹配时除了支持整型和字符，还支持浮点数、字符串、元组、枚举等类型，并且 case 语句不能有遗漏，如果不愿写太多 case 可用 default 分支满足需求。当匹配的 case 分支中的代码执行完毕后，程序会终止 switch 语句，避免了因忘记写 break 而产生的错误，break 语句可以用于逻辑性的跳出 switch。如果希望能够在执行完 case 中的代码后向下掉落则需要使用 fallthrough。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&quot;e&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">switch</span> <span class="n">str</span> <span class="p">{</span>
</span><span class='line'><span class="k">case</span> <span class="s">&quot;a&quot;</span><span class="o">:</span>
</span><span class='line'>    <span class="k">break</span>
</span><span class='line'><span class="k">case</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;B&quot;</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;b or B&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">case</span> <span class="s">&quot;c&quot;</span><span class="p">...</span><span class="s">&quot;e&quot;</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;c - e&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">fallthrough</span>
</span><span class='line'><span class="k">default</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;default...&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>用 switch 语句匹配元组的值</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">somePoint</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">switch</span> <span class="n">somePoint</span> <span class="p">{</span>
</span><span class='line'><span class="k">case</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;(0, 0)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">case</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="c1">// 只匹配 y，x 可以是任何值</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;(\(somePoint.0), 0)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">case</span> <span class="p">(</span><span class="o">-</span><span class="mf">2.</span><span class="p">.</span><span class="mf">.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">.</span><span class="mf">.2</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;(\(somePoint.0), \(somePoint.1))&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">case</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">let</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span> <span class="c1">// 只匹配 x，并且将 y 的值赋给常量 y</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;0, \(y)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">case</span> <span class="k">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">where</span> <span class="n">x</span> <span class="o">==</span> <span class="nl">y</span><span class="p">:</span> <span class="c1">// 通过 where 来进行匹配</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;\(x) == \(y)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">case</span> <span class="k">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;(\(x), \(y))&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>for-in</h3>

<p>如果不需要区间序列内每一项的值，可以使用下划线 _ 替代变量名来忽略这个值</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;apple&quot;</span><span class="p">,</span> <span class="s">&quot;pen&quot;</span><span class="p">,</span> <span class="s">&quot;apple-pen&quot;</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="n">array</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>while</h3>

<p>while 条件语句中的小括号可以省略，do-while 变成 repeat-while</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">repeat</span> <span class="p">{}</span> <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span>
</span></code></pre></td></tr></table></div></figure>


<h2>函数与闭包</h2>

<h3>函数</h3>

<p>Swift 是类型安全的，所以支持参数个数相同但类型不同的函数重载</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="n">hello</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s">&quot;Hello, &quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">func</span> <span class="n">hello</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s">&quot;Hello, &quot;</span> <span class="o">+</span> <span class="n">String</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">hello</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Lee&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">hello</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>没有返回值的函数其实是返回了一个特殊的 Void 值，它是一个空的元组，可用()表示</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">greet</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="k">func</span> <span class="nf">greet</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="k">func</span> <span class="n">greet</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Void</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p>参数名称默认作为参数标签来使用，我们可以自定义参数标签，也可以用 _ 来忽略参数标签，Swift 支持为参数指定默认值，为了代码可读性考虑，一般将带默认值的参数放在参数列表的最后面</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="n">say</span><span class="p">(</span><span class="n">_</span> <span class="nl">prefixStr</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">parameterLabel</span> <span class="nl">parameterName</span><span class="p">:</span> <span class="n">String</span> <span class="o">=</span> <span class="s">&quot;lijingcheng&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">prefixStr</span> <span class="o">+</span> <span class="n">parameterName</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">say</span><span class="p">(</span><span class="s">&quot;hello, &quot;</span><span class="p">,</span> <span class="nl">parameterLabel</span><span class="p">:</span> <span class="s">&quot;lijingcheng&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">say</span><span class="p">(</span><span class="s">&quot;hello, &quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>一个函数最多只能拥有一个可变参数，可变参数可以接受零个或多个值</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="n">total</span><span class="p">(</span><span class="n">_</span> <span class="nl">numbers</span><span class="p">:</span> <span class="n">Double</span><span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Double</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">total</span><span class="p">:</span> <span class="n">Double</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">numbers</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">total</span> <span class="o">+=</span> <span class="n">number</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">total</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">total</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>函数参数默认是常量，如果要修改参数的值，可以将参数定义为输入输出参数。输入输出参数不能有默认值，而且可变参数不能用 inout 标记。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">swapTwoInts</span><span class="p">(</span><span class="n">_</span> <span class="nl">a</span><span class="p">:</span> <span class="k">inout</span> <span class="n">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nl">b</span><span class="p">:</span> <span class="k">inout</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">temporaryA</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">temporaryA</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">someInt</span> <span class="o">=</span> <span class="mi">3</span>
</span><span class='line'><span class="k">var</span> <span class="n">anotherInt</span> <span class="o">=</span> <span class="mi">107</span>
</span><span class='line'><span class="n">swapTwoInts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">someInt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anotherInt</span><span class="p">)</span> <span class="c1">// &amp; 对于值类型来说 inout 相当于在函数内部创建了一个新值，然后在函数返回时将这个值赋给 &amp; 修饰的变量，这与引用类型是不一样的。</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;someInt is now \(someInt), and anotherInt is now \(anotherInt)&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>Swift 支持我们用函数式思维来写代码，函数也作为语言的一等公民，函数其实也是一种值，Swift 支持函数类型的变量或常量，可以将函数以参数的形式传给其它函数，并且可以将一个函数作为返回值使用，还支持嵌套函数，通常称这种函数为高阶函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">addTwoInts</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="nl">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">addMathFunction</span> <span class="o">=</span> <span class="n">addTwoInts</span> <span class="c1">// 类型为：(Int, Int) -&gt; Int</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">addMathFunction</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">// print: 5</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">func</span> <span class="n">printMathResult</span><span class="p">(</span><span class="n">_</span> <span class="nl">mathFunction</span><span class="p">:</span> <span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nl">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nl">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="n">mathFunction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">printMathResult</span><span class="p">(</span><span class="n">addMathFunction</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// print: 8</span>
</span></code></pre></td></tr></table></div></figure>


<p>函数的柯里化(Currying)是指把接受多个参数的方法变换成接受第一个参数的方法，并且返回接受余下的参数并且返回结果的新方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="n">addTo</span><span class="p">(</span><span class="n">_</span> <span class="nl">adder</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">{</span> <span class="n">num</span> <span class="k">in</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">num</span> <span class="o">+</span> <span class="n">adder</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">addTwo</span> <span class="o">=</span> <span class="n">addTo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// 变量接收的函数会将 2 作为递增数</span>
</span><span class='line'><span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">addTwo</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="c1">// 调用函数，将 6 与预先设置的 2 相加</span>
</span></code></pre></td></tr></table></div></figure>


<p>把函数定义在别的函数体中称作嵌套函数，下面例子中 incrementBySeven 和 incrementByTen 都是常量，但是他们指向的函数仍然可以增加其捕获的变量的值。这是因为函数和闭包都是引用类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="n">makeIncrementer</span><span class="p">(</span><span class="n">forIncrement</span> <span class="nl">amount</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">runningTotal</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="k">func</span> <span class="n">incrementer</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">runningTotal</span> <span class="o">+=</span> <span class="n">amount</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">runningTotal</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">incrementer</span> <span class="c1">// 返回内部函数</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">incrementByTen</span> <span class="o">=</span> <span class="n">makeIncrementer</span><span class="p">(</span><span class="nl">forIncrement</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">// incrementByTen 为函数类型变量，并且无参，返回 Int</span>
</span><span class='line'><span class="n">incrementByTen</span><span class="p">()</span> <span class="c1">// return 10</span>
</span><span class='line'><span class="n">incrementByTen</span><span class="p">()</span> <span class="c1">// return 20</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//如果你创建了另一个 incrementer，它会有属于自己的引用，指向一个全新、独立的 runningTotal 变量：incrementBySeven 和 incrementByTen 没有任何联系</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">incrementBySeven</span> <span class="o">=</span> <span class="n">makeIncrementer</span><span class="p">(</span><span class="nl">forIncrement</span><span class="p">:</span> <span class="mi">7</span><span class="p">)</span>
</span><span class='line'><span class="n">incrementBySeven</span><span class="p">()</span> <span class="c1">// return 7</span>
</span><span class='line'><span class="n">incrementBySeven</span><span class="p">()</span> <span class="c1">// return 14</span>
</span><span class='line'>
</span><span class='line'><span class="n">incrementByTen</span><span class="p">()</span> <span class="c1">// return 30</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>闭包</h3>

<p>闭包是自包含的函数代码块，可以在代码中被传递和使用，闭包可以捕获和存储其所在上下文中任意常量和变量的引用，即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p>

<p>全局函数和嵌套函数实际上也是特殊的闭包，全局函数是一个有名字但不会捕获任何值的闭包，嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包。闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Chris&quot;</span><span class="p">,</span> <span class="s">&quot;Alex&quot;</span><span class="p">,</span> <span class="s">&quot;Ewa&quot;</span><span class="p">,</span> <span class="s">&quot;Barry&quot;</span><span class="p">,</span> <span class="s">&quot;Daniella&quot;</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">names</span><span class="p">.</span><span class="n">sorted</span><span class="p">(</span><span class="nl">by</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="nl">s1</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">s2</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="k">in</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">s1</span> <span class="o">&lt;</span> <span class="n">s2</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift 可以根据闭包接收的参数和返回值推断出参数和返回值的类型，所以可以简写为下面形式，很短的函数体可以写成一行，单行表达式闭包可以省略 return，不过完整形式的闭包具有更好的代码可读性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">names</span><span class="p">.</span><span class="n">sorted</span><span class="p">(</span><span class="nl">by</span><span class="p">:</span> <span class="p">{</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="k">in</span> <span class="n">s1</span> <span class="o">&lt;</span> <span class="n">s2</span> <span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>闭包的参数列表也可以省略，可以用 $0，$1，$2 来顺序调用闭包的参数</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">names</span><span class="p">.</span><span class="n">sorted</span><span class="p">(</span><span class="nl">by</span><span class="p">:</span> <span class="p">{</span><span class="err">$</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="err">$</span><span class="mi">1</span><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>Swift 的 String 重载了 > 用于比较两个字符串并返回大小，所以 sorted 函数还可以直接将 &lt; 当作闭包处理</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">names</span><span class="p">.</span><span class="n">sorted</span><span class="p">(</span><span class="nl">by</span><span class="p">:</span> <span class="o">&lt;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果闭包表达式是函数的唯一参数，则可以作为尾随闭包来使用，以增强函数的可读性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">names</span><span class="p">.</span><span class="n">sorted</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="k">in</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">s1</span> <span class="o">&lt;</span> <span class="n">s2</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>当定义接受闭包作为参数的函数时，可以用 @escaping 来标注参数名称，用来指明这个闭包是允许“逃逸”出这个函数的，这样我们就可以用一个变量或常量来接收闭包，并在适当的时候调用它，如果将一个闭包标记为 @escaping 意味着你必须在闭包中显式地引用 self。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">var</span> <span class="n">closures</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="k">func</span> <span class="n">someFunctionWithEscapingClosure</span><span class="p">(</span><span class="nl">completionHandler</span><span class="p">:</span> <span class="p">@</span><span class="n">escaping</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">closures</span> <span class="o">=</span> <span class="n">completionHandler</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">customersInLine</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Chris&quot;</span><span class="p">,</span> <span class="s">&quot;Alex&quot;</span><span class="p">,</span> <span class="s">&quot;Ewa&quot;</span><span class="p">,</span> <span class="s">&quot;Barry&quot;</span><span class="p">,</span> <span class="s">&quot;Daniella&quot;</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">someFunctionWithEscapingClosure</span> <span class="p">{</span> <span class="n">customersInLine</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="nl">at</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">customersInLine</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="c1">// print: 5</span>
</span><span class='line'><span class="n">closures</span><span class="p">()</span> <span class="c1">// 执行闭包</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">customersInLine</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="c1">// print: 4</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>枚举</h2>

<p>Swift 的枚举成员在被创建时不会被赋予一个默认的整型值，枚举成员本身就是完备的值，多个成员值可以用逗号分隔并定义在一行上</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">enum</span> <span class="n">CompassPoint</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">north</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">west</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">directionToHead</span> <span class="o">=</span> <span class="n">CompassPoint</span><span class="p">.</span><span class="n">west</span>
</span><span class='line'><span class="n">directionToHead</span> <span class="o">=</span> <span class="p">.</span><span class="n">east</span> <span class="c1">// 当 directionToHead 的类型已知时，再次为其赋值可以省略枚举类型名</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>枚举成员虽然没有默认值，但是可以给它指定原始值，类型可以是字符串、字符、整型、浮点数，这些原始值一旦设置了就不能再改变，并且值在枚举声明中必须是唯一的而且类型必须相同，使用枚举成员的 rawValue 属性可以访问该成员的原始值。在使用原始值为整数或者字符串类型的枚举时，通常不需要显式地为每一个枚举成员设置原始值，Swift 会自动赋值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">enum</span> <span class="nl">CompassPoint2</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">north</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">west</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">sunsetDirection2</span> <span class="o">=</span> <span class="n">CompassPoint2</span><span class="p">.</span><span class="n">west</span><span class="p">.</span><span class="n">rawValue</span> <span class="c1">// “west”</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>当使用整数作为原始值时，隐式赋值的值依次递增1。如果第一个枚举成员没有设置原始值，其原始值将为0。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">enum</span> <span class="nl">CompassPoint3</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">north</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">west</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">earthsOrder</span> <span class="o">=</span> <span class="n">CompassPoint3</span><span class="p">.</span><span class="n">east</span><span class="p">.</span><span class="n">rawValue</span> <span class="c1">// 3</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个叫做 rawValue 的参数，参数类型即为原始值类型，返回值则是枚举成员或 nil。</span>
</span><span class='line'><span class="k">let</span> <span class="n">possiblePlanet</span> <span class="o">=</span> <span class="n">CompassPoint3</span><span class="p">(</span><span class="nl">rawValue</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// south</span>
</span><span class='line'><span class="k">let</span> <span class="n">possiblePlanet2</span> <span class="o">=</span> <span class="n">CompassPoint3</span><span class="p">(</span><span class="nl">rawValue</span><span class="p">:</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">// nil</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>如果不为枚举成员指定原始值，那么就可以指定任意类型的关联值存储到枚举成员中，每个枚举成员都可以有不同类型的关联值，并且关联值可以修改。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">enum</span> <span class="n">Barcode</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">upc</span><span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="n">Int</span><span class="p">,</span> <span class="n">Int</span><span class="p">,</span> <span class="n">Int</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">qrCode</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">productBarcode</span> <span class="o">=</span> <span class="n">Barcode</span><span class="p">.</span><span class="n">upc</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">85909</span><span class="p">,</span> <span class="mi">51226</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// .upc关联的元组值为(8, 85909, 51226, 3)。</span>
</span><span class='line'><span class="n">productBarcode</span> <span class="o">=</span> <span class="p">.</span><span class="n">qrCode</span><span class="p">(</span><span class="s">&quot;ABCDEFGHIJKLMNOP&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//关联值可以被提取出来作为 switch 语句的一部分。你可以在switch的 case 分支代码中提取每个关联值作为一个常量（用let前缀）或者作为一个变量（用var前缀）来使用：</span>
</span><span class='line'><span class="k">switch</span> <span class="n">productBarcode</span> <span class="p">{</span>
</span><span class='line'><span class="k">case</span> <span class="p">.</span><span class="n">upc</span><span class="p">(</span><span class="k">let</span> <span class="n">numberSystem</span><span class="p">,</span> <span class="k">let</span> <span class="n">manufacturer</span><span class="p">,</span> <span class="k">let</span> <span class="n">product</span><span class="p">,</span> <span class="k">let</span> <span class="n">check</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;UPC: \(numberSystem), \(manufacturer), \(product), \(check).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">case</span> <span class="p">.</span><span class="n">qrCode</span><span class="p">(</span><span class="k">let</span> <span class="n">productCode</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;QR code: \(productCode).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，你可以只在成员名称前标注一个let或者var：</span>
</span><span class='line'><span class="k">switch</span> <span class="n">productBarcode</span> <span class="p">{</span>
</span><span class='line'><span class="k">case</span> <span class="k">let</span> <span class="p">.</span><span class="n">upc</span><span class="p">(</span><span class="n">numberSystem</span><span class="p">,</span> <span class="n">manufacturer</span><span class="p">,</span> <span class="n">product</span><span class="p">,</span> <span class="n">check</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;UPC: \(numberSystem), \(manufacturer), \(product), \(check).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">case</span> <span class="k">let</span> <span class="p">.</span><span class="n">qrCode</span><span class="p">(</span><span class="n">productCode</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;QR code: \(productCode).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>类和结构体</h2>

<p>Swift 中的所有的基本类型和枚举都是值类型，它们在底层都是以结构体的形式所实现，所以结构体是值类型，类是引用类型。值类型数据在进行函数传递时会被拷贝，引用类型不会。当定义数据结构的目的是用来封装简单的数据值，并且希望该数据结构在被赋值或传递时，封装的数据及其内部存储的属性也能够通过值传递，那么适合用结构体来定义它。</p>

<p>Swift 中类和结构体都支持属性、方法、下标、构造器、扩展和协议，与结构体相比，类还支持继承、多态、用析构器释放所分配资源以及用引用计数对一个类进行多次引用。另外引用类型对象存储在堆上，值类型在栈上，栈的操作仅仅是指针的上下移动，而堆的操作会因内存的分配和回收产生合并、移位、重新链接等行为，所以使用结构体效率会高一些。另外值类型在复制时，复制的对象和原对象实际上在内存中指向同一个对象。只有当复制后的对象被修改时才会在内存中重新创建一个新的对象，通过 copy-on-write 这种的方式提高效率。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">struct</span> <span class="n">Range</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Objective-C 和 Swift 中的属性定义其实都是 setter/getter 方法的声明，其背后还对应一个实例变量，但是在 Swift 中不能直接访问。在 Swift 中属性默认为 nonatomic 和 strong，可改用 weak var ...</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">location</span><span class="p">:</span> <span class="n">Int</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">length</span><span class="p">:</span> <span class="n">Int</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 函数与某个类型相关联后通常称为方法，结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改。但是可以为这个方法选择可变(mutating)行为，然后就可以从其方法内部改变它的属性，甚至修改 self （引用类型可以直接修改）</span>
</span><span class='line'>    <span class="kr">mutating</span> <span class="k">func</span> <span class="n">moveBy</span><span class="p">(</span><span class="n">_</span> <span class="nl">step</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">location</span> <span class="o">+=</span> <span class="n">step</span> <span class="c1">// 通常只有当属性和参数名称一样时才用 self. 方式进行赋值</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">range</span> <span class="o">=</span> <span class="n">Range</span><span class="p">(</span><span class="nl">location</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nl">length</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// 所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性，类实例没有。因为结构体属于值类型。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量，并且 mutating 方法也不可以被调用。</span>
</span><span class='line'><span class="n">range</span><span class="p">.</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1">// Swift 允许直接设置结构体属性的子属性，Objective-C 不可以（例:self.frame.size.width = 10）</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">location</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">range</span><span class="p">.</span><span class="n">moveBy</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">location</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>存储属性可存储常量或变量作为实例的一部分，只能用于类和结构体。计算属性提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值，计算属性可以用于类、结构体和枚举。</p>

<p>可以通过重写属性的方式为继承的属性添加属性观察器，但不包括常量存储型属性和只读计算型属性。父类的属性在子类的构造器中被赋值时，父类会先响应。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="p">{</span> <span class="c1">// 直接赋值或通过构造器赋值时不会触发 KVO，弱引用对象变成 nil 时也不会触发 KVO，并且不能对延迟存储做 KVO</span>
</span><span class='line'>        <span class="kr">willSet</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">print</span><span class="p">(</span><span class="n">newValue</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="kr">didSet</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">print</span><span class="p">(</span><span class="n">oldValue</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Size</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">width</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Rect</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">origin</span> <span class="o">=</span> <span class="n">Point</span><span class="p">()</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">size</span> <span class="o">=</span> <span class="n">Size</span><span class="p">()</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">center</span><span class="p">:</span> <span class="n">Point</span> <span class="p">{</span> <span class="c1">// 必须用 var 定义，因为值不是固定的</span>
</span><span class='line'>        <span class="kr">get</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">let</span> <span class="n">centerX</span> <span class="o">=</span> <span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>            <span class="k">let</span> <span class="n">centerY</span> <span class="o">=</span> <span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="n">centerX</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="n">centerY</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="kr">set</span><span class="p">(</span><span class="n">newCenter</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称 newValue</span>
</span><span class='line'>            <span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">newCenter</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>            <span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">newCenter</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// 只读计算属性，只有 get，并且可以去掉 get 关键字</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">width</span><span class="p">:</span> <span class="n">Double</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">var</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">(</span><span class="nl">origin</span><span class="p">:</span> <span class="n">Point</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mi">2</span><span class="p">),</span> <span class="nl">size</span><span class="p">:</span> <span class="n">Size</span><span class="p">(</span><span class="nl">width</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="nl">height</span><span class="p">:</span> <span class="mi">10</span><span class="p">))</span>
</span><span class='line'><span class="n">frame</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 Objective-C 中，与类关联的静态常量或静态变量是全局的，但在 Swift 中，它的作用范围就在类型支持的范围内。</p>

<p>下标可以定义在类、结构体和枚举中，是访问集合，列表或序列中元素的快捷方式。一个类型可以定义多个下标，并通过不同索引类型进行重载。下标不限于一维，可以定义具有多个入参的下标满足自定义类型的需求。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">struct</span> <span class="n">Tyre</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">let</span> <span class="nl">row</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="nl">column</span><span class="p">:</span> <span class="n">Int</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="n">Car</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">tyre</span> <span class="o">=</span> <span class="p">[</span><span class="n">Tyre</span><span class="p">(</span><span class="nl">row</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nl">column</span><span class="p">:</span> <span class="mi">0</span><span class="p">),</span> <span class="n">Tyre</span><span class="p">(</span><span class="nl">row</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nl">column</span><span class="p">:</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Tyre</span><span class="p">(</span><span class="nl">row</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nl">column</span><span class="p">:</span> <span class="mi">0</span><span class="p">),</span> <span class="n">Tyre</span><span class="p">(</span><span class="nl">row</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nl">column</span><span class="p">:</span> <span class="mi">1</span><span class="p">)]</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">lazy</span> <span class="k">var</span> <span class="n">allComponentNames</span> <span class="o">=</span> <span class="n">Car</span><span class="p">.</span><span class="n">getAllComponentName</span><span class="p">()</span> <span class="c1">// 必须将延迟存储属性声明成变量，因为属性的初始值可能在实例构造完成之后才会得到，全局的常量或变量都是延迟计算的。</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">static</span> <span class="k">var</span> <span class="n">description</span> <span class="o">=</span> <span class="s">&quot;Car&quot;</span> <span class="c1">// 类属性无法被子类重写，class 修饰的属性可以被子类重写，但是只能用来修饰计算属性。</span>
</span><span class='line'>    <span class="k">static</span> <span class="k">func</span> <span class="n">getAllComponentName</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">String</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[]</span> <span class="p">}</span> <span class="c1">// static 换成 class 则子类可以重写该方法</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">subscript</span><span class="p">(</span><span class="nl">row</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="nl">column</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tyre</span> <span class="p">{</span> <span class="c1">// car[0, 1]</span>
</span><span class='line'>        <span class="kr">get</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">tyre</span><span class="p">[(</span><span class="n">row</span> <span class="o">*</span> <span class="n">column</span><span class="p">)</span> <span class="o">+</span> <span class="n">column</span><span class="p">]</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="kr">set</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">tyre</span><span class="p">[(</span><span class="n">row</span> <span class="o">*</span> <span class="n">column</span><span class="p">)</span> <span class="o">+</span> <span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">newValue</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">car</span> <span class="o">=</span> <span class="n">Car</span><span class="p">()</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">car</span><span class="p">.</span><span class="n">tyre</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'><span class="n">car</span><span class="p">.</span><span class="n">tyre</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tyre</span><span class="p">(</span><span class="nl">row</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="nl">column</span><span class="p">:</span> <span class="mi">100</span><span class="p">)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">car</span><span class="p">.</span><span class="n">tyre</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。如果结构体或类的所有属性都有默认值，同时没有自定义的构造器，那么 Swift 会提供一个默认构造器。与 Objective-C 中的构造器不同，Swift 的构造器无需返回值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">class</span> <span class="n">User</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">10</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">var</span> <span class="n">item</span> <span class="o">=</span> <span class="n">User</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>可以将继承来的只读属性通过提供 getter/setter 重写为一个读写属性，但是不可以将继承来的读写属性重写为一个只读属性。</p>

<p>如果为值类型定义了构造器，将无法访问到他的默认构造器。这种限制可以防止你为值类型增加了一个额外的且十分复杂的构造器之后，仍然有人错误的使用自动生成的构造器，如果希望他们能同时使用，可以将自定义的构造器写到扩展中。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">// Swift 中的类没有通用基类</span>
</span><span class='line'><span class="k">class</span> <span class="n">Person</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">age</span><span class="p">:</span> <span class="n">Int</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">gender</span> <span class="o">=</span> <span class="s">&quot;male&quot;</span> <span class="c1">// 尽量为属性设置默认值，不仅代码可读性好，还可以在属性很多时减少构造器参数的个数</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span> <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">func</span> <span class="n">sayHello</span><span class="p">()</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;person: hello!&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">deinit</span> <span class="p">{</span> <span class="c1">// 析构器只适用于类类型，用法与 ARC 下的 dealloc() 一样 }</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 用 final 修饰的类不能被继承，用 final 修饰方法、属性、下标，则它们不能被重写。</span>
</span><span class='line'><span class="n">final</span> <span class="k">class</span> <span class="nl">Employee</span><span class="p">:</span> <span class="n">Person</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">company</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">position</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 重写父类的指定构造器</span>
</span><span class='line'>    <span class="kr">override</span> <span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">company</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
</span><span class='line'>
</span><span class='line'>        <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 指定构造器将初始化类中提供的所有属性，并必须调用其直接父类的的指定构造器来实现父类的初始化。每一个类都必须拥有至少一个指定构造器。</span>
</span><span class='line'>    <span class="k">init</span><span class="p">(</span><span class="nl">company</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="nl">position</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">company</span> <span class="o">=</span> <span class="n">company</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">position</span>
</span><span class='line'>
</span><span class='line'>        <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 当参数很多时可用便利构造器辅助指定构造器初始化对象，它必须调用同类中的其它构造器，并必须最终导致一个指定构造器被调用</span>
</span><span class='line'>    <span class="n">convenience</span> <span class="k">init</span><span class="p">(</span><span class="nl">company</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">company</span><span class="p">:</span> <span class="n">company</span><span class="p">,</span> <span class="nl">position</span><span class="p">:</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 缺少 override 的重写会在编译时报错，这样可以避免意外重写。</span>
</span><span class='line'>    <span class="kr">override</span> <span class="k">func</span> <span class="n">sayHello</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">super</span><span class="p">.</span><span class="n">sayHello</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;employee: hello!&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">var</span> <span class="n">item2</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;xx&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>可以用非可失败构造器重写可失败构造器，但反过来不行。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">struct</span> <span class="n">Animal</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">let</span> <span class="nl">species</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// init? 表示可能会构造失败返回 nil</span>
</span><span class='line'>    <span class="k">init</span><span class="o">?</span><span class="p">(</span><span class="nl">species</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">species</span><span class="p">.</span><span class="n">isEmpty</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nb">nil</span> <span class="c1">// 通常构造函数不用 return，唯一用到的情景就是表示构造失败</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">species</span> <span class="o">=</span> <span class="n">species</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">someCreature</span> <span class="o">=</span> <span class="n">Animal</span><span class="p">(</span><span class="nl">species</span><span class="p">:</span> <span class="s">&quot;Giraffe&quot;</span><span class="p">)</span> <span class="c1">// someCreature 的类型是 Animal? 而不是 Animal</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="k">let</span> <span class="n">giraffe</span> <span class="o">=</span> <span class="n">someCreature</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;An animal was initialized with a species of \(giraffe.species)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>在类的构造器前添加 required 修饰符表明所有该类的子类都必须实现该构造器</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">class</span> <span class="n">SomeClass5</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">required</span> <span class="k">init</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nl">SomeSubclass</span><span class="p">:</span> <span class="n">SomeClass5</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">required</span> <span class="k">init</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 必须也用 required 应用于继承链后面的子类</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>访问控制</h3>

<p>Swift 中的访问控制模型基于模块和源文件这两个概念，并为代码中的实体提供了五种不同的访问级别。</p>

<ul>
<li>open：可以被任何模块访问、继承和重写。</li>
<li>public：可以被任何模块访问，但只能被所定义模块中的类继承和重写。</li>
<li>internal(默认)：只能被所定义的模块内部访问。</li>
<li>fileprivate：只能被所定义的文件内部访问。</li>
<li>private：只能在所定义的作用域内使用。</li>
</ul>


<p>类的访问级别会影响到类成员的默认访问级别，不可以在某个实体中定义访问级别更低的东西。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">public</span> <span class="k">var</span> <span class="nl">xx</span><span class="p">:</span> <span class="n">SomePrivateClass</span><span class="o">?</span> <span class="c1">// xx 虽然可以被外界访问，但类是私有的，所以没意义</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">private</span><span class="p">(</span><span class="kr">set</span><span class="p">)</span> <span class="k">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span> <span class="c1">// name 只能被内部修改，但可以被外部访问</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果想要在测试 target 中访问模块中所有内部级别的实体，可以在导入模块前使用 @testable，然后修改模块的编译设置项 Build Options -> Enable Testability。</p>

<h3>元类型</h3>

<p>元类型是指类型的类型，类、结构体或枚举类型的元类型是相应的类型名后紧跟 <code>.Type</code>，协议的元类型是该协议名字紧跟 <code>.Protocol</code>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">class</span> <span class="n">AnotherSubClass</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">let</span> <span class="nl">str</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">required</span> <span class="k">init</span><span class="p">(</span><span class="nl">str</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">str</span> <span class="o">=</span> <span class="n">str</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="nl">metatype</span><span class="p">:</span> <span class="n">AnotherSubClass</span><span class="p">.</span><span class="kt">Type</span> <span class="o">=</span> <span class="n">AnotherSubClass</span><span class="p">.</span><span class="nb">self</span>
</span><span class='line'><span class="k">let</span> <span class="n">anotherInstance</span> <span class="o">=</span> <span class="n">metatype</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">str</span><span class="p">:</span> <span class="s">&quot;some string&quot;</span><span class="p">)</span> <span class="c1">// 用元类型来 init 实例，init 必须是 required 或类是 final 的。</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">type</span><span class="p">(</span><span class="nl">of</span><span class="p">:</span> <span class="n">anotherInstance</span><span class="p">))</span> <span class="c1">// type(of:) 表达式来获取该实例在运行阶段的类型</span>
</span></code></pre></td></tr></table></div></figure>


<h3>嵌套类型</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">struct</span> <span class="n">BlackjackCard</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">enum</span> <span class="n">Suit</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">Spades</span> <span class="o">=</span> <span class="s">&quot;♠&quot;</span><span class="p">,</span> <span class="n">Hearts</span> <span class="o">=</span> <span class="s">&quot;♡&quot;</span><span class="p">,</span> <span class="n">Diamonds</span> <span class="o">=</span> <span class="s">&quot;♢&quot;</span><span class="p">,</span> <span class="n">Clubs</span> <span class="o">=</span> <span class="s">&quot;♣&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">BlackjackCard</span><span class="p">.</span><span class="n">Suit</span><span class="p">.</span><span class="n">Hearts</span><span class="p">.</span><span class="n">rawValue</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>运算符重载</h3>

<p>类和结构体可以为现有的运算符提供自定义的实现，这通常被称为运算符重载。只有组合赋值运算符可以被重载，不能对默认的赋值运算符 <code>=</code> 和三目条件运算符 <code>? :</code> 进行重载。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">struct</span> <span class="n">Vector2D</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 中缀运算符</span>
</span><span class='line'>    <span class="k">static</span> <span class="k">func</span> <span class="o">+</span> <span class="p">(</span><span class="nl">left</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">,</span> <span class="nl">right</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector2D</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="kr">left</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="kr">right</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="kr">left</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="kr">right</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 重载前缀或后缀运算符时需要在 func 前指定 prefix 或 postfix 修饰符</span>
</span><span class='line'>    <span class="k">static</span> <span class="kr">prefix</span> <span class="k">func</span> <span class="o">-</span> <span class="p">(</span><span class="nl">vector</span><span class="p">:</span> <span class="n">Vector2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector2D</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="o">-</span><span class="n">vector</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="o">-</span><span class="n">vector</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">combinedVector</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">)</span>
</span><span class='line'><span class="k">let</span> <span class="n">negativeVector</span> <span class="o">=</span> <span class="o">-</span><span class="n">Vector2D</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nl">y</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>内存管理</h2>

<p>Swift 使用 ARC 机制来跟踪和管理内存，并且只针对拥有引用计数的类实例，在 ARC 中有 strong、weak、unnowned 三个关键字，默认为 strong。Swift 可以通过弱引用和无主引用来解决循环引用问题，它们都允许循环引用中的一个实例强引用而另外一个实例不保持强引用。</p>

<p>当可能造成循环引用的两个实例中的其中一个为可选类型，那么就将这个可能为 nil 的属性声明为弱引用</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">weak</span> <span class="k">var</span> <span class="nl">delegate</span><span class="p">:</span> <span class="n">XXX</span><span class="o">?</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>当可能造成循环引用的两个实例有着几乎相同的生命周期，并且都不希望值为 nil 时，将有着强制依赖性的那个实例对另一个实例持有无主引用。ARC 无法在实例被销毁后将无主引用设为 nil，所以要小心无主引用实例释放后再次使用它时出现的运行时错误。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="kr">unowned</span> <span class="k">let</span> <span class="nl">timer</span><span class="p">:</span> <span class="n">Timer</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift 提供了闭包捕获列表来解决闭包引起的循环引用。捕获列表定义了闭包体内捕获一个或者多个引用类型的规则，跟解决两个类实例间的循环引用一样。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">__weak</span> <span class="k">typeof</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="n">weakSelf</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="nb">self</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="k">__strong</span> <span class="k">typeof</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="n">strongSelf</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">strongSelf</span> <span class="n">doSomething</span><span class="p">];</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="nb">self</span><span class="p">.</span><span class="n">closure</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="nb">self</span><span class="p">]</span> <span class="k">in</span> <span class="c1">// 用 weak 而不是 unowned 会更安全些</span>
</span><span class='line'>    <span class="n">guard</span> <span class="k">let</span> <span class="n">strongSelf</span> <span class="o">=</span> <span class="nb">self</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span> <span class="c1">// 像 OC 一样</span>
</span><span class='line'>    <span class="n">strongSelf</span><span class="p">.</span><span class="n">doSomething</span><span class="p">()</span> <span class="c1">// 必须用 self 引用属性或方法</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>扩展</h2>

<p>Swift 的扩展没有名字，可以为已有的类、结构体、枚举和协议添加方法、下标、嵌套类型、计算型属性以及确认某个协议，还可以为类添加新的便利构造器，但是不能为类添加新的指定构造器或析构器，也不可以为已有属性添加属性观察器和重写已有功能。如果要添加存储型属性也要像 Objective-C 中的方式去添加。（<a href="http://stackoverflow.com/questions/25426780/how-to-have-stored-properties-in-swift-the-same-way-i-had-on-objective-c%EF%BC%89">http://stackoverflow.com/questions/25426780/how-to-have-stored-properties-in-swift-the-same-way-i-had-on-objective-c%EF%BC%89</a></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">extension</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">mutating</span> <span class="k">func</span> <span class="n">square</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span> <span class="o">=</span> <span class="nb">self</span> <span class="o">*</span> <span class="nb">self</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>协议</h2>

<p>类、结构体或枚举都可以遵循协议，协议里的东西都是 requied 的，但是可以通过协议扩展来提供默认实现，默认实现可以被遵循协议的类型提供的实现所替代。在扩展协议的时候，还可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">protocol</span> <span class="n">Named</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span> <span class="kr">get</span> <span class="kr">set</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">protocol</span> <span class="n">Aged</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">age</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="n">TestClass</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="k">extension</span> <span class="n">Aged</span> <span class="k">where</span> <span class="nl">Self</span><span class="p">:</span> <span class="n">TestClass</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">age</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 父类名放在协议名之前</span>
</span><span class='line'><span class="k">class</span> <span class="nl">Person</span><span class="p">:</span> <span class="n">TestClass</span><span class="p">,</span> <span class="n">Named</span><span class="p">,</span> <span class="n">Aged</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// celebrator 的类型为 Named &amp; Aged，这意味着它不关心参数的具体类型，只要参数符合这两个协议即可，这称为协议合成。</span>
</span><span class='line'><span class="k">func</span> <span class="n">wishHappyBirthday</span><span class="p">(</span><span class="n">to</span> <span class="nl">celebrator</span><span class="p">:</span> <span class="n">Named</span> <span class="o">&amp;</span> <span class="n">Aged</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Happy birthday, \(celebrator.name), you&#39;re \(celebrator.age)!&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">birthdayPerson</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;xx&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">wishHappyBirthday</span><span class="p">(</span><span class="nl">to</span><span class="p">:</span> <span class="n">birthdayPerson</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>添加 class 关键字来限制协议只能被类类型遵循</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">protocol</span> <span class="nl">SomeProtocol</span><span class="p">:</span> <span class="k">class</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>使用 @objc 修饰后的类型，可以供 Objective-C 调用,标记 @objc 特性的协议只能被继承自 Objective-C 类的类或者 @objc 类遵循，struct 不能用，以下代码是错的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="p">@</span><span class="n">objc</span> <span class="k">class</span> <span class="n">test</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 使用@objc修饰的类，必须继承自NSObject</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift 协议中的所有方法默认情况下都要被确认者实现，可通过扩展来实现某个方法使其成为可选方法，也可用下面方式来实现</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="p">@</span><span class="n">objc</span> <span class="k">protocol</span> <span class="n">AnotherProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">@</span><span class="n">objc</span> <span class="n">optional</span> <span class="k">func</span> <span class="n">incrementForCount</span><span class="p">(</span><span class="nl">count</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span>
</span><span class='line'>    <span class="p">@</span><span class="n">objc</span> <span class="n">optional</span> <span class="k">var</span> <span class="nl">fixedIncrement</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>在 struct 或 enum 中用 mutating 来修饰方法是为了能够在该方法内修改自己的变量，如果协议中定义的方法没有写 mutating，那么确认该协议的 struct 或 enum 就不能在该方法中修改自己的变量，class 的话没关系，因为 class 可以随意修改自己的变量。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">protocol</span> <span class="n">SomeProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span> <span class="kr">get</span> <span class="kr">set</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kr">mutating</span> <span class="k">func</span> <span class="n">changeName</span><span class="p">(</span><span class="n">_</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="nl">SomeClass</span><span class="p">:</span> <span class="n">SomeProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">mutating</span> <span class="k">func</span> <span class="n">changeName</span><span class="p">(</span><span class="n">_</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="c1">// changeName 方法如果没加 mutating 编译会报错</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>泛型</h2>

<p>泛型能够减少重复代码，用一种清晰和抽象的方式来表达代码的意图。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">// 没用到泛型，它只能交换 Int 值</span>
</span><span class='line'><span class="k">func</span> <span class="nf">swapTwoInts</span><span class="p">(</span><span class="n">_</span> <span class="nl">a</span><span class="p">:</span> <span class="k">inout</span> <span class="n">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nl">b</span><span class="p">:</span> <span class="k">inout</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">temporaryA</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">temporaryA</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 用了泛型可以交换任意类型的值，T 的具体类型可以由传入的值的类型推断出来。</span>
</span><span class='line'><span class="k">func</span> <span class="n">swapTwoValues</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nl">a</span><span class="p">:</span> <span class="k">inout</span> <span class="n">T</span><span class="p">,</span> <span class="n">_</span> <span class="nl">b</span><span class="p">:</span> <span class="k">inout</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">temporaryA</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">temporaryA</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>泛型还可以添加类型约束，用来指定一个类型参数必须继承自指定类，或者符合一个特定的协议或协议组合。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="n">findIndex</span><span class="o">&lt;</span><span class="nl">T</span><span class="p">:</span> <span class="n">Equatable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">of</span> <span class="nl">valueToFind</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="k">in</span> <span class="nl">array</span><span class="p">:[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Int</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="n">array</span><span class="p">.</span><span class="n">enumerated</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">valueToFind</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">index</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">doubleIndex</span> <span class="o">=</span> <span class="n">findIndex</span><span class="p">(</span><span class="nl">of</span><span class="p">:</span> <span class="mf">9.3</span><span class="p">,</span> <span class="k">in</span><span class="o">:</span> <span class="p">[</span><span class="mf">3.14159</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">])</span>
</span><span class='line'><span class="k">let</span> <span class="n">stringIndex</span> <span class="o">=</span> <span class="n">findIndex</span><span class="p">(</span><span class="nl">of</span><span class="p">:</span> <span class="s">&quot;Andrea&quot;</span><span class="p">,</span> <span class="k">in</span><span class="o">:</span> <span class="p">[</span><span class="s">&quot;Mike&quot;</span><span class="p">,</span> <span class="s">&quot;Malcolm&quot;</span><span class="p">,</span> <span class="s">&quot;Andrea&quot;</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift 还允许定义泛型类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">struct</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Element</span><span class="o">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">Element</span><span class="p">]()</span>
</span><span class='line'>    <span class="kr">mutating</span> <span class="k">func</span> <span class="n">push</span><span class="p">(</span><span class="n">_</span> <span class="nl">item</span><span class="p">:</span> <span class="n">Element</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">items</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="kr">mutating</span> <span class="k">func</span> <span class="n">pop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Element</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">items</span><span class="p">.</span><span class="n">removeLast</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">stackOfStrings</span> <span class="o">=</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="p">()</span>
</span><span class='line'><span class="n">stackOfStrings</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="s">&quot;apple&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>错误处理</h2>

<p>和其他语言中的异常处理不同的是，Swift 中的错误处理并不涉及展开调用栈，所以对性能影响不大。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">enum</span> <span class="nl">StringError</span><span class="p">:</span> <span class="n">Error</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">StringisEmpty</span><span class="p">,</span> <span class="n">OtherError</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">func</span> <span class="n">canThrowAnError</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="n">throws</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">guard</span> <span class="o">!</span><span class="n">name</span><span class="p">.</span><span class="n">isEmpty</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">throw</span> <span class="n">StringError</span><span class="p">.</span><span class="n">StringisEmpty</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="s">&quot;no error&quot;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">do</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">str</span> <span class="o">=</span> <span class="n">try</span> <span class="n">canThrowAnError</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="c1">// 如果写成 try?，那么方法在抛出错误时，会将 nil 赋给 str，如果认为方法不可能抛出错误，可以用 try!</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;没有错误&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="n">catch</span> <span class="n">StringError</span><span class="p">.</span><span class="n">StringisEmpty</span> <span class="k">where</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;字符串不能为空&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="n">catch</span> <span class="k">let</span> <span class="n">error</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;其它错误: \(error)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>其它</h2>

<h3>给类型起别名</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">typealias</span> <span class="n">MyInt</span> <span class="o">=</span> <span class="n">Int</span>
</span></code></pre></td></tr></table></div></figure>


<h3>注释</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="cm">/* </span>
</span><span class='line'><span class="cm">    ...</span>
</span><span class='line'><span class="cm">    /* 支持多行注释嵌套 */</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="err">*/</span>
</span></code></pre></td></tr></table></div></figure>


<h3>断言</h3>

<p>一般用于在函数中对参数进行有效性验证，以避免非法的参数值导致函数不能正常执行，Xcode 在用 Release 配置项编译项目时，断言会被禁用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">age</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span>
</span><span class='line'>
</span><span class='line'><span class="n">assert</span><span class="p">(</span><span class="n">age</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;A person&#39;s age cannot be less than zero&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>编译配置语句</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="cp">#if arch(i386) || arch(x86_64)</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="cp">#if swift( &gt;=3.0.0 )</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">if</span> <span class="err">#</span><span class="n">available</span><span class="p">(</span><span class="n">iOS</span> <span class="mf">9.1.0</span><span class="p">,</span> <span class="o">*</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 使用 iOS 9.1.0+ 的 API</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">print</span><span class="p">(</span><span class="err">#</span><span class="n">file</span><span class="p">,</span> <span class="err">#</span><span class="n">function</span><span class="p">,</span> <span class="err">#</span><span class="n">line</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>标注命令</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">// MARK: - Section mark with a separator line</span>
</span><span class='line'><span class="c1">// TODO: Do something soon</span>
</span><span class='line'><span class="c1">// FIXME: Fix this code</span>
</span></code></pre></td></tr></table></div></figure>


<h3>@discardableResult</h3>

<p>如果没有使用方法返回的对象，编译器会有一个警告，有两种方法可以解决。</p>

<ul>
<li>如果是自己写的方法，在 func 前加 @discardableResult 修饰符，代表可以不使用返回值</li>
<li>对于第三方库中的方法：_ = navigationController?.popViewController(animated: true)</li>
</ul>


<h3>defer 语句</h3>

<p>defer语句在即将离开当前代码块时（throw、return 等）执行一系列语句，可用于执行一些必要的清理工作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">test</span><span class="p">(</span><span class="n">_</span> <span class="nl">param</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">guard</span> <span class="n">param</span><span class="p">.</span><span class="n">isEmpty</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">defer</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;我一定会被执行&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">test</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Carthage 做依赖管理]]></title>
    <link href="https://lijingcheng.github.io/blog/2016/12/23/shi-yong-carthage-zuo-yi-lai-guan-li/"/>
    <updated>2016-12-23T19:18:47+08:00</updated>
    <id>https://lijingcheng.github.io/blog/2016/12/23/shi-yong-carthage-zuo-yi-lai-guan-li</id>
    <content type="html"><![CDATA[<p><strong><a href="https://github.com/Carthage/Carthage">Carthage</a> - <em>A simple, decentralized dependency manager for Cocoa.</em></strong></p>

<p>Carthage 会用最简单的方式来管理第三方库，它会在下载完第三方库代码后，通过 xcodebuild 将其编译成动态库，但它不会像 CocoaPods 那样去修改你的项目文件和编译设置，这些都需要你自己去完成。</p>

<!-- more -->


<h2>Carthage VS CocoaPods</h2>

<ul>
<li><p>CocoaPods 需要我们在本地维护第三方库依赖的 podspec 文件，大部分 pod 命令执行时都会去读取此文件，Carthage 则是去中心化的管理方式，不需要维护这种说明文件，它会去直接下载项目并编译成动态库使用，所以对使用 Carthage 的项目来说，最低系统适配要求 iOS8+</p></li>
<li><p>CocoaPods 在执行 pod install 后会帮我们做好所有配置工作，我们只需要用它提供的 workspace 文件打开项目即可，使用 Carthage 的话需要我们自己到项目中进行动态库以及打包资源的配置，但是好处是项目配置信息相对 CocoaPods 来说较干净</p></li>
<li><p>Carthage 使用的是动态库方式，所以无法进行调试，看不到源码，但带来的好处是编译速度的提高</p></li>
<li><p>Carthage 的下载源目前仅支持 GitHub（GitHub.com 和 GitHub Enterprise），CocoaPods 除了 GitHub，还支持我们托管在公司的 Git 仓库，还有本地路径</p></li>
<li><p>目前支持 CocoaPods 的第三方库比 Carthage 要多一些</p></li>
</ul>


<p>我们可以在一个项目里同时使用 CocoaPods 和 Carthage，可以用 Carthage 管理比较成熟并且不需要调试的第三方库，用来提高编译速度，再用 CocoaPods 管理其它有可能需要进行代码调试的第三方库，还可以用来在组件化开发中做依赖设置。</p>

<h2>安装 Carthage</h2>

<p>建议通过 HomeBrew 安装</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>brew update
</span><span class='line'>
</span><span class='line'>brew install carthage</span></code></pre></td></tr></table></div></figure>


<p>如果在 brew update 时提示权限问题 Error: The /usr/local directory is not writable，可以执行 sudo chown -R $(whoami):admin /usr/local 进行授权</p>

<h2>使用 Carthage</h2>

<ul>
<li>在项目目录下创建 <a href="https://github.com/Carthage/Carthage/blob/master/Documentation/Artifacts.md">Cartfile</a> 文件，并写入想要使用的第三方库</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>github "lijingcheng/FMDBHelper" == 1.0.0</span></code></pre></td></tr></table></div></figure>


<ul>
<li>获取/更新 第三方库</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>carthage update --platform iOS</span></code></pre></td></tr></table></div></figure>


<p>执行完成后，本地目录下会新增以下文件及目录</p>

<ul>
<li>Cartfile.resolved 作用同 CocoaPods 中的 Podfile.lock 文件，用来跟踪项目当前使用的第三方库版本，此文件需要提交到 Git</li>
<li>Carthage/Checkouts 第三方库的项目代码会存放在这里</li>
<li><p>Carthage/Build 用于存储根据第三方库的项目代码打包后的动态库以及 .dSYM 文件</p></li>
<li><p>将动态库添加到项目中</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Target -&gt; General -&gt; Embedded Binaries</span></code></pre></td></tr></table></div></figure>


<ul>
<li>将资源文件添加到项目中</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Target -&gt; Build Phases -&gt; Copy Bundle Resources</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>针对由 universal binaries 引起的 App Store submission bug，还需要添加角本 <code>copy-frameworks</code></p></li>
<li><p>为了根踪第三方库的 Crash 信息，还需要将 .dSYM 文件添加到 <code>Copy Files Phase</code></p></li>
<li><p>导入第三方库</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;FMDBHelper/FMDBHelper.h&gt;</span></code></pre></td></tr></table></div></figure>


<p>完成了上述步骤并提交后，其他开发人员只需要用 carthage boostrap 来将第三方库下载到本地就可以了，以后还可以通过 carthage outdated 来检查依赖的第三方库是否有更新。</p>

<h2>carthage boostrap VS carthage update</h2>

<ul>
<li>carthage update 会去读 Cartfile 文件，如果添加了新的第三方库，或更新了版本号，则需要用这个命令去下载更新，执行完成后 Cartfile.resolved 文件也会同步更新</li>
<li>carthage boostrap 会去读 Cartfile.resolved 文件，并根据指定版本号进行下载，所以如果只是为了下载则可以使用这个命令</li>
</ul>


<h2>让自己的开源项目支持 Carthage</h2>

<p>Carthage 仅支持动态库，所以你的开源项目也只能支持 iOS8 及以上版本</p>

<ul>
<li><p>Carthage 提供给用户的动态库是根据项目中的 <code>动态库 Target</code> 编译打包后生成的，所以首先我们需要新建一个 Target，选择 Cocoa Touch Framework（动态库），并设置 Deployment Target</p></li>
<li><p>添加 .h 文件到 Build Phases -> Headers -> Public</p></li>
<li><p>添加 .m 文件到 Build Phases -> Compile Sources</p></li>
<li><p>添加其它资源文件到 Build Phases -> Copy Bundle Sources</p></li>
<li><p>Carthage 只构建从 .xcodeproj 分享出来的 scheme，所以需要我们在 Manage Schemes 中将新生成的 scheme 设置为 shared</p></li>
<li><p>通过 <code>carthage build --no-skip-current</code> 来检测 scheme 是否能够构建成功，然后检查 Carthage/Build 目录</p></li>
<li><p>Carthage 通过搜索 Git tag 来决定用户可以下载哪个版本的项目资源，所以还需要在提交代码后添加 tag 并 push 到 GitHub，格式建议写成 1.2.0 或 v1.2</p></li>
<li><p>通过添加下面内容，用来在项目 Readme.md 文件上显示 <img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat" alt="Carthage compatible" /></p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[![Carthage compatible](https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat)](https://github.com/Carthage/Carthage)</span></code></pre></td></tr></table></div></figure>


<p><br></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Xcodebuild 打包 IPA 并上传蒲公英]]></title>
    <link href="https://lijingcheng.github.io/blog/2016/12/05/tong-guo-xcodebuildda-bao-ipabing-shang-chuan-pu-gong-ying/"/>
    <updated>2016-12-05T18:49:45+08:00</updated>
    <id>https://lijingcheng.github.io/blog/2016/12/05/tong-guo-xcodebuildda-bao-ipabing-shang-chuan-pu-gong-ying</id>
    <content type="html"><![CDATA[<p> xcodebuild - 是苹果提供的项目自动构建工具，包含在 Command Line Tools 中，可以完成 iOS 项目的编译、打包和签名等工作。</p>

<p>shell script - 是一种命令语言，有点像 Windows 下的批处理，但更强大，它可以跑在 Linux/Unix 系统的 shell 程序中。</p>

<!-- more -->


<h2>为什么要用 xcodebuild</h2>

<p>通过 Xcode 对项目进行编译打包，并将 IPA 分发给测试人员这一过程操作步骤多并繁琐，而在 shell 脚本中使用 xcodebuild 命令执行这一过程便会非常方便快捷，特别是当项目进入测试阶段，每天都会打一个或多个测试包时，使用脚本进行自动化打包能够大大提高我们的工作效率。</p>

<h2>以前的作法</h2>

<p>AFNetworking 的作者 mattt 曾经提供了一个名为 <a href="https://github.com/nomad/shenzhen">shenzhen</a> 的打包服务，使用起来非常简单方便，并且能够在打包后上传到很多分发平台上，可惜已经有两年多没有再维护了。</p>

<h2>造个轮子</h2>

<p>因为打包脚本写起来比较简单，并且它也会随着 Xcode 的发展而改变，所以在这里我们还是选择自己写一个脚本使用并维护，下面的介绍不会太详细，如果有更多需求可以使用以下命令来查看帮助，并修改脚本。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>xcodebuild --help</span></code></pre></td></tr></table></div></figure>


<p>完成打包并分发这一过程通常分为四个步骤： &ldquo;build 工程 -> 生成 xcarchive 文件 -> 生成 ipa 文件 -> 上传到分发平台&rdquo;</p>

<h2>完整脚本</h2>

<p>新建 xxx.sh 文件，然后将下面脚本复制过去，如果你也在用 CocoaPods，并且只需要打 Release 包，那么只需要用蒲公英提供给你的 userKey 和 apiKey 替换掉脚本里的就可以了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#!/bin/sh</span>
</span><span class='line'>
</span><span class='line'><span class="cp">##########################################################################</span>
</span><span class='line'><span class="cp">######   1.执行 chmod +x ./xxx.sh 使脚本具有执行权限                    ######</span>
</span><span class='line'><span class="cp">######   2.通过 ./xxx.sh 执行脚本，./ 不能省略                          ######</span>
</span><span class='line'><span class="cp">######   3.Xcode 需要配置好证书，并且不能连接非测试机，否则会签名失败        ######</span>
</span><span class='line'><span class="cp">######   4.将 .xcarchive 中的 .dSYM 文件备份一下                       ######</span>
</span><span class='line'><span class="cp">######   5.在蒲公英网站的应用设置中添加成员后，便会在上传成功后给他发邮件     ######</span>
</span><span class='line'><span class="cp">##########################################################################</span>
</span><span class='line'>
</span><span class='line'><span class="cp"># CocoaPods 打包需要使用 workspace 名字</span>
</span><span class='line'><span class="n">WorkSpace_Name</span><span class="o">=</span><span class="err">`</span><span class="n">find</span> <span class="p">.</span> <span class="o">-</span><span class="n">name</span> <span class="o">*</span><span class="p">.</span><span class="n">xcworkspace</span> <span class="o">|</span> <span class="n">awk</span> <span class="o">-</span><span class="n">F</span> <span class="s">&quot;[/.]&quot;</span> <span class="err">&#39;</span><span class="p">{</span><span class="n">print</span> <span class="err">$</span><span class="p">(</span><span class="n">NF</span><span class="o">-</span><span class="mi">1</span><span class="p">)}</span><span class="err">&#39;`</span>
</span><span class='line'>
</span><span class='line'><span class="cp"># 要打包的 scheme 名字，默认与 workspace 名字一样</span>
</span><span class='line'><span class="n">Scheme_Name</span><span class="o">=</span><span class="err">$</span><span class="p">{</span><span class="n">WorkSpace_Name</span><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp"># build 文件目录</span>
</span><span class='line'><span class="n">Build_File_Path</span><span class="o">=</span><span class="err">$</span><span class="p">(</span><span class="n">PWD</span><span class="p">)</span><span class="o">/</span><span class="n">build</span><span class="o">/</span><span class="n">Release</span><span class="o">-</span><span class="n">iphoneos</span>
</span><span class='line'>
</span><span class='line'><span class="cp"># build 文件名字 (archive/ipa)</span>
</span><span class='line'><span class="n">Build_File_Name</span><span class="o">=</span><span class="err">$</span><span class="p">{</span><span class="n">Build_File_Path</span><span class="p">}</span><span class="o">/</span><span class="err">$</span><span class="p">{</span><span class="n">Scheme_Name</span><span class="p">}</span><span class="err">$</span><span class="p">(</span><span class="n">date</span> <span class="o">+%</span><span class="n">Y</span><span class="o">%</span><span class="n">m</span><span class="o">%</span><span class="n">d</span><span class="o">%</span><span class="n">H</span><span class="o">%</span><span class="n">M</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="cp"># 蒲公英</span>
</span><span class='line'><span class="n">PGY_User_Key</span><span class="o">=</span><span class="s">&quot;由蒲公英提供&quot;</span>
</span><span class='line'><span class="n">PGY_API_Key</span><span class="o">=</span><span class="s">&quot;由蒲公英提供&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="cp"># 开始时间</span>
</span><span class='line'><span class="n">Start_Time</span><span class="o">=</span><span class="err">`</span><span class="n">date</span> <span class="o">+%</span><span class="n">s</span><span class="err">`</span>
</span><span class='line'>
</span><span class='line'><span class="n">echo</span> <span class="s">&quot;================= 开始编译 =================&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">xcodebuild</span> <span class="n">clean</span> <span class="o">-</span><span class="n">workspace</span> <span class="err">$</span><span class="p">{</span><span class="n">WorkSpace_Name</span><span class="p">}.</span><span class="n">xcworkspace</span> <span class="o">-</span><span class="n">scheme</span> <span class="err">$</span><span class="p">{</span><span class="n">Scheme_Name</span><span class="p">}</span> <span class="o">-</span><span class="n">configuration</span> <span class="n">Release</span> <span class="o">-</span><span class="n">sdk</span> <span class="n">iphoneos</span> <span class="n">SYMROOT</span><span class="o">=</span><span class="err">$</span><span class="p">(</span><span class="n">PWD</span><span class="p">)</span><span class="o">/</span><span class="n">build</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="o">!</span> <span class="p">[</span> <span class="err">$</span><span class="o">?</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">];</span> <span class="n">then</span>
</span><span class='line'>    <span class="n">exit</span> <span class="mi">1</span>
</span><span class='line'><span class="n">fi</span>
</span><span class='line'>
</span><span class='line'><span class="n">echo</span> <span class="s">&quot;================= 开始构建 =================&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">xcodebuild</span> <span class="n">archive</span> <span class="o">-</span><span class="n">workspace</span> <span class="err">$</span><span class="p">{</span><span class="n">WorkSpace_Name</span><span class="p">}.</span><span class="n">xcworkspace</span> <span class="o">-</span><span class="n">scheme</span> <span class="err">$</span><span class="p">{</span><span class="n">Scheme_Name</span><span class="p">}</span> <span class="o">-</span><span class="n">archivePath</span> <span class="err">$</span><span class="p">{</span><span class="n">Build_File_Name</span><span class="p">}.</span><span class="n">xcarchive</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="o">!</span> <span class="p">[</span> <span class="o">-</span><span class="n">d</span> <span class="s">&quot;${Build_File_Name}.xcarchive&quot;</span> <span class="p">];</span> <span class="n">then</span>
</span><span class='line'>    <span class="n">exit</span> <span class="mi">1</span>
</span><span class='line'><span class="n">fi</span>
</span><span class='line'>
</span><span class='line'><span class="n">echo</span> <span class="s">&quot;================= 导出ipa =================&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">xcodebuild</span> <span class="o">-</span><span class="n">exportArchive</span> <span class="o">-</span><span class="n">archivePath</span> <span class="err">$</span><span class="p">{</span><span class="n">Build_File_Name</span><span class="p">}.</span><span class="n">xcarchive</span> <span class="o">-</span><span class="n">exportPath</span> <span class="err">$</span><span class="p">{</span><span class="n">Build_File_Path</span><span class="p">}</span> <span class="o">-</span><span class="n">exportOptionsPlist</span> <span class="err">$</span><span class="p">(</span><span class="n">PWD</span><span class="p">)</span><span class="o">/</span><span class="n">exportOptions</span><span class="p">.</span><span class="n">plist</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">[</span> <span class="o">-</span><span class="n">e</span> <span class="s">&quot;${Build_File_Path}/${Scheme_Name}.ipa&quot;</span> <span class="p">];</span> <span class="n">then</span>
</span><span class='line'>    <span class="n">mv</span> <span class="s">&quot;${Build_File_Path}/${Scheme_Name}.ipa&quot;</span> <span class="s">&quot;${Build_File_Name}.ipa&quot;</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>    <span class="n">exit</span> <span class="mi">1</span>
</span><span class='line'><span class="n">fi</span>
</span><span class='line'>
</span><span class='line'><span class="n">echo</span> <span class="s">&quot;================= 上传到蒲公英 =================&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">curl</span> <span class="o">-</span><span class="n">F</span> <span class="s">&quot;file=@${Build_File_Name}.ipa&quot;</span> <span class="o">-</span><span class="n">F</span> <span class="s">&quot;uKey=${PGY_User_Key}&quot;</span> <span class="o">-</span><span class="n">F</span> <span class="s">&quot;_api_key=${PGY_API_Key}&quot;</span> <span class="nl">https</span><span class="p">:</span><span class="c1">//www.pgyer.com/apiv1/app/upload</span>
</span><span class='line'>
</span><span class='line'><span class="cp"># 结束时间</span>
</span><span class='line'><span class="n">End_Time</span><span class="o">=</span><span class="err">`</span><span class="n">date</span> <span class="o">+%</span><span class="n">s</span><span class="err">`</span>
</span><span class='line'>
</span><span class='line'><span class="n">echo</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">================= 耗时: $[ End_Time - Start_Time ] 秒 =================&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在导出 ipa 文件时，需要我们提供一个 plist 文件，用于配置打包过程中所需要的参数，文件名为 exportOptions.plist，并放在项目根目录下，内容用下面提供的就可以，如果不满足需要，可通过 xcodebuild &ndash;help 查看帮助。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
</span><span class='line'><span class="cp">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span>
</span><span class='line'><span class="nt">&lt;plist</span> <span class="na">version=</span><span class="s">&quot;1.0&quot;</span><span class="nt">&gt;</span>
</span><span class='line'><span class="nt">&lt;dict&gt;</span>
</span><span class='line'>  <span class="nt">&lt;key&gt;</span>provisioningProfiles<span class="nt">&lt;/key&gt;</span>
</span><span class='line'>  <span class="nt">&lt;dict&gt;</span>
</span><span class='line'>      <span class="nt">&lt;key&gt;</span>com.xx.xx(bundleid)<span class="nt">&lt;/key&gt;</span>
</span><span class='line'>      <span class="nt">&lt;string&gt;</span>profile文件名<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/dict&gt;</span>
</span><span class='line'>  <span class="nt">&lt;key&gt;</span>teamID<span class="nt">&lt;/key&gt;</span>
</span><span class='line'>  <span class="nt">&lt;string&gt;</span>由苹果提供<span class="nt">&lt;/string&gt;</span>
</span><span class='line'>  <span class="nt">&lt;key&gt;</span>method<span class="nt">&lt;/key&gt;</span>
</span><span class='line'>  <span class="nt">&lt;string&gt;</span>development<span class="nt">&lt;/string&gt;</span>
</span><span class='line'><span class="nt">&lt;/dict&gt;</span>
</span><span class='line'><span class="nt">&lt;/plist&gt;</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 开发 Tips]]></title>
    <link href="https://lijingcheng.github.io/blog/2016/06/09/ioskai-fa-tips/"/>
    <updated>2016-06-09T10:58:59+08:00</updated>
    <id>https://lijingcheng.github.io/blog/2016/06/09/ioskai-fa-tips</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li>用模拟器调试动画功能时，让动画执行的慢一些</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>模拟器菜单：Debug -&gt; Show Animations</span></code></pre></td></tr></table></div></figure>


<ul>
<li>取两位整数，不够补 0</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSLog(@"%@", [NSString stringWithFormat:@"%02d月", 3]);</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在不知道谁是第一响应者时隐藏键盘</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[[[UIApplication sharedApplication] keyWindow] endEditing:YES];</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Provisioning Profiles 所在路径</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>~/Library/MobileDevice/Provisioning Profiles</span></code></pre></td></tr></table></div></figure>


<ul>
<li>解码 cms 加密后的授权文件</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>终端：security cms -D -i example.mobileprovision</span></code></pre></td></tr></table></div></figure>


<ul>
<li>查找代码中的中文字符串，做国际化适配时会用到</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Xcode左侧导航处：Find -&gt; Regular Expression，然后输入 @"[^"]*[\u4E00-\u9FA5]+[^"\n]*?"</span></code></pre></td></tr></table></div></figure>


<ul>
<li>忽略第三方 SDK 文档中的警告</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>build settings -&gt;  Other Warning Flags -&gt; -Wno-documentation</span></code></pre></td></tr></table></div></figure>


<ul>
<li>关闭 UINavigationController 滑动返回功能</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.navigationController.interactivePopGestureRecognizer.enabled = NO;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>自定义 leftBarButtonItem 后，左滑返回手势失效</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.navigationController.interactivePopGestureRecognizer.delegate = self;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在 xib 中给 UILabel 或 UITextView 设置多行文字</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>输入文字后，用 control + enter 来插入换行符，相当于在代码中添加 \n</span></code></pre></td></tr></table></div></figure>


<ul>
<li>禁用 UIButton 并且颜色不变灰</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>button.userInteractionEnabled = NO;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>UITableView 的分割线左边顶头</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tableView.separatorInset = UIEdgeInsetsZero;
</span><span class='line'>cell.layoutMargins = UIEdgeInsetsZero;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>修改约束后，用动画展示效果</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[UIView animateWithDuration:0.3f animations:^{
</span><span class='line'>    [myView layoutIfNeeded];
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<ul>
<li>给 UIView 设置透明度后不影响 subviews</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>superView.backgroundColor = [[UIColor blackColor] colorWithAlphaComponent:0.5];</span></code></pre></td></tr></table></div></figure>


<ul>
<li>隐藏导航条下面的线</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>navigationBar.setValue(hide, forKey: "hidesShadow")</span></code></pre></td></tr></table></div></figure>


<ul>
<li>隐藏 Grouped TableView 上边多余的间隔</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.tableView.tableHeaderView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, CGFLOAT_MIN)];</span></code></pre></td></tr></table></div></figure>


<ul>
<li>根据模糊程度生成 UIVisualEffectView</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension UIVisualEffectView {
</span><span class='line'>    public convenience init(blurRadius: CGFloat) {
</span><span class='line'>        let blurEffect = (NSClassFromString("_UICustomBlurEffect") as! UIBlurEffect.Type).init()
</span><span class='line'>        blurEffect.setValue(blurRadius, forKeyPath: "blurRadius")
</span><span class='line'>
</span><span class='line'>        self.init(effect: blurEffect)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>编译出 error 后继续编译</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Xcode -&gt; preference -&gt; general -&gt; 勾选 Continue building after errors</span></code></pre></td></tr></table></div></figure>


<ul>
<li>清理 Derived Data</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Xcode -&gt; Product -&gt; 按下 option -&gt; 选择 Clean Build Folder... </span></code></pre></td></tr></table></div></figure>


<ul>
<li>自定义类后，禁止通过 init 方法初始化对象</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (instancetype)init UNAVAILABLE_ATTRIBUTE;
</span><span class='line'>或
</span><span class='line'>- (instancetype)init __attribute__((unavailable("init 方法不可用，请用 initWithName:")));</span></code></pre></td></tr></table></div></figure>


<ul>
<li>忽略可以忽略的警告，<a href="http://fuckingclangwarnings.com">更多警告</a></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#pragma clang diagnostic push
</span><span class='line'>#pragma clang diagnostic ignored "-Wdeprecated-declarations"
</span><span class='line'>
</span><span class='line'>#pragma clang diagnostic pop
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>KVC</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSArray *numbers = @[@4, @81, @2]; // @[@{@"price": @4}, @{@"price": @81}, @{@"price": @2}]
</span><span class='line'>
</span><span class='line'>NSLog(@"max = %@", [numbers valueForKeyPath:@"@max.self"]); // @max.price
</span><span class='line'>NSLog(@"min = %@", [numbers valueForKeyPath:@"@min.self"]); // @min.price
</span><span class='line'>NSLog(@"sum = %@", [numbers valueForKeyPath:@"@sum.self"]); // @sum.price
</span><span class='line'>NSLog(@"avg = %@", [numbers valueForKeyPath:@"@avg.self"]); // @avg.price
</span><span class='line'>
</span><span class='line'>//数组去重
</span><span class='line'>NSArray *devices = @[@"iPhone6", @"iPhone5", @"iPhone6 Plus", @"iPhone6", @"iPhone5"];
</span><span class='line'>
</span><span class='line'>NSLog(@"devices = %@", [devices valueForKeyPath:@"@distinctUnionOfObjects.self"]); // iPhone5, iPhone6, iPhone6 Plus
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[代码重构及代码Review]]></title>
    <link href="https://lijingcheng.github.io/blog/2016/05/09/man-chang-de-dai-ma-zhong-gou-zhi-lu/"/>
    <updated>2016-05-09T10:50:10+08:00</updated>
    <id>https://lijingcheng.github.io/blog/2016/05/09/man-chang-de-dai-ma-zhong-gou-zhi-lu</id>
    <content type="html"><![CDATA[<p><strong>代码重构 - <em>重构就是在不改变软件系统外部行为的前提下，改善它的内部结构。</em></strong></p>

<p>Martin Flower 在《重构》中有一句经典的话："任何一个傻瓜都能写出计算机可以理解的程序，只有写出人类容易理解的程序才是优秀的程序员。"</p>

<!-- more -->


<h1>重构原则</h1>

<p>随着时间推移，需求的频繁变化等原因都会导致代码质量逐步下降，所以持续重构就变得越来越重要，并且重构对开发人员技术水平及经验的要求会更高一些，下面列出几条重构原则：</p>

<ul>
<li><p>要充分理解旧代码后再进行修改，模块之间过度耦合导致牵一发而动全身，不易控制影响范围，有时代码摆放顺序的修改都会造成问题</p></li>
<li><p>优先重构经常修改的部分，如果代码一两年都没有修改过，那么说明改动的收益很小</p></li>
<li><p>重构可能需要很长时间，并且不是非要一次做完，主要取决于团队对于风险的容忍程度</p></li>
<li><p>删除无用代码是提高代码可维护性最有效的方式</p></li>
<li><p>小范围重构，当重构后会导致大量测试工作时，需要谨慎决定是否有必要重构</p></li>
<li><p>要构建可扩展系统，我们需要认同错误的不可避免性，有时候避免这些错误会带来高昂的成本，因此我们不妨将注意力集中在对问题的快速检测以及出现后的应对措施上</p></li>
</ul>


<p><br></p>

<h1>哪种代码需要重构</h1>

<ul>
<li><p>臃肿的类：一个类应该只做一件事，可通过一些设计模式去拆分</p></li>
<li><p>长方法：方法应尽量短小，专注一个功能点，并且要放在合适的类里</p></li>
<li><p>重复代码：往往由于开发人员对框架不熟悉，也有个别不讲究的情况</p></li>
<li><p>方法有多个参数：可通过提取成类对象或字典解决，个别情况也可拆分方法</p></li>
<li><p>魔鬼数字：尽量用常量去定义数字，或在使用处添加注释说明用意</p></li>
<li><p>模糊的命名：要做到见名知意</p></li>
<li><p>if/else 嵌套过多：尽量不超过3层，如果不能简化逻辑，可通过拆分方法或添加注释方式解决</p></li>
</ul>


<p><br></p>

<h1>Xcode 提供的重构功能</h1>

<p>跟别的开发工具相比 Xcode 提供的重构功能简直弱暴了，不过有总比没有好，Xcode 提供了以下几个重构功能，从菜单栏中进入：Edit -> Refactor，或在代码上右键，然后选择 Refactor</p>

<ul>
<li>Rename：重命名类、方法、变量</li>
<li>Extract：将方法中的一段代码抽取为一个独立的方法</li>
<li>Create Superclass：给当前选中的类创建父类</li>
<li>Move Up：将选中方法或属性移到父类中</li>
<li>Move Down：将父类中选中的属性移到子类中</li>
<li>Encapsulate：封装，生成 setter/getter，一般用不上</li>
</ul>


<p>相对来说，Rename 更常用一些，有时也会用到 Extract，最后吐槽一下</p>

<ul>
<li>Extract：使用时 Xcode 经常崩掉</li>
<li>Rename：并不能保证全部覆盖到，还需要自己再次检查</li>
</ul>


<p><br></p>

<h1>代码 Review</h1>

<p>有效并持续的 Code Review 不仅可以提高代码质量，降低程序风险，还可以提高开发人员技术水平，但前提是需要开发人员能够真正认可并意识到这并不是在浪费时间，而且在实施前最好能够得到公司认可，并能够将 Code Review 的时间计入工作量，下面列出几条需要注意的地方：</p>

<ul>
<li><p>要有一个 CheckList，对一些代码问题进行定义，要求开发人员以此为准</p></li>
<li><p>对于代码规范上的问题应该通过自动 Review 工具去做，如 OCLint/SwiftLint</p></li>
<li><p>对于代码逻辑及性能上的问题可通过 Pull Request 方式去做</p></li>
<li><p>审查要及时，打回时被审查者要尽量优先修改问题然后再次提交</p></li>
<li><p>Review 过程中不要太关注代码细节，并且不要过度主观，例如同一功能可用多种方式实现并且它们之间没有明显好坏的情况下不用要求别人修改代码</p></li>
<li><p>按功能提交代码，不要攒一堆然后一次提交</p></li>
<li><p>提交描述要写清楚，并且加上前辍，如 fix: fea:</p></li>
</ul>


<h1>CheckList</h1>

<ul>
<li>代码简洁不重复</li>
<li>方法短小并专注一个功能</li>
<li>删除无用的代码及资源</li>
<li>适时地使用 private 实现封装并使代码更清晰</li>
<li>避免无意义的 log，保持好的编码习惯</li>
<li>不要用魔术数字</li>
<li>框架代码及复杂代码要写注释</li>
<li>遍历数组或字典时不允许添加或删除元素</li>
<li>代码尽量不要有警告</li>
<li>相似意义的常量超过 2 个时就要考虑用枚举代替</li>
<li>命名要做到“见名知意”，UI 控件的命名要能看出来是什么控件</li>
<li>使用 xib 或 storyboard 画界面来降低代码量，UI 控件可通过纯代码实现</li>
<li>尽量避免循环引用问题</li>
<li>Model 中对应接口返回 Int 类型字段如果需要定义成枚举，需要注意接口返回未定义 case 的场景</li>
<li>避免对可选类型强解包，可用 <code>if let foo = foo { ... }</code> 或可选链 <code>foo?.doSomething()</code></li>
<li>尽早的退出方法，可提升代码的可读性，例：<code>guard xx else { return }</code>或<code>if xxx { return}</code></li>
<li>定义 model 用 struct，值类型是线程安全的，并以栈的形式分配，速度上比 class 快</li>
<li>用于对接接口返回数据的 model 中的属性必须是 optional 的，当接口返回字段较少时，可用字典</li>
<li>不要在 ViewModel 里用到跟 UIKit 相关的东西，Controller 当 View 用，尽量不写逻辑性代码</li>
<li>UI 切的图需要<a href="https://tinypng.com">压缩</a>后再使用，图片命名方式：
<code>core_hud_loading@2x.png</code></li>
<li>项目的主色和辅色有对应常量，如果在 xib 中使用，需要先将做好的 .clr 文件复制到指定目录</li>
<li>用<code>// MARK:</code>来做代码分段，用<code>// TODO:</code>来做待办，但需要写出计划完成时间或条件</li>
<li>尽量多用常量来增强代码的不可变性，可以让代码更加安全并提高可读性</li>
<li>尽量避免混合使用 Swift 类型和 NSObject 子类，这样会造成大量的类型转换，对性能有影响</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[了解 Block]]></title>
    <link href="https://lijingcheng.github.io/blog/2015/12/03/liao-jie-block/"/>
    <updated>2015-12-03T15:09:29+08:00</updated>
    <id>https://lijingcheng.github.io/blog/2015/12/03/liao-jie-block</id>
    <content type="html"><![CDATA[<p>Block 是 Apple 为 C、C++ 以及 Objective-C 添加的特性，使得这些语言可以用类 lambda 表达式的语法来创建闭包。在适当的时候使用 block 替代 delegation 可以使代码看起来更紧凑，但也需要注意 block 带来的循环引用问题。</p>

<!-- more -->


<p>从 iOS4 开始 block 便在很多场景下替代了 delegate，相对来说 block 的最大优点就是可以使代码集中在一起，提高可读性，但也提高了代码调试的复杂度，另外 block 会使 app 运行成本增高，因为 delegate 只是保存了一个对象指针，而 block 实际上就是对象，它会被编译成 struct 并为其内容分配空间，主要包括 isa 指针、block 对应实现函数的地址以及 block 复制过来的变量，这些内容也会随需求从栈内存复制到堆内存</p>

<ul>
<li>isa：指向 block 对应的 Class

<ul>
<li>_NSConcreteGlobalBlock：定义在全局区的 block 会作为代码片段存在</li>
<li>_NSConcreteStackBlock：定义在方法中的 block 会保存在栈中，当函数返回时被销毁</li>
<li>_NSConcreteMallocBlock：为了增加 block 的生命周期，可以用 copy 方法将其复制到堆中，如果 block 已经在堆里了，再次进行 copy 只会增加引用计数</li>
</ul>
</li>
<li>IMP：block 块中的代码会作为方法形式存在，IMP 指向方法地址</li>
<li>复制的变量：block 能够读取它所在函数的内部变量，该变量会被复制到 struct 中，默认是值复制，不能够修改，用 __block 修饰的是引用复制，所以可以修改</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">__block</span> <span class="bp">NSInteger</span> <span class="n">mutiplier</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="c1">// 用 __block 修饰后，在 block 里就可以修改 mutiplier 的值</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 定义名为 myBlock 的代码块，返回值类型为 NSInteger，并有一个名为 num 的 NSInteger 型参数</span>
</span><span class='line'><span class="bp">NSInteger</span> <span class="p">(</span><span class="o">^</span><span class="n">myBlock</span><span class="p">)(</span><span class="bp">NSInteger</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="bp">NSInteger</span> <span class="n">num</span><span class="p">){</span>
</span><span class='line'>    <span class="n">mutiplier</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">num</span> <span class="o">*</span> <span class="n">mutiplier</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%ld&quot;</span><span class="p">,</span> <span class="n">myBlock</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span> <span class="c1">// 像调用函数一样使用 block</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><br></p>

<h1>循环引用(retain cycle)</h1>

<p>对象之间相互持有便会造成循环引用问题，下面用一个经典例子看一下怎么解决 block 中的循环引用问题</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 因为 self 会强引用 block，所以避免 block 强引用 self 对象</span>
</span><span class='line'><span class="k">__weak</span> <span class="n">__typeof</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span><span class="n">weakSelf</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">AFNetworkReachabilityStatusBlock</span> <span class="n">callback</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">AFNetworkReachabilityStatus</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 如果有多处引用 weakSelf，则需要转成 strongSelf，避免 weakSelf 因多线程导致其被释放后出现问题</span>
</span><span class='line'>    <span class="k">__strong</span> <span class="n">__typeof</span><span class="p">(</span><span class="n">weakSelf</span><span class="p">)</span><span class="n">strongSelf</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">strongSelf</span><span class="p">.</span><span class="n">networkReachabilityStatus</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">strongSelf</span><span class="p">.</span><span class="n">networkReachabilityStatusBlock</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">strongSelf</span><span class="p">.</span><span class="n">networkReachabilityStatusBlock</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<h1>Block 作为属性使用</h1>

<ul>
<li>将 block 定义成类型</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">^</span><span class="n">BannerViewSelectedBlock</span><span class="p">)(</span><span class="bp">NSString</span> <span class="o">*</span><span class="n">bannerId</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>然后定义相关属性，虽然 strong 和 copy 的实际效果一样，为了代码可读性还是建议用 copy</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="n">BannerViewSelectedBlock</span> <span class="n">seletedBlock</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>定义方法用来接收 block 参数并设置 block 属性，如有多个参数，block 参数应为最后一个</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setCompletionBlockWithSeleted:</span><span class="p">(</span><span class="n">BannerViewSelectedBlock</span><span class="p">)</span><span class="nv">completionBlock</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">seletedBlock</span> <span class="o">=</span> <span class="n">completionBlock</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>调用上面定义的方法，并传入 BannerViewSelectedBlock 类型的 block 代码块</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">bannerView</span> <span class="nl">setCompletionBlockWithSeleted</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="n">bannerId</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>当发生相关事件时触发 block 属性中的代码块</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">seletedBlock</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nb">self</span><span class="p">.</span><span class="n">seletedBlock</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">items</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">item</span><span class="p">][</span><span class="s">@&quot;bannerId&quot;</span><span class="p">]);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="https://github.com/lijingcheng/JCBannerView">参考代码</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C Runtime 开发]]></title>
    <link href="https://lijingcheng.github.io/blog/2015/09/21/objective-c-runtimekai-fa/"/>
    <updated>2015-09-21T14:30:27+08:00</updated>
    <id>https://lijingcheng.github.io/blog/2015/09/21/objective-c-runtimekai-fa</id>
    <content type="html"><![CDATA[<p><strong>Runtime - 使用 C 和汇编实现的运行时代码库，Objective-C 中有很多语言特性都是通过它来实现。</strong></p>

<p>了解 Runtime 开发可以帮助我们更灵活的使用 Objective-C 这门语言，我们可以将程序功能推迟到运行时再去决定怎么做，还可以利用 Runtime 来解决项目开发中的一些设计和技术问题，使开发过程更加具有灵活性。</p>

<!-- more -->


<h1>一些关键字</h1>

<ul>
<li><p>self：类的隐藏参数变量，指向当前调用方法的对象</p></li>
<li><p>super：是编译器的标示符，通过 super 调用方法会被翻译成 objc_msgSendSuper(self, _cmd,&hellip;)</p></li>
<li><p>SEL：以方法名为内容的 C 字符串</p></li>
<li><p>IMP：指向方法实现的函数指针</p></li>
<li><p>id：指向类对象或实例对象的指针</p></li>
<li><p>isa：为 id 对象所属类型 (objc_class)，Objc 中的继承就是通过 isa 指针找到 objc_class，然后再通过 super_class 去找对应的父类</p></li>
<li><p>metaclass：在 Objc 中，类本身也是对象，实例对象的 isa 指向它所属的类，而类对象的 isa 指向元类 (metaclass)，元类的 isa 直接指向根元类，根元类的isa指向它自己，它们之间的关系如下图所示。</p></li>
</ul>


<p><img src="https://lijingcheng.github.io/images/runtime_class.jpeg" height="500" width="500" alt="" /></p>

<h1>消息传递 (Messaging)</h1>

<p>Objective-C 对于调用对象的某个方法这种行为叫做给对象发送消息，实际上就是沿着它的 isa 指针去查找真正的函数地址。下面我们来了解一下这个过程：</p>

<ul>
<li>我们写一个给对象发送消息的代码</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">array</span> <span class="nl">insertObject</span><span class="p">:</span><span class="n">obj</span> <span class="nl">atIndex</span><span class="p">:</span><span class="mi">5</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>编译器首先会将上面代码翻译成这种样子</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">objc_msgSend</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">insertObject</span><span class="p">:</span><span class="nl">atIndex</span><span class="p">:),</span> <span class="n">obj</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<ul>
<li>系统在运行时会通过 array 对象的 isa 指针找到对应的 class（如果是给类发消息，则找到的是metaclass）。</li>
<li>在 class 的 cache 方法列表中用 SEL 去找对应 method，如果找不到便去 class 的方法列表中去找</li>
<li>如果在方法列表中也找不对对应 method 时，便沿着继承体系继续向上查找

<ul>
<li>找到后将 method 放入 cache，以便下次能快速定位，然后再去执行 method 的 IMP</li>
<li>找不到时系统便报错：unrecognized selector sent to insertObject:atIndex:</li>
</ul>
</li>
</ul>


<p><br/>
<strong>Runtime 提供了三种方法避免因为找不到方法而崩溃</strong></p>

<ul>
<li>当找不到方法实现时，Runtime 会先发送 +resolveInstanceMethod: 或 +resolveClassMethod: 消息，我们可以重写它然后为对象指定一个处理方法。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">dynamicXXXMethod</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">_cmd</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;ok...&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">resolveInstanceMethod:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSEL</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">aSEL</span> <span class="o">==</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">xxx</span><span class="p">:))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">class_addMethod</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="n">aSEL</span><span class="p">,</span> <span class="p">(</span><span class="kt">IMP</span><span class="p">)</span><span class="n">dynamicXXXMethod</span><span class="p">,</span> <span class="s">&quot;v@:&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="nb">super</span> <span class="n">resolveInstanceMethod</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>class_addMethod 方法的最后一个参数用来指定所添加方法的参数及返回值，叫 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encodings</a>。</p></blockquote>

<ul>
<li>如果 resolve 方法返回 NO，Runtime 会发送 -forwardingTargetForSelector: 消息，允许我们将消息转发给能处理它的其它对象。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">forwardingTargetForSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">aSelector</span> <span class="o">==</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">xxx</span><span class="p">:)){</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">otherObject</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">forwardingTargetForSelector</span><span class="p">:</span><span class="n">aSelector</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>当 -forwardingTargetForSelector: 返回 nil 时，Runtime 会发送 -methodSignatureForSelector: 和 -forwardInvocation: 消息。我们可以选择忽略消息、抛出异常、将消息转由当前对象或其它对象的任意消息来处理。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//根据 SEL 生成 NSInvocation 对象，然后再由 -forwardInvocation: 方法进行转发。</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSMethodSignature</span> <span class="o">*</span><span class="p">)</span><span class="nf">methodSignatureForSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">NSMethodSignature</span> <span class="o">*</span><span class="n">signature</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">methodSignatureForSelector</span><span class="p">:</span><span class="n">aSelector</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signature</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">signature</span> <span class="o">=</span> <span class="p">[</span><span class="n">otherObject</span> <span class="nl">instanceMethodSignatureForSelector</span><span class="p">:</span><span class="n">aSelector</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">signature</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">forwardInvocation:</span><span class="p">(</span><span class="bp">NSInvocation</span> <span class="o">*</span><span class="p">)</span><span class="nv">invocation</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">SEL</span> <span class="n">sel</span> <span class="o">=</span> <span class="n">invocation</span><span class="p">.</span><span class="n">selector</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span><span class="p">([</span><span class="n">otherObject</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="n">sel</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">invocation</span> <span class="nl">invokeWithTarget</span><span class="p">:</span><span class="n">otherObject</span><span class="p">];</span> <span class="c1">// 转发消息</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">doesNotRecognizeSelector</span><span class="p">:</span><span class="n">sel</span><span class="p">];</span> <span class="c1">// 抛出异常</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><br/></p>

<h1>KVO</h1>

<p>当我们为对象添加观察者后，Runtime 会在运行时创建这个对象所在类的子类，并且将该对象的 isa 指针指向这个子类，然后重写监听属性的 set 方法并在方法中调用 -willChangeValueForKey: 和 -didChangeValueForKey: 来通知观察者，所以如果直接修改实例变量便不会触发监听方法。当移除观察者后，Runtime 便会将这个子类删除。</p>

<p>所以 isa 指针并不总是指向实例对象所属的类，也有可能指向一个中间类，所以不能依靠它来确定类型，而是应该用 class 方法来确定实例对象的类。</p>

<p><br/></p>

<h1>关联对象 (Associated Objects)</h1>

<p>在 Category 中可以为类添加实例方法或类方法，但是不支持添加实例变量，所以即使我们在 Category 中为类添加了 property，也不能直接使用它，Runtime 可以解决这个问题，我们只需要定义一个指针，然后通过 objc_setAssociatedObject 方法将指针与对象进行关联并指定内存管理方式，数据以 KeyValue 的形式存储在一个 HashMap 里。</p>

<p>注：Objc 中的类和对象都是结构体，Category 也是这样，定义的方法和属性在结构体中的存储，并在运行时按倒序添加到主类中（添加的方法会放在方法列表的上面），所以如果添加的方法与原类中的一样，那么在调用此方法时，优先找到的便是我们添加的这个方法。如果有多个 Category 添加同样名称的方法，那么这些方法在方法列表中的顺序取决于他们的编译顺序，也就是这些 Category 文件在 Compile Sources 中的顺序。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="bp">NSObject</span> <span class="nl">(JC)</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">ID</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="bp">NSObject</span> <span class="nl">(JC)</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">IDKey</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">ID</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">IDKey</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setID:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">ID</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">IDKey</span><span class="p">,</span> <span class="n">ID</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_COPY_NONATOMIC</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>
<br/></p>

<h1>AOP(Method Swizzling)</h1>

<p>我们可以通过继承、Category、AOP 方式来扩展类的功能。</p>

<ul>
<li>继承比较适合在设计底层代码架构时使用，不适当的使用会让代码看起来很啰嗦，并且增加维护难度。</li>
<li>Category 适合为现有类添加方法。</li>
<li>当需要修改现有类的方法并且拿不到源码时，继承和 AOP 都能解决问题，但是用 AOP 来解决代码耦合度更低。其实就算能拿到源码，往往直接去改源码也不是个好办法。</li>
</ul>


<p><br/>
在 Objective-C 中，可以通过 Method Swizzling 技术来实现 AOP，下面我们通过交换两个方法的实现代码来向已存在的方法中添加其它功能。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &lt;objc/runtime.h&gt; </span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="bp">UIViewController</span> <span class="nl">(Tracking)</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">load</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
</span><span class='line'>    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="kt">Class</span> <span class="n">aClass</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="k">class</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">SEL</span> <span class="n">originalSelector</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">viewWillAppear</span><span class="p">:);</span>
</span><span class='line'>        <span class="kt">SEL</span> <span class="n">swizzledSelector</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">swizzled_viewWillAppear</span><span class="p">:);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">Method</span> <span class="n">originalMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">aClass</span><span class="p">,</span> <span class="n">originalSelector</span><span class="p">);</span>
</span><span class='line'>        <span class="n">Method</span> <span class="n">swizzledMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="n">aClass</span><span class="p">,</span> <span class="n">swizzledSelector</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 如果要对类方法进行交换，使用下面注释的代码</span>
</span><span class='line'>        <span class="c1">// Class aClass = object_getClass((id)self);</span>
</span><span class='line'>        <span class="c1">// </span>
</span><span class='line'>        <span class="c1">// Method originalMethod = class_getClassMethod(aClass, originalSelector);</span>
</span><span class='line'>        <span class="c1">// Method swizzledMethod = class_getClassMethod(aClass, swizzledSelector);</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// 交换两个方法的实现</span>
</span><span class='line'>      <span class="c1">// 防止 aClass 不存在 originalSelector，所以添加一下试试，但指向地址为新方法地址</span>
</span><span class='line'>        <span class="kt">BOOL</span> <span class="n">didAddMethod</span> <span class="o">=</span> <span class="n">class_addMethod</span><span class="p">(</span><span class="n">aClass</span><span class="p">,</span> <span class="n">originalSelector</span><span class="p">,</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">swizzledMethod</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">swizzledMethod</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">didAddMethod</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="c1">// 添加成功，说明 aClass 不存在 originalSelector，所以替换 swizzledSelector 的 IMP 为 originalMethod，实质上它们都指向 swizzledMethod</span>
</span><span class='line'>            <span class="n">class_replaceMethod</span><span class="p">(</span><span class="n">aClass</span><span class="p">,</span> <span class="n">swizzledSelector</span><span class="p">,</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">));</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>          <span class="c1">// 添加失败，说明 aClass 存在 originalSelector，直接交换</span>
</span><span class='line'>            <span class="n">method_exchangeImplementations</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">,</span> <span class="n">swizzledMethod</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - Method Swizzling </span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 由于方法实现已经被交换，所以系统在调用 viewWillAppear: 时，实际上会调用 swizzled_viewWillAppear:</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">swizzled_viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// 下面代码表面上看起来会引起递归调用，由于函数实现已经被交换，实际上会调用 viewWillAppear:</span>
</span><span class='line'>   <span class="p">[</span><span class="nb">self</span> <span class="nl">swizzled_viewWillAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 在原有基础上添加其它功能(写日志等)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>
<br/>
需要注意一个问题，如果你用了 swizzled_viewWillAppear 作为方法名，那么如果你引用的第三方 SDK 中也用了这个方法名来做方法交换，那会造成方法的递归调用，所以你最好换一个不会被重复使用的方法名，例如 mx_swizzled_viewWillAppear。</p>

<p><br/></p>

<h1>其它</h1>

<p>我们可以通过 Runtime 特性来获得类的所有属性名称和类型，然后再通过 KVC 将 JSON 中的值填充给该类的对象。还可以在程序运行时为类添加方法或替换方法从而使对象能够更灵活的根据需要来选择实现方法。总之 Runtime 库就象一堆积木，只要发挥想象力便能实现各种各样的功能，但前提是你需要了解它。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 内存管理]]></title>
    <link href="https://lijingcheng.github.io/blog/2015/07/12/iosnei-cun-guan-li/"/>
    <updated>2015-07-12T15:07:54+08:00</updated>
    <id>https://lijingcheng.github.io/blog/2015/07/12/iosnei-cun-guan-li</id>
    <content type="html"><![CDATA[<p><strong>内存管理 - 指程序在运行时申请内存，并在使用完后释放内存的过程</strong></p>

<p>内存管理不当造成的主要问题便是内存泄漏和过度释放，虽然 ARC 使我们可以不去关注内存管理上的一些细节问题，但掌握一些相关知识还是很有必要的。</p>

<!-- more -->


<h1>一些概念</h1>

<ul>
<li><p>MRC：manual reference counting，自己编写内存管理代码（retain、release、autorelease&hellip;）</p></li>
<li><p>ARC：automatic reference counting，编译器会在编译阶段为代码加上优化过的内存管理代码，这样就可以让我们不必花费大量时间在内存管理上面，可以将更多的精力放在业务代码上。</p></li>
<li><p>内存泄漏：不再使用的对象内存没有释放掉，将导致内存占用无限增长，即便是使用 ARC，也会因为循环引用问题而造成内存泄露，并且还要注意与 CoreFoundation 对象进行桥接时要手动释放内存。</p></li>
<li><p>内存过度释放：释放了仍需要使用中的对象，将有可能导致应用崩溃</p></li>
</ul>


<p><br></p>

<h1>内存管理规则</h1>

<p>内存管理是建立在对象的拥有关系上的，当拥有对象后就要负责释放它，并且不要释放非自己持有的对象，具体规则如下：</p>

<ul>
<li>拥有对象所有权

<ul>
<li>通过 alloc/new/copy/mutableCopy 创建对象</li>
<li>在某些场景里避免一个对象被移除，可以对它进行 retain</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">Student</span> <span class="o">*</span> <span class="n">stu1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Student</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">Student</span> <span class="o">*</span> <span class="n">stu2</span> <span class="o">=</span> <span class="p">[</span><span class="n">stu1</span> <span class="k">retain</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>放弃对象拥有权

<ul>
<li>立即释放：给对象发送一个 release 消息</li>
<li>延迟释放：给对象发送一个 autorelease 消息</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="n">Student</span> <span class="o">*</span><span class="p">)</span><span class="nf">studentWithName:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Student</span> <span class="o">*</span><span class="n">stu</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Student</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithName</span><span class="p">:</span><span class="n">name</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">stu</span> <span class="n">autorelease</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>实现 dealloc 方法来释放对象自身内存与它所持有的资源，此方法由系统在该对象被销毁时自动调用</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="n">_firstName</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">_lastName</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">[</span><span class="nb">super</span> <span class="n">dealloc</span><span class="p">];</span> <span class="c1">// 必须先释放自己占有的资源再通过此行代码释放自己</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<h3>ARC 带来的变化</h3>

<ul>
<li>不能够自己调用 retain/release/autorelease，由编译器自动插入</li>
<li>dealloc 方法中不能调用 [super dealloc] ，由系统去调用并释放实例变量和 assocate 对象，weak 对象也是在这时被设置为 nil，我们只需要释放一些资源，如通知、KVO 等</li>
</ul>


<p><br></p>

<h1>引用计数</h1>

<p>内存管理规则中的对象所有权是通过引用计数来实现，除了常量以外，每个对象都有一个引用计数。</p>

<ul>
<li>创建对象时，计数为 1</li>
<li>给对象发送 retain 消息时，计数加 1</li>
<li>给对象发送 release 消息时，计数减 1</li>
<li>给对象发送 autorelease 消息时，计数在当前自动释放池代码块结束时减 1</li>
<li>当对象的计数为 0 时将被销毁</li>
</ul>


<p><img src="https://lijingcheng.github.io/images/retaincount.jpeg" height="600" width="600" alt="" /></p>

<h1>属性修饰符</h1>

<h3>MRC 中包括 assign/copy/retain</h3>

<ul>
<li>assign：表示在 setter 中仅是简单的赋值，不改变引用计数，一般用来修饰基本类型和 delegate 属性</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">)</span> <span class="bp">NSInteger</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">)</span> <span class="kt">id</span> <span class="n">delegate</span><span class="p">;</span> <span class="c1">// 避免引用循环，但要在适当时候设置为 nil</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 对应 setter 方法</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setCount:</span><span class="p">(</span><span class="bp">NSInteger</span><span class="p">)</span><span class="nv">count</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">_count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>copy：表示在 setter 中将参数进行内存 copy 后再进行赋值，一般用于不可变字符串、字典、Block</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">userName</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 对应 setter 方法</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setUserName:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">userName</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">id</span> <span class="n">tempName</span> <span class="o">=</span> <span class="p">[</span><span class="n">userName</span> <span class="k">copy</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">_userName</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'>  <span class="n">_userName</span> <span class="o">=</span> <span class="n">tempName</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>retain：表示在 setter 中将参数对象 retain 后再进行赋值，一般用于可变字符串、可变字典及其他对象</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">retain</span><span class="p">)</span> <span class="bp">NSMutableString</span> <span class="o">*</span><span class="n">userName</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 对应 setter 方法</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setUserName:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">userName</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="n">userName</span> <span class="k">retain</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">_userName</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'>  <span class="n">_userName</span> <span class="o">=</span> <span class="n">userName</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<h3>ARC 中包括 assign/weak/unsafe_unretained/copy/strong</h3>

<ul>
<li>assign：同 MRC 中的 assign 一样，只是不再用来修饰 delegate 对象。</li>
<li>weak：可以避免循环引用，用来修饰对象，但在 setter 中是简单赋值，不改变引用计数，和 assign 的区别在于属性被销毁后会被设置为 nil，所以能在继续使用该属性时避免程序崩溃，一般用来修饰 delegate 对象和 IBOutlet 对象。</li>
<li>unsafe_unretained：和 weak 相似，区别在于被销毁时不会置为 nil (unsafe)，它主要是为了兼容 4.0 系统而存在(iOS4 以及之前没有 weak)，由于 weak 会对性能有一点影响，因此对性能要求很高的地方可以考虑使用 unsafe_unretained 替换 weak</li>
<li>copy：同 MRC 中的 copy 一样</li>
<li>strong：同 MRC 中的 retain 一样</li>
</ul>


<h3>runtime 是如何将 weak 对象设置为 nil?</h3>

<p>weak 对象会被放入到一个 hash 表中，并用它指向的对象内存地址作为 key，所有指向它的 weak 指针以数组的形式作为 value，当此对象的 dealloc 方法被调用时，会用这个 key 将指向它的 weak 指针数组找出来，并将它们置为 nil，最后再从 weak hash 表中删除这条数据。</p>

<h3>列出几种有问题的写法</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 当源字符串是 NSMutableString 类型时，strong 是浅拷贝，copy 才是深拷贝，所以 str 会随着源字符串的修改而变化</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSMutableString</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 当源字符串是 NSString 类型时，不管用 strong 还是 copy 都是浅拷贝，所以这里 str 指向的仍然是 NSString 对象，当用 str 调用 NSMutableString 类的 insert 等方法时会报错&quot;找不到该方法&quot;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">)</span> <span class="kt">id</span> <span class="n">delegate</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// MRC 下需要自己在 dealloc 中将 delegate 设置为 nil， ARC 下需要用 weak 修饰 delegate 属性</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">newString</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// newString属性对应的 getter 也叫 newString，ARC下编译器不允许方法名以 alloc/init/new/copy/mutableCopy 开头，它会根据方法以什么开头来决定内存管理方式</span>
</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<h1>循环引用</h1>

<p>多个对象之间相互持有便会造成循环引用，从而导致 app 占用内存过高，通常打破它的方法就是将其中对象的引用关系设置为 weak，会造成循环引用的几种常见情况：</p>

<ul>
<li><p>NSTimer：初始化 timer 对象时会 strong 当前对象从而造成循环引用，当 repeat 为 NO 时 timer 执行完成后会自动调用 invalidate 方法打破循环引用，repeat 为 YES 时则需要根据业务逻辑在适当时候调用 invalidate</p></li>
<li><p>Block：需要注意的是即使我们在 block 内部直接用 _username 这种方式引用实例变例 block 仍然会 retain self，另外需要知道的就是并不是所有 block 都会造成循环引用，只有在互相持有时才会。（例如 [UIView animateWithDuration: animations:] 就没问题）</p></li>
<li><p>Delegate：delegate 属性要用 weak 修饰，使用 strong 会造成循环引用，使用 assgin 有可能会造成崩溃，需要注意的是 UIWebview 的 delegate 就是 assgin 的，所以需要我们自己将它设置为 nil。</p></li>
<li><p>自定义类之间的相互持有：这个其实才是最常见，并且最不容易被发现的，复杂些的是两个以上对象造成的相互持有，这种情况不容易被发现，可通过下面几种场景了解下</p>

<ul>
<li>A -> B -> C 没问题，即使 A -> C 也没问题，因为没有 “环”</li>
<li>A -> B -> C -> A 都释放不了</li>
<li>A -> B -> C -> B 只有 A 能释放，这也说明了不在 “环” 里的对象就不受影响，可以从下面的例子中证明这一点，我们可以将 Parent 中的 son 设置为 weak 来打破循环引用</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">class</span> <span class="n">Teacher</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">stu</span><span class="p">:</span> <span class="n">Student</span><span class="o">?</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">deinit</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;Teacher deinit&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="n">Student</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">parent</span><span class="p">:</span> <span class="n">Parent</span><span class="o">?</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">deinit</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;Student deinit&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="n">Parent</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">son</span><span class="p">:</span> <span class="n">Student</span><span class="o">?</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">deinit</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;Parent deinit&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">teacher</span> <span class="o">=</span> <span class="n">Teacher</span><span class="p">()</span>
</span><span class='line'><span class="k">let</span> <span class="n">student</span> <span class="o">=</span> <span class="n">Student</span><span class="p">()</span>
</span><span class='line'><span class="k">let</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">Parent</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="n">teacher</span><span class="p">.</span><span class="n">stu</span> <span class="o">=</span> <span class="n">student</span>
</span><span class='line'><span class="n">student</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
</span><span class='line'><span class="n">parent</span><span class="p">.</span><span class="n">son</span> <span class="o">=</span> <span class="n">student</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>除了靠正确编写代码来避免循环引用，还可以通过腾讯推出的 MLeaksFinder 工具来检测已经发生循环引用的代码，MLeaksFinder 的主要优点在于使用简单，不侵入业务代码，并且能够在出现问题时准确告诉你哪个对象没被释放，更重要的是它能够检测出 Instrument 检测不出来的很多问题。
<br></p>

<h1>AutoreleasePool</h1>

<p>当不再使用一个对象时应该将其释放，但是在某些情况下，我们很难理清一个对象什么时候不再使用，Objc 提供的自动释放池可以解决这个问题，只需要给这种对象发送 autorelease 消息，就会将该对象放到池子里，当池子被清理时，会给池里所有的对象发送 release 消息。</p>

<ul>
<li>每个 Runloop 在迭代时都会创建自动释放池，并在迭代后释放池子。如果是我们自己创建的池子，会在出了 @autoreleasepool 的大括号后进行清理。通常我们不用自己去创建池子，但是遇到循环次数较大时会导致内存占用不断增长，这时需要我们自己创建自动释放池。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>      <span class="bp">NSString</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>PS: NSArray 的 enumerateObjectUsingBlock&hellip;. 中也有一个 AutoreleasePool</p>

<ul>
<li><p>每个线程在维护自己的自动释放池时都会有一个或多个 AutoreleasePoolPage 对象，每个 Page 对象会开辟4096字节内存（虚拟内存一页的大小），它们之间以双向链表的形式组合而成，Page 对象通过 next 指针实现用栈的结构形式存储 autorelease 对象，next 指针会被初始化在栈底，当有 autorelease 对象入栈时，next 便会指向下一地址，当 Page 空间被占满便指向栈顶，这时如果再添加 autorelease 对象，便会交给新建的 Page 对象存储，并连接链表。</p></li>
<li><p>每添加一个 @autoreleasepool { &hellip; } 相当于实现下面代码</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">// 会在现有 AutoreleasePoolPage 对象中添加一个哨兵对象(nil)用来标记位置，主要用于在释放池子时标记哪些 autorelease 对象需要释放</span>
</span><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="n">objc_autoreleasePoolPush</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="p">...</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 给晚于哨兵对象后加入的所有 autorelease 对象发送 release 消息，并修改 next 指针，可以跨 Page（所以得用双向链表组合 Page 对象）</span>
</span><span class='line'><span class="n">objc_autoreleasePoolPop</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>PS:在添加 autorelease 对象时，如果发现线程没有 AutoreleasePoolPage 则会创建新的，所以不用担心子线程中没开启 Runloop 导致的内存泄露问题。</p>

<p>AutoreleasePoolPage 结构如下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">class</span> <span class="n">AutoreleasePoolPage</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">magic_t</span> <span class="k">const</span> <span class="n">magic</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">id</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span> <span class="c1">// 指向栈顶最新进来的 autorelease 对象的下一个位置</span>
</span><span class='line'>    <span class="kt">pthread_t</span> <span class="k">const</span> <span class="kr">thread</span><span class="p">;</span> <span class="c1">// 当前线程</span>
</span><span class='line'>    <span class="n">AutoreleasePoolPage</span> <span class="o">*</span> <span class="k">const</span> <span class="n">parent</span><span class="p">;</span> <span class="c1">// 上一个 Page</span>
</span><span class='line'>    <span class="n">AutoreleasePoolPage</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span> <span class="c1">// 下一个 Page</span>
</span><span class='line'>    <span class="kt">uint32_t</span> <span class="k">const</span> <span class="n">depth</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">uint32_t</span> <span class="n">hiwat</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过下面这张图可以更好的理解这些细节</p>

<p><img src="https://lijingcheng.github.io/images/autorelease_pool.jpeg" height="600" width="600" alt="" /></p>

<h2>Swift 中的内存管理</h2>

<p>Swift 使用 ARC 机制来跟踪和管理内存，并且只针对拥有引用计数的 class 实例，和 OC 相似它有 strong、weak、unnowned 三个关键字，默认为 strong。Swift 可以通过弱引用和无主引用来解决循环引用问题，它们都允许循环引用中的一个实例强引用而另外一个实例不保持强引用。</p>

<h3>weak VS unowned</h3>

<p>当可能造成循环引用的两个实例中的其中一个为可选类型，那么就将这个可能为 nil 的属性声明为 weak，相当于 OC 中的 __weak，它可以在这个属性释放时设置为 nil，所以不会导致 app 崩溃</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">weak</span> <span class="k">var</span> <span class="nl">delegate</span><span class="p">:</span> <span class="n">XXX</span><span class="o">?</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>当可能造成循环引用的两个实例有着几乎相同的生命周期，并且都不希望值为 nil 时，将有着强制依赖性的那个实例对另一个实例持有无主引用。ARC 无法在实例被销毁后将无主引用设为 nil，所以要小心无主引用实例释放后再次使用它时出现的运行时错误，unowned 相当于 OC 中的 __unsafe_unretained</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="kr">unowned</span> <span class="k">let</span> <span class="nl">timer</span><span class="p">:</span> <span class="n">Timer</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift 提供了闭包捕获列表来解决闭包引起的循环引用。捕获列表定义了闭包体内捕获一个或者多个引用类型的规则，跟解决两个类实例间的循环引用一样。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">__weak</span> <span class="k">typeof</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="n">weakSelf</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="nb">self</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="k">__strong</span> <span class="k">typeof</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="n">strongSelf</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">strongSelf</span> <span class="n">doSomething</span><span class="p">];</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="nb">self</span><span class="p">.</span><span class="n">closure</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="k">weak</span> <span class="nb">self</span><span class="p">]</span> <span class="k">in</span> <span class="c1">// 用 weak 而不是 unowned 会更安全些</span>
</span><span class='line'>    <span class="n">guard</span> <span class="k">let</span> <span class="n">strongSelf</span> <span class="o">=</span> <span class="nb">self</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span> <span class="c1">// 像 OC 一样</span>
</span><span class='line'>    <span class="n">strongSelf</span><span class="p">.</span><span class="n">doSomething</span><span class="p">()</span> <span class="c1">// 必须用 self 引用属性或方法</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>struct VS class</h3>

<p>首先我们要了解它们的区别：struct 是值类型，在栈中分配内存，访问控制是 public，class 是引用类型，在堆中分配内存，访问控制是 private 并且可以使用继承。</p>

<p>因为值类型在数据传递和拷贝时要比 class 安全，并且值类型所处的栈是线程独有的，所以不用考虑多线程问题，所以我们在使用时可以将存储数据的 model 类定义成 struct，而进行逻辑处理的类定义成 class。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">class</span> <span class="n">Student</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="k">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">stu1</span> <span class="o">=</span> <span class="n">Student</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="s">&quot;Bob&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">var</span> <span class="n">stu2</span> <span class="o">=</span> <span class="n">stu1</span>
</span><span class='line'><span class="n">stu2</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Leo&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">stu1</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="c1">// &quot;Leo&quot; 如果将 class 改成 struct，则 stu1.name 会打出 Bob，通常这也是我们想要的结果。</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">stu2</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="c1">// &quot;Leo&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>PS: 堆栈的区别以及 Swift 中的堆为什么要通过双向链表实现，可参考这篇<a href="https://www.jianshu.com/p/aca50c5a9d64">文章</a></p>

<h3>内存对齐</h3>

<p>Swift也有内存对齐的概念，使用内存对齐可以使 CPU 寻址更快从而提高访问速度。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">struct</span> <span class="n">St1</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">a</span><span class="p">:</span> <span class="n">Int8</span> <span class="c1">// 1 Bytes</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">b</span><span class="p">:</span> <span class="n">Int32</span> <span class="c1">// 4 Bytes</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">St2</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">a</span><span class="p">:</span> <span class="n">Int32</span> <span class="c1">// 4 Bytes</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">b</span><span class="p">:</span> <span class="n">Int8</span> <span class="c1">// 1 Bytes</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">St1</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nl">b</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="k">let</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">St2</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nl">b</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">MemoryLayout</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="nl">ofValue</span><span class="p">:</span> <span class="n">s1</span><span class="p">))</span> <span class="c1">// 1 + 3 + 4 = 8 (3 是需要对齐的内存)</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">MemoryLayout</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="nl">ofValue</span><span class="p">:</span> <span class="n">s2</span><span class="p">))</span> <span class="c1">// 4 + 1 = 5</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以 struct 和 class 中成员变量的声明顺序会影响它在内存中的占用空间，元素在放入内存时并不是紧密排列，而是从结构体存储的首地址开始，每一个元素放置到内存中时，它都会认为内存是以它自己的大小来划分的，因此元素放置的位置一定会在自己宽度的整数倍上开始，所以 St1 中 b 会从 4 开始。如果在 b 上面再定义一个 Int16 的变量，那么所需要的内存大小还是 8。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 多线程开发]]></title>
    <link href="https://lijingcheng.github.io/blog/2015/06/03/iosduo-xian-cheng-kai-fa/"/>
    <updated>2015-06-03T15:07:00+08:00</updated>
    <id>https://lijingcheng.github.io/blog/2015/06/03/iosduo-xian-cheng-kai-fa</id>
    <content type="html"><![CDATA[<p><strong>多线程 - <em>合理的线程分配能够提高程序的执行效率和资源利用率。</em></strong></p>

<p>GCD 基于 C API，Operation Queue 是在 GCD 基础上实现的，效率上较 GCD 会差一点点，但代码可读性和易用性较高，简单的任务可用 GCD 去实现，复杂一些的还是推荐使用 Operation Queue 来处理。微小的性能提升远不如写出可维护性高的代码来的实在。</p>

<!-- more -->


<h1>一些概念</h1>

<ul>
<li>进程和线程

<ul>
<li>进程是一个可执行程序，至少有一个线程，也可以包含多个线程</li>
<li>线程是执行程序最基本的单元，在进程中负责执行任务，每个进程至少有一个线程（主线程）</li>
</ul>
</li>
<li>主线程和子线程

<ul>
<li>主线程是随着进程的创建而创建的，主线程结束，其他线程也会结束</li>
<li>子线程由其他线程创建，一般子线程退出不会影响主线程</li>
</ul>
</li>
<li>同步和异步

<ul>
<li>同步任务在执行过程中会阻塞当前线程，直到任务执行完毕</li>
<li>异步任务在执行过程中不会阻塞当前线程</li>
</ul>
</li>
<li>串行队列和并行队列

<ul>
<li>串行队列中装载的线程是按进队列顺序一个一个执行</li>
<li>并行队列中装载的线程可以一起执行，可以通过设置最大并发数，限制同时最多执行几个线程</li>
</ul>
</li>
<li>并发和并行

<ul>
<li>并发在多核设备上是真正意义上的多任务同时运行，而在单核设备上是以分时共享的方式同时执行多个任务，需要先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程，因为这个过程很快所以会给我们并发执行的错觉</li>
<li>并行是真正意义上的多任务同时运行</li>
</ul>
</li>
<li>优先级和优先级反转

<ul>
<li>正常情况下优先级高的任务会比优先级低的先执行</li>
<li>优先级反转指程序在运行时，低优先级的任务由于某种原因不能释放掉锁，所以阻塞了高优先级的任务，而其他不需要该共享资源的低优先级任务会在高优先级任务之前执行，从而反转了任务的优先级。设置任务的优先级会让本来就复杂的并行编程变得更加复杂和不可预见，所以建议只使用默认优先级。</li>
</ul>
</li>
<li>生产者和消费者模式：是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。我们还可以使用多个线程来生产数据，同样可以使用多个消费线程来消费数据。而更复杂的情况是，消费者消费的数据，有可能需要继续处理，于是消费者处理完数据之后，它又要作为生产者把数据放在新的队列里，交给其他消费者继续处理。</li>
<li>为了防止多个线程抢夺同一个资源造成数据安全问题可采取以下措施

<ul>
<li>锁：在同一时刻，只允许一个线程访问某个特定资源

<ul>
<li>NSLock：最基本的锁，通过 lock 和 unlock 加锁解锁，@synchronize 会自动加锁解锁，但性能稍差</li>
<li>NSRecursiveLock：递归锁，可以在一个线程中反复获取锁不会造成死锁，可用在循环或递归操作中</li>
<li>NSConditionLock：条件锁，为加锁/解锁设置条件</li>
</ul>
</li>
<li>信号量：和锁很像，区别在于它可以控制同时访问同一资源的线程个数</li>
<li>串行队列：一个一个执行就避免了同步问题</li>
</ul>
</li>
<li>死锁：当多个线程在相互等待对方结束时，就会发生死锁，在下面的例子中，大多数时候 swap 方法都能正常运行，但是当两个线程使用相反的值来同时调用 swap 时，程序就会很可能由于死锁而被终止。线程1 获得了 X 的一个锁，线程2 获得了 Y 的一个锁。接着它们会同时等待另外一把锁，但是永远都不会获得。所以我们要尽量减少线程间资源共享，并确保共享的资源尽量简单。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void swap(A, B)
</span><span class='line'>{
</span><span class='line'>    lock(A);
</span><span class='line'>    lock(B);
</span><span class='line'>    
</span><span class='line'>    ...
</span><span class='line'>    
</span><span class='line'>    unlock(B);
</span><span class='line'>    unlock(A);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>swap(X, Y); // 线程1
</span><span class='line'>swap(Y, X); // 线程2</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<h1>NSThread</h1>

<p>使用 NSThread 创建并操作线程在使用上相对简单一些，但是需要我们自己去管理线程的生命周期。所以总的来说易用性上不如 GCD，功能上不如 Operation Queues。</p>

<p><strong><em>创建并启动线程</em></strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSThread</span> <span class="o">*</span><span class="kr">thread</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSThread</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">run</span><span class="p">:)</span> <span class="nl">object</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="kr">thread</span> <span class="n">start</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong><em>线程通讯</em></strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelectorOnMainThread:withObject:waitUntilDone:modes:</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelectorOnMainThread:withObject:waitUntilDone:</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelector:onThread:withObject:waitUntilDone:modes:</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelector:onThread:withObject:waitUntilDone:</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// perform 方法只对拥有 RunLoop 的线程有效，如果创建的线程没有添加 RunLoop，perform 的 selector 将无法执行，如果该线程不存在了，程序会 Crash。</span>
</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<h1>GCD（Grand Central Dispatch）</h1>

<p>GCD 是苹果为多核的并行计算提出的解决方案，它会自动地利用更多的 CPU 内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程）。同时它基于 C 语言，使用 Block 方式，使用起来更加方便灵活。</p>

<p><strong><em>最常用的使用方式</em></strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>     <span class="c1">// 异步耗时操作</span>
</span><span class='line'>     <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>          <span class="c1">// 由于 UIKit 中大部分类都不是线程安全的，所以需要在主队列中处理 UI</span>
</span><span class='line'>          <span class="c1">// dispatch 到主队列时 libDispatch 会唤醒主线程的 Runloop，并把 block 中的内容交给 Runloop 来处理，如果 dispatch 到其他线程则由 libDispatch 自己处理</span>
</span><span class='line'>     <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>GCD 有 5个不同队列：主队列，3个不同优先级的全局队列，以及一个优先级更低的后台队列（用于 I/O），我们还可以自己创建队列。通常不建议给队列设置优先级，因为多任务在访问共享资源时，可能会造成优先级反转问题。</p></li>
<li><p>获取主队列：主队列是串行队列，所以比较适合处理共享资源、更新 UI 等事情</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_main_queue</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>获取不同优先级的全局队列：全局队列是并行队列，支持数百个线程执行</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_HIGH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_LOW</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>如果经常需要在后台队列上执行开销庞大的操作，可通过 dispatch_queue_create 函数创建新队列，它接收两个参数，第一个是标识符，可以在 Instruments 或 lldb 调试程序时查看队列名字，第二个参数用来表示创建的队列是串行还是并行，DISPATCH_QUEUE_SERIAL 或 NULL 表示串行，DISPATCH_QUEUE_CONCURRENT 表示并行。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">queueLabel</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;%@.%p.queue1&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="nb">self</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">([</span><span class="n">queueLabel</span> <span class="n">UTF8String</span><span class="p">],</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">([</span><span class="n">queueLabel</span> <span class="n">UTF8String</span><span class="p">],</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>创建任务并交给队列处理</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 异步任务</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 同步任务</span>
</span><span class='line'><span class="n">dispatch_sync</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>同步任务很容易造成死锁，主要发生在串行队列中，并且同步任务所在队列为当前队列</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// dispatch_sync 将 block 中的任务加入到主队列队尾，按照队列的先进先出规则，该任务要等主线程中的其它任务执行完成后才能执行，但是因为 block 中的任务是要求同步执行的，所以主线程中的其它任务会等 block 中的任务执行完后才去执行，这时双方互相等待造成死锁。</span>
</span><span class='line'><span class="n">dispatch_sync</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 同上</span>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;queue1&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="p">...</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面例子会打印什么呢？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务1&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务2&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务3&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务4&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">while</span> <span class="p">(</span><span class="nb">YES</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>会先打印主线程中的 <code>任务4</code>，然后在主线程中执行 <code>while</code> 死循环，再打印新创建线程中的 <code>任务1</code>，<code>任务2</code> 是在主线程中执行，并且由于是同步操作，所以它会一直等待 <code>while</code> 结束才会执行，这时程序就卡死了。如果将 <code>任务2</code> 改成异步执行，那么 <code>任务3</code> 会先打印出来，但因为 <code>任务2</code> 是在主线程中，所以它还是会等待 <code>while</code> 结束，程序依旧会卡死。</p>

<ul>
<li>队列和线程的关系：队列可按照同步或异步的方式来组织并执行任务，同步异步的区别在于是否会阻塞当前线程，以及是否会开启新线程。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务1%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span> <span class="c1">// 在主线程中执行</span>
</span><span class='line'>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">serialQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;test.serialQueue&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">concurrentQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;test.concurrentQueue&quot;</span><span class="p">,</span><span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 同步执行的任务不管是位于串行队列还是并行队列，都是串行效果，它们都会在当前线程中执行（全局队列换成 serialQueue 或 concurrentQueue 结果是一样的）</span>
</span><span class='line'>    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务2%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 异步执行任务如果不是放在主队列中的话都会开启新的线程，如果任务位于串行队列，该队列中就算放入多个任务，也只会创建一个线程</span>
</span><span class='line'>    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">serialQueue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务3%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 异步执行的多个任务如果位于并行队列，会由操作系统决定要开启多少线程，有可能多个任务会共用一个线程。(全局队列换成 concurrentQueue 结果是一样的)</span>
</span><span class='line'>    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;任务4%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>NSTimer 在使用时会受 RunLoop 影响而导致延迟触发，当有更精准的计时需求时，可用 GCD 的计时器</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_source_t</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">dispatch_source_create</span><span class="p">(</span><span class="n">DISPATCH_SOURCE_TYPE_TIMER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</span><span class='line'><span class="n">dispatch_source_set_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">dispatch_walltime</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="c1">// 每秒触发一次</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_source_set_event_handler</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(...)</span> <span class="p">{</span>
</span><span class='line'>              <span class="n">dispatch_source_cancel</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span> <span class="c1">// 停止</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>      <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_resume</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span> <span class="c1">// 启动</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>dispatch_once 可以控制 Block 中的代码只被执行一次，通常用于创建单例，如果需要完整的单例，不被人 alloc 还需要进一步处理</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span> <span class="nf">sharedInstance</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">pred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">static</span> <span class="n">ClassName</span> <span class="o">*</span><span class="n">sharedObject</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pred</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">sharedObject</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">sharedObject</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>延迟处理，类似于 performSelector:withObject:afterDelay:，可指定时间和处理队列</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_after</span><span class="p">(</span><span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="mi">1</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">)),</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>当使用 foreach 遍历数组遇到效率问题时，可以考虑用 dispatch_apply 进行快速迭代，dispatch_apply 是 dispatch_sync 和 Dispatch Group 的关联 API，所以它会阻塞当前线程</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_apply</span><span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%zu&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span> <span class="c1">// 由于任务在并发队列中，所以 index 为乱序</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;done&quot;</span><span class="p">);</span> <span class="c1">// 由于当前线程被阻塞，所以迭代结束后，此句才会执行</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>iOS8 开始支持取消任务</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">serialQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;queue1&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">dispatch_block_t</span> <span class="n">firstBlock</span> <span class="o">=</span> <span class="n">dispatch_block_create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="kt">dispatch_block_t</span> <span class="n">secondBlock</span> <span class="o">=</span> <span class="n">dispatch_block_create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">serialQueue</span><span class="p">,</span> <span class="n">firstBlock</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">serialQueue</span><span class="p">,</span> <span class="n">secondBlock</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_block_cancel</span><span class="p">(</span><span class="n">secondBlock</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>多任务并发，都完成后触发另一个任务，可通过队列组实现，例如同时下载 2张图片，都下载完成后再将他们拼接起来</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 任务1</span>
</span><span class='line'><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 下载资源1</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 任务2</span>
</span><span class='line'><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 下载资源2</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 任务1 和任务2 都完成后会自动通知</span>
</span><span class='line'><span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 处理资源1和资源2</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>dispatch_barrier_async 在执行任务时会确保队列在此过程不会执行其它任务，可以在适当时候用来解决同步问题，它只在自己创建的队列上有这种作用，在全局并发队列和串行队列上，效果和 dispatch_sync 一样</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;queue1&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 在 dispatch_barrier_async 前面的任务执行结束后才执行，后面的任务等它执行完成后才会执行</span>
</span><span class='line'><span class="n">dispatch_barrier_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<ul>
<li>利用 dispatch_semaphore_t 信号量限制任务并发数，dispatch_semaphore_wait 函数会消耗一次这个可用数，如果可用数已满则开始等待，dispatch_semaphore_signal 函数每次执行都会将该可用计数加 1，以此来表明已经释放了资源，如果此刻有因为等待可用资源而被阻塞的任务，系统会从等待的队列中解锁一个任务来执行。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_semaphore_t</span> <span class="n">semaphore</span> <span class="o">=</span> <span class="n">dispatch_semaphore_create</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="c1">// 只有一个停车位</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">semaphore</span><span class="p">,</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">))))</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;不等了，开走&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;第一辆车来了，有位置直接停&quot;</span><span class="p">);</span> <span class="c1">// 1</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">semaphore</span><span class="p">,</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">))))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;不等了，开走&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;第二辆车,等到有位置后停车&quot;</span><span class="p">);</span> <span class="c1">// 3</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;第一辆车开走，这时第二辆车准备停车&quot;</span><span class="p">);</span> <span class="c1">// 2</span>
</span><span class='line'>    <span class="n">dispatch_semaphore_signal</span><span class="p">(</span><span class="n">semaphore</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">semaphore</span><span class="p">,</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">))))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;第三辆车不等了，开走&quot;</span><span class="p">);</span> <span class="c1">// 4</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;有位置，停车&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;第二辆车开走，第三辆车没有继续等&quot;</span><span class="p">);</span> <span class="c1">// 5</span>
</span><span class='line'>    <span class="n">dispatch_semaphore_signal</span><span class="p">(</span><span class="n">semaphore</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<h1>Operation Queues</h1>

<p>GCD 提供了更加底层的控制，而操作队列则在 GCD 之上实现了一些方便的功能，这些功能对于我们来说通常是最好最安全的选择，使用时需要将任务封装到一个 NSOperation 对象中，再将它添加到 NSOperationQueue，系统会将 NSOperationQueue 中的 NSOperation 取出并放到线程上执行。</p>

<ul>
<li>NSOperationQueue 默认是串行队列，可通过设置 maxConcurrentOperationCount 实现并发</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 获取主队列</span>
</span><span class='line'><span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">mainQueue</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSOperationQueue</span> <span class="n">mainQueue</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 创建队列</span>
</span><span class='line'><span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>NSOperation 不能够直接使用，可通过它的两个子类来封装任务，或者自定义 Operation

<ul>
<li>NSInvocationOperation：通过 SEL 方式添加任务</li>
<li>NSBlockOperation：通过 Block 方式添加任务</li>
<li>自定义 Operation：需要继承 NSOperation 类，并实现 main 方法
<br></li>
</ul>
</li>
<li>NSOperation 有一个非常实用的功能，可以添加和解除依赖。但要注意，不能相互依赖，否则会造成死锁，例如 A 依赖 B，B 依赖 A。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">operation1</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>   <span class="c1">// 下载资源1</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">operation2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 下载资源2</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">operation3</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 处理资源1和资源2</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">operation3</span> <span class="nl">addDependency</span><span class="p">:</span><span class="n">operation1</span><span class="p">];</span>      <span class="c1">// 任务三依赖任务一</span>
</span><span class='line'><span class="p">[</span><span class="n">operation3</span> <span class="nl">addDependency</span><span class="p">:</span><span class="n">operation2</span><span class="p">];</span>      <span class="c1">// 任务三依赖任务二</span>
</span><span class='line'>
</span><span class='line'><span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">mainQueue</span><span class="p">]</span> <span class="nl">addOperations</span><span class="p">:</span><span class="l">@[</span><span class="n">operation3</span><span class="p">,</span> <span class="n">operation2</span><span class="p">,</span> <span class="n">operation1</span><span class="l">]</span> <span class="nl">waitUntilFinished</span><span class="p">:</span><span class="nb">NO</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>在做多线程开发时，要合理的进行线程分配并且控制线程数量，为了追踪线程操作，每个线程还要起好名字。主线程主要用来做 UI 操作和数据处理，而日志记录，网络请求都可以安排在各自的线程中，为了检查 UI 操作是否在主线程中执行，可以 hook 掉 UIView 和 CALayer 的 <code>setNeedsDisplay</code> <code>setNeedsDisplayInRect:</code> <code>setNeedsLayout</code> 这三个方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 应用的生命周期]]></title>
    <link href="https://lijingcheng.github.io/blog/2015/03/28/iosying-yong-de-sheng-ming-zhou-qi/"/>
    <updated>2015-03-28T11:23:29+08:00</updated>
    <id>https://lijingcheng.github.io/blog/2015/03/28/iosying-yong-de-sheng-ming-zhou-qi</id>
    <content type="html"><![CDATA[<p><strong>生命周期 - 程序的生命周期是指应用程序从启动到结束整个阶段的全过程.</strong></p>

<p>点击应用图标打开程序，系统会首先通过 main 函数进行相关设置，然后通过 RunLoop 保持程序能够始终运行并监听处理分发事件，当没有事件发生时 RunLoop 便处于睡眠状态，节省资源。当发生事件后，RunLoop 将事件对象分发给相应视图处理。当用户按下 Home 键，应用会在进入后台后短暂运行，直到被系统挂起。</p>

<!-- more -->


<h1>main 函数</h1>

<p>main 函数是 app 的入口函数</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">UIApplicationMain</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">AppDelegate</span> <span class="k">class</span><span class="p">]));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<ul>
<li>在进入 main 函数之前，系统会由 dyld（the dynamic link editor）加载相关动态链接库，然后再初始化 runtime 环境，并由 runtime 触发 + load 方法，所以不要在 load 方法里执行耗时任务，否则会影响启动时间。</li>
<li>@autoreleasepool 用来管理主线程中标记为自动释放的对象。</li>
<li>UIApplicationMain 根据传入参数以及 info.plist 文件来初始化 app

<ul>
<li>argc 和 argv 参数在 iOS 应用中用不到</li>
<li>第三个参数为 app 的首要类名，用来监听并管理应用的生命周期，默认使用 UIApplication</li>
<li>最后一个参数为 app 首要类的代理类，它负责实际处理 UIApplication 监听到的应用程序生命周期事件，具体参考 UIApplicationDelegate</li>
<li>main 函数会在初始化 app 后启动主线程及 RunLoop</li>
</ul>
</li>
</ul>


<h1>RunLoop</h1>

<p>RunLoop 能够保持程序始终运行并监听处理分发事件，当没有事件发生时进入休眠状态，有事件发生时系统会将接收到的事件放在一个队列里，然后唤醒 RunLoop 依次处理事件，使用队列不仅可以解决线程同步问题也促使我们要把更新 UI 的代码放在主线程中运行，以免由于多个线程抢占资源产生奇怪的问题。RunLoop 可以接收的事件来自两种不同的来源，分别是输入源和定时源，输入源传递异步事件，事件通常来自于其他线程或程序，如一些 UI 事件等。定时源则传递同步事件，发生在特定时间或者重复的时间间隔，如 NSTimer。</p>

<p>RunLoop 的开启和退出</p>

<ul>
<li>苹果提供了 NSRunLoop 和 CFRunLoopRef 来操作 Runloop，CFRunLoopRef 是线程安全的，NSRunLoop 基于 CFRunLoopRef 并提供了面向对象的 API，API 不是线程安全的</li>
<li>苹果不允许我们直接创建 Runloop，只能在线程内部通过 <code>[NSRunLoop currentRunLoop]</code> 来获取，第一次调用此方法时便会创建 Runloop</li>
<li>主线程的 Runloop 是默认开启的，子线程需要我们自己开启，并且在开启后通过添加 port 来监听事件，否则 RunLoop 在启动后便会结束（除了 NSTimer）</li>
<li>可以通过给 RunLoop 设置过期时间来使 Runloop 能够退出，或者通过 CFRunLoopStop 直接退出（会在执行完正在运行的事件后退出，并且如果给 Runloop 添加了 port，那么需要 remove port）</li>
</ul>


<p>那么什么情况下需要我们在子线程中开启并使用 RunLoop 呢？</p>

<ul>
<li>创建常驻线程，可以像 AFN 那样给新线程开启 Runloop 的同时添加端口来监听事件，这样它就能一直处于等待事件的状态中，线程就不会结束了。</li>
<li>线程间需要持续交互，需要在开启 Runloop 时同时指定一个用于唤醒它的 NSPort 端口对象，然后使用端口对象来进行多线程间的通信。</li>
<li>使用 NSTimer 或 performSelector 系列方法。

<ul>
<li>performSelecter:afterDelay: 会创建 timer 并添加到当前线程的 RunLoop 中，如果当前线程没有 RunLoop，此方法失效。</li>
<li>performSelector:onThread: 会创建 timer 并添加到指定线程的 RunLoop 中，如果指定线程没有 RunLoop，此方法失效。</li>
</ul>
</li>
</ul>


<p><br/>
不同的事件源会运行在 RunLoop 的不同模式中，它们只有在相匹配的情况下才会被处理。这种工作方式利于 RunLoop 更好的管理和处理事件，使它们之间不相互影响。</p>

<ul>
<li>NSTimer 运行在 NSDefaultRunLoopMode 模式下。</li>
<li>列表滚动事件运行在 UITrackingRunLoopMode 模式下。</li>
<li>NSRunLoopCommonModes 包含 NSDefaultRunLoopMode 和 UITrackingRunLoopMode。</li>
</ul>


<p>我们可以通过改变一些事件操作的 RunloopMode 来提高用户体验</p>

<ul>
<li>在列表中加载图片时，让加载图片的操作处于 NSDefaultRunLoopMode 中，这样在列表滚动时便不会加载图片，列表的滚动速度便会有所提升</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">imageView</span> <span class="nl">performSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">setImage</span><span class="p">:)</span>
</span><span class='line'>                           <span class="nl">withObject</span><span class="p">:</span><span class="n">image</span> <span class="nl">afterDelay</span><span class="p">:</span><span class="mi">0</span>
</span><span class='line'>                              <span class="nl">inModes</span><span class="p">:</span><span class="l">@[</span><span class="n">NSDefaultRunLoopMode</span><span class="l">]</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在列表中使用 NSTimer 时，默认情况下在滚动时 timer 会停止，这时可以将 timer 运行在 NSRunLoopCommonModes 下，便可以在表格静止以及滚动时都能够正常运行。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">addTimer</span><span class="p">:</span><span class="n">timer</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">NSRunLoopCommonModes</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是 NSTimer 并不是以子线程的方式运行，它只是在 RunLoop 里注册了一下，RunLoop 会根据 timer 的设置情况去检测并触发，所以任务在执行过程中一旦出现延迟，那么会丢失执行次数，如果对精确度有要求的话，可以使用 dispatch_time，GCD 不受 RunLoop 影响。</p>

<blockquote><p>关于 RunLoop 的具体介绍详见<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">官方文档</a></p></blockquote>

<p><br/></p>

<h1>事件传递&amp;事件响应</h1>

<p>当发生触摸操作后，系统会将这一事件封装成 UIEvent 对象并放到由 UIApplication 管理的事件队列中，再由 RunLoop 接收事件并传递给触摸点所在的视图，该视图即为 &ldquo;hit-test视图"，而查找这一视图的过程就叫做 "hit-testing"。hit-testing 过程大致如下:</p>

<ul>
<li>RunLoop 将接收到的事件分发给 UIWindow。</li>
<li>UIWindow 通过 hitTest:withEvent: 方法在视图树中递归查找触摸点所在的视图。</li>
<li>当前视图通过 hitTest 方法调用 pointInside:withEvent: 来判定触摸点是否在当前视图，如果不在 hitTest 返回 nil，在的话则从当前视图的 subViews 末尾向前遍历，依次向每个 subView 发送 hitTest 消息，以此规则一直到某个 subView 不再返回 nil 或遍历完成。</li>
<li>最终由最后一个遍历到并且不返回 nil 的视图作为 hit-test视图。</li>
</ul>


<p>在这过程中如果视图不具备响应事件的条件(userInteractionEnabled 或 enabled 为 NO，hidden=YES 或 alpha=0)，那么 hitTest 就不会调用 pointInside 方法，会直接返回 nil，该视图的子视图也就不会被遍历到，如果我们想改变这一点，或者有别的需求需要改变事件传递的规则，那么需要自定义父视图并重写以下方法来控制子视图。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nf">hitTest:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">point</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">pointInside:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">point</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><br/>
如果想在某种情况下不响应事件，可以在适当时调用 UIApplication 的以下方法停止和恢复事件接收和分发。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">beginIgnoringInteractionEvents</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">endIgnoringInteractionEvents</span>
</span></code></pre></td></tr></table></div></figure>


<p><br/>
如果 hit-test 视图不处理收到的事件（没有重写 touches 方法，或者只是在 touches 方法里调用 [super touches..]），则通过响应者链机制寻找其它响应者来处理。</p>

<p>响应链由一系列链接在一起的响应者组成。如果一个响应者不能处理事件，则会将事件沿着响应链传到下一响应者。下一响应者有可能是它的父视图也可能是它所在的 ViewController，系统会以此类推一直传递到 UIApplication。如果整个过程都没有响应者响应事件，该事件就会被丢弃。否则事件便会停止传递交由响应者处理。</p>

<p><br/>
在开发过程中，有时我们不得不定义一个很小的按钮，为了避免发生用户点不到按钮的事情发生，可以利用上面的知识，扩大按钮的有效范围，只要触碰到按钮附近就使按钮响应事件。解决办法就是自定义继承 UIButton 的视图，并重写 pointInside:withEvent 方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">pointInside:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">point</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">CGRect</span> <span class="n">bounds</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">widthDelta</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="mf">44.0</span> <span class="o">-</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">heightDelta</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="mf">44.0</span> <span class="o">-</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectInset</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">widthDelta</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">heightDelta</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">CGRectContainsPoint</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">point</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><br/>
当子视图添加到父视图后，其响应事件的范围就是父视图的 bounds，如果部分界面超出了这个范围，则超出部分无法响应事件，未超出部分仍然可以响应事件，为了使超出父视图范围的子视图也能响应事件，需要实现主视图的 <code>- hitTest:withEvent:</code> 方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nf">hitTest:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">point</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">UIView</span> <span class="o">*</span><span class="n">view</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">hitTest</span><span class="p">:</span><span class="n">point</span> <span class="nl">withEvent</span><span class="p">:</span><span class="n">event</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">view</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="bp">UIView</span> <span class="o">*</span><span class="n">subView</span> <span class="k">in</span> <span class="nb">self</span><span class="p">.</span><span class="n">subviews</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="bp">CGPoint</span> <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">subView</span> <span class="nl">convertPoint</span><span class="p">:</span><span class="n">point</span> <span class="nl">fromView</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">CGRectContainsPoint</span><span class="p">(</span><span class="n">subView</span><span class="p">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">view</span> <span class="o">=</span> <span class="n">subView</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">view</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><br/></p>

<h1>前后台切换</h1>

<p>在程序进入后台后仍然能够在短时间里执行一些代码，然后便进入挂起状态，程序在挂起后仍然会驻留在内存中，但是不能执行代码，直到 iOS 系统内存降低发出警告后才会把相对耗内存的挂起程序清除掉。</p>

<p>当程序在前后台切换时，系统会调用 UIApplicationDelegate 的相关代理方法并发送通知，我们可以在不同情况下做出不同处理，例如在进入后台时暂停某些操作或存储某些数据，当恢复到前台时再恢复之前的暂停操作或读取之前存储的数据。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在 Git 环境下维护多个 SSH Keys]]></title>
    <link href="https://lijingcheng.github.io/blog/2015/03/01/zai-githuan-jing-xia-wei-hu-duo-ge-ssh-keys/"/>
    <updated>2015-03-01T18:11:42+08:00</updated>
    <id>https://lijingcheng.github.io/blog/2015/03/01/zai-githuan-jing-xia-wei-hu-duo-ge-ssh-keys</id>
    <content type="html"><![CDATA[<p>SSH Key - 通过 SSH 密钥登录服务器，可以避免密码在网络中传输，也就保证了登录过程的安全，也不会因此受到中间人攻击，如果在 SSH 密钥登录基础上再加上密码短语 （passphrase）的使用，安全性便会再次提高。</p>

<!-- more -->


<p>作为一个程序猿，我们经常会往公司的 Git 服务器上提交代码，还有很多猿在 GitHub 上也有自己的开源项目，不管是公司的服务器还是 GitHub 服务器都会在你提交代码时通过维护在服务器上的公钥进行验证，如果你希望能够以不同身份向不同服务器提交代码，那么你需要在机器上维护多个 SSH Key，并且将不同的公钥添加到不同的服务器中。</p>

<p>下面介绍下在已经拥有一个用于公司服务器的 SSH Key 后，如何再添加一个用于 GitHub 的 SSH Key。</p>

<p>首先进入 .ssh 目录</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd ~/.ssh</span></code></pre></td></tr></table></div></figure>


<p>创建用于 GitHub 的 SSH Key，根据提示将名字设置为 id_rsa_github</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh-keygen -t rsa -C "注册 GitHub 时用的 Email"</span></code></pre></td></tr></table></div></figure>


<p>因为 Git 默认只读取 id_rsa，为了让 SSH 识别新的私钥，需将 id_rsa_github 添加到 SSH Agent 中</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh-add id_rsa_github</span></code></pre></td></tr></table></div></figure>


<p>将 id_rsa_github.pub 中的公钥复制到 GitHub 帐户中，并为 GitHub 项目指定提交代码时使用哪个用户</p>

<pre><code>- 通过 SourceTree 设置：项目 -&gt; 设置 -&gt; 高级 -&gt; 直接修改用户名和邮箱
- 进入项目根目录，然后打开 .git 目录下的 config 文件，修改 [user] 部分
</code></pre>

<p>如果 .ssh 目录下没有 config 文件，便新增一个</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>touch config</span></code></pre></td></tr></table></div></figure>


<p>配置 config 文件，指明服务器及所使用的密钥</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Host github.com
</span><span class='line'>IdentityFile ~/.ssh/id_rsa_github
</span><span class='line'>
</span><span class='line'>Host gitlab.xxx.com
</span><span class='line'>IdentityFile ~/.ssh/id_rsa</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<blockquote><p>如果你使用 SourceTree 的话，也可以在添加 GitHub 帐户时直接生成密钥，它会帮你配置好一切并上传，这样就省去了上面一切操作步骤，但仅支持添加 GitHub 和 BitBucket 账号。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 CocoaPods 做依赖管理]]></title>
    <link href="https://lijingcheng.github.io/blog/2015/02/11/yong-cocoapodswei-iosxiang-mu-zuo-yi-lai-guan-li/"/>
    <updated>2015-02-11T15:10:58+08:00</updated>
    <id>https://lijingcheng.github.io/blog/2015/02/11/yong-cocoapodswei-iosxiang-mu-zuo-yi-lai-guan-li</id>
    <content type="html"><![CDATA[<p><strong><a href="http://www.cocoapods.org">CocoaPods</a> - <em>Get on with building your app, not duplicating code.</em></strong></p>

<p>可以为 Cocoa 和 Swift 项目使用的第三方类库和我们自己的私有类库提供依赖管理，我们只需要告诉它要使用的类库名称和版本，然后再执行一条命令，它就会自动将这个类库的源码从 GitHub 上下载到本地，并且为工程设置好相应的系统依赖和编译项。使用 CocoaPods 可以大大节省我们在设置和更新类库时所花的时间。</p>

<!-- more -->


<h1>准备工作</h1>

<p>由于 CocoaPods 是用 Ruby 写的，并且主要用于管理 GitHub 上的第三方类库，所以在安装前需要有 Ruby 环境和 Git 环境。Git 环境可以通过下载 Xcode 中的 Command Line Tools 建立。Ruby 环境可以使用 Mac 系统默认提供的版本，也可以通过以下命令将它更新至最新版。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo gem update –system</span></code></pre></td></tr></table></div></figure>


<p>
<br/>
为了提高下载速度，还需要将 Ruby 的源更改为 ruby-china</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem sources -a https://gems.ruby-china.com/  (添加)
</span><span class='line'>gem sources -r https://rubygems.org/  (删除)
</span><span class='line'>gem sources -l  (检查一下)</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><br/></p>

<h1>安装并使用 CocoaPods</h1>

<ul>
<li>安装 CocoaPods</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo gem install cocoapods (更新命令也是这个)
</span><span class='line'>
</span><span class='line'>// 新版 OSX 安装时会报下面这个错，可另外指定 CocoaPods 的安装目录
</span><span class='line'>ERROR:  While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/xcodeproj
</span><span class='line'>
</span><span class='line'>sudo gem install -n /usr/local/bin cocoapods
</span><span class='line'>或者安装 pre release 版本
</span><span class='line'>sudo gem install -n /usr/local/bin cocoapods --pre</span></code></pre></td></tr></table></div></figure>


<ul>
<li>下载 CocoaPods 维护的所有 podspec 文件到"~/.cocoapods/repos/master/Specs"</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod setup</span></code></pre></td></tr></table></div></figure>


<blockquote><p>更新 spec 也用这个命令，podspec 文件主要用来描述依赖库的名称、版本、作者、下载地址等信息。通过 CocoaPods 下载第三方类库，其实就是根据我们指定的类库名称找到相关的 podspec，然后再根据 podspec 文件中指定的地址去下载。</p></blockquote>

<ul>
<li>查看 CocoaPods 管理的依赖库信息</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod search 依赖库的名字</span></code></pre></td></tr></table></div></figure>


<ul>
<li>新建 Podfile 文件，此文件用于配置项目所需要使用的依赖库</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd "项目根目录"
</span><span class='line'>pod init</span></code></pre></td></tr></table></div></figure>


<ul>
<li>打开 Podfile 文件，按下面内容配置依赖关系，Podfile 的更详细配置方法可参照<a href="http://guides.cocoapods.org/syntax/podfile.html">官方文档</a></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source 'https://github.com/CocoaPods/Specs.git'
</span><span class='line'>
</span><span class='line'>platform :ios, '7.0'
</span><span class='line'>inhibit_all_warnings!
</span><span class='line'>
</span><span class='line'>pod 'AFNetworking', '2.5.1' </span></code></pre></td></tr></table></div></figure>


<blockquote><p>上面内容的意思是，specs 文件由 CocoaPods 提供，项目需要使用支持 ios7.0 及以上的依赖库，并且为主 target 配置了 2.5.1 版本的 AFNetworking，并忽略依赖库中的所有警告。依赖库的版本号建议明确指定，这样可以避免更新依赖库后对现有工程造成影响，而且可以保证团队所有开发人员使用的版本一致。</p></blockquote>

<p>如果你的项目有多个 target，那么需要按下面的方式配置 pod，否则依赖关系只能作用于主 target。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#Tests target 不仅使用主 target 的依赖库还需要添加自己的
</span><span class='line'>target 'Tests' do
</span><span class='line'>  pod "Tests 需要的依赖库"
</span><span class='line'>end
</span><span class='line'>或
</span><span class='line'>#Tests target 不需要主 target 的依赖库
</span><span class='line'>target 'Tests', :exclusive =&gt; true do
</span><span class='line'>  pod "Tests 需要的依赖库"
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<ul>
<li>根据 Podfile 下载安装依赖库</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod install (添加或删除依赖库后也是通过此命令更新)</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>CocoaPods 会自动为项目工程设置好相应的系统依赖和编译参数，当依赖库安装完成后，打开项目根目录，会发现多了以下文件及文件夹</strong></p>

<ol>
<li>&ldquo;.xcworkspace"，以后必须通过此 workspace 打开项目。</li>
<li>&ldquo;Pods"，CocoaPods 将 Profile 中配置的所有依赖库都下载到这里，并且将所有依赖库打包成单独的静态库供主项目使用。</li>
<li>&ldquo;Podfile.lock"，用于保存已经安装的依赖库版本信息。如果在配置依赖库时没有明确指定版本，那么必须将此文件加入到版本控制中，否则有可能造成团队开发中不同成员使用的依赖库版本不一致。</li>
</ol>
</blockquote>

<ul>
<li>查看所下载的依赖库是否有新版本</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod outdated</span></code></pre></td></tr></table></div></figure>


<ul>
<li>更新本地 podspec 仓库并更新依赖库</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod update</span></code></pre></td></tr></table></div></figure>


<ul>
<li>更新依赖库且不更新本地 podspec 仓库（速度会快很多）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod update --no-repo-update</span></code></pre></td></tr></table></div></figure>


<ul>
<li>将 CocoaPods 从项目中移除，并还原其对 Xcode 的配置修改（1.0 版本开始支持，以前需要用第三方提供的方式）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod deintegrate</span></code></pre></td></tr></table></div></figure>


<p>PS: 如果你使用的是 CocoaPods 1.0+，那么你可以下载 CocoaPods app 试一下，可以省去一些命令操作，并且在修改 Podfile 文件时，会有代码提示。</p>

<p><br/></p>

<h1>让自己的开源项目支持 CocoaPods</h1>

<h4>通过 CocoaPods 创建项目会让整个事情变的简单一些</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod lib create FMDBHelper</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>创建完成后项目根目录会包含以下文件及文件夹</strong></p>

<ol>
<li>&ldquo;.travis.yml"，通过 travis-ci 做持续集成要用到的配置文件，一般情况下使用默认配置就可以，如果需要使用持续集成服务，还需要以 GitHub 帐号登录 <a href="https://travis-ci.org">travis-ci</a>，并打开对应项目开关。</li>
<li>&ldquo;.gitignore"，建议将 Pods 目录也加入到忽略范围</li>
<li>&ldquo;LICENSE"，默认为 MIT</li>
<li>&ldquo;FMDBHelper.podspec"，通过 Cocoapods 下载项目时要用到的项目配置文件。</li>
<li>&ldquo;README.md"，通过 markdown 语法编写此文件，用于在 GitHub 上显示项目介绍。</li>
<li>&ldquo;Pod"，将自己的开源代码和资源文件放到这里</li>
<li>&ldquo;Example"，demo 工程，包含测试用的 target。</li>
</ol>
</blockquote>

<h4>在 demo 工程中开发并测试</h4>

<ul>
<li>将源代码和资源文件分别放到 Pod/Classes 和 Pod/Assets 目录下</li>
<li>用 pod install 命令为 demo 工程安装依赖库，以后只要新增依赖库的代码或资源文件都需要更新</li>
<li>开发测试完成后还需要修改 podspec 文件</li>
</ul>


<h4>将 podspec 发布到 CocoaPods 的 Git 库中</h4>

<ul>
<li>向 CocoaPods 注册你的信息，需要输入邮箱(与 podspec 中写的一致)和名字，稍后还需要验证 email</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod trunk register bj_lijingcheng@163.com "lijingcheng"</span></code></pre></td></tr></table></div></figure>


<ul>
<li>登录 GitHub，release 一版项目并打上标签，标签要与 podspec 中定义的一致</li>
<li>检查 spec 文件是否合格</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod spec lint FMDBHelper.podspec</span></code></pre></td></tr></table></div></figure>


<ul>
<li>检查并发布 spec 文件，以后需要升级也是用这个命令</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod trunk push FMDBHelper.podspec</span></code></pre></td></tr></table></div></figure>


<ul>
<li>更新本地 spec</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod setup (稍后便可以在 ~/.cocoapods/repos/master/Specs 下看到你的开源项目了)</span></code></pre></td></tr></table></div></figure>


<p><br/></p>

<h1>通过 CocoaPods 安装私有库</h1>

<p>可以按<a href="https://guides.cocoapods.org/making/private-cocoapods.html">官方指导</a>来做，大致步骤与在 GitHub 上维护开源项目相似，区别如下：</p>

<ul>
<li>需要通过 Git 建立自己的 spec 仓库，并在 Podfile 文件中填加 source</li>
<li>通过 pod repo 来查看现有的 spec 仓库</li>
<li>通过 pod repo add repo_name source_url 在 ~/.cocoapods/repos/ 目录下新建自己的 spec 仓库</li>
<li>通过 pod repo push &ndash;allow-warnings repo_name spec_name.podspec 命令将已经写好的 podspec 文件填加到 spec 仓库中</li>
<li>私有库新增版本后需要打 tag 并修改 podspec 文件中的 version，然后再次更新 spec 仓库</li>
<li>在 Podfile 中可直接通过 pod repo_name 安装私有库</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GitHub Pages + Octopress 搭博客]]></title>
    <link href="https://lijingcheng.github.io/blog/2015/01/04/zai-macxia-tong-guo-github-pages-plus-octopressda-jian-bo-ke/"/>
    <updated>2015-01-04T14:51:02+08:00</updated>
    <id>https://lijingcheng.github.io/blog/2015/01/04/zai-macxia-tong-guo-github-pages-plus-octopressda-jian-bo-ke</id>
    <content type="html"><![CDATA[<p><strong><a href="https://pages.github.com">Github Pages</a> - <em>Websites for you and your projects.</em></strong> <br/>
可用来搭建静态网站，提供免费域名、空间、无限流量，并且在世界各地都有较好的访问速度。不过网站也会轻易被人 clone，如果在意的话可以付费给 GitHub 从而使用私有库。
<br/><br/>
<strong><a href="http://octopress.org">Octopress</a> - <em>A blogging framework for hackers.</em></strong><br/>
开源的静态博客系统，可用来为我们的静态网站提供所需的 HTML。</p>

<!-- more -->


<h1>准备工作</h1>

<ul>
<li>需要有 Git 环境，最好为 GitHub 另外维护一个 SSH Key</li>
<li>在 GitHub 上新建名为 yourname.github.io 的版本库，之后可通过 yourname.github.io 域名来访问博客，如果你有自己的域名，可通过配置 Octopress 的 CNAME 文件进行关联</li>
<li>需要有 1.9.3 及以上版本的 ruby 环境。(通过 ruby &ndash;version 查看，如需升级可用 rvm 或 rbenv)</li>
<li>更改 ruby 的源，可提高下载速度</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem sources -a https://gems.ruby-china.com/  (添加)
</span><span class='line'>gem sources -r https://rubygems.org/  (删除)
</span><span class='line'>gem sources -l  (检查一下)</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><br/></p>

<h1>Octopress 环境搭建</h1>

<ul>
<li>安装 Octopress</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone git://github.com/imathis/octopress.git octopress</span></code></pre></td></tr></table></div></figure>


<ul>
<li>clone 完成后 cd octopress，然后安装所需依赖</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo gem install bundler 
</span><span class='line'>rbenv rehash 
</span><span class='line'>bundle install</span></code></pre></td></tr></table></div></figure>


<ul>
<li>安装默认模板</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake install</span></code></pre></td></tr></table></div></figure>


<ul>
<li>关联 GitHub Pages</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake setup_github_pages
</span><span class='line'>git@github.com:yourname/yourname.github.io.git</span></code></pre></td></tr></table></div></figure>


<ul>
<li>配置 <a href="http://octopress.org/docs/configuring">Octopress</a>，建议同时删除 HTML 和 CSS 中用不到的东西，可提高访问速度</li>
</ul>


<p><br/></p>

<h1>写博客并发布</h1>

<ul>
<li>新建文章（博客存储为 markdown 文件，位于 \octopress\source\_posts 目录下）</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_post["new_blog_title"]</span></code></pre></td></tr></table></div></figure>


<ul>
<li>生成静态网站</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake generate</span></code></pre></td></tr></table></div></figure>


<ul>
<li>通过 <a href="http://localhost:4000">http://localhost:4000</a> 预览静态网站，之后修改 markdown 后直接刷新即可</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake preview</span></code></pre></td></tr></table></div></figure>


<ul>
<li>部署并将 Octopress 生成的 HTML 等文件提交到 master 分支</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>


<blockquote><p>如果提交失败，提示让先 pull 文件，但是本地文件已经是最新的，可按下面方式解决：进入 _deploy 目录，执行 git reset –hard origin/master 将本地状态回退到和远程一样，然后回到根目录下重新 generate 并 deploy。</p></blockquote>

<ul>
<li>将 Octopress 修改过的 markdown 等资源文件提交到 source 分支</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add .
</span><span class='line'>git commit -m ‘your commit message’
</span><span class='line'>git push origin source</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<h2>如果更换了电脑或希望多台电脑能够写博客</h2>

<ul>
<li>首先需要下载 source 分支到你的电脑上</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone -b source git@github.com:lijingcheng/lijingcheng.github.io.git</span></code></pre></td></tr></table></div></figure>


<ul>
<li>然后进入下载目录</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd lijingcheng.github.io</span></code></pre></td></tr></table></div></figure>


<ul>
<li>下载 master 分支到 _deploy 目录</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone -b master git@github.com:lijingcheng/lijingcheng.github.io.git _deploy</span></code></pre></td></tr></table></div></figure>


<ul>
<li>生成网站并部署</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake generate
</span><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
</feed>
