
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>iOS多线程开发 - 风行的博客</title>
  <meta name="author" content="风行">

  
  <meta name="description" content="多线程 - 合理的线程分配能够提高程序的执行效率和资源利用率。 GCD基于C API，Operation Queue是在GCD基础上实现的OC API，效率上较GCD会差一点点，但代码可读性和易用性较高，简单的任务可用GCD去实现，复杂一些的还是推荐使用Operation Queue来处理。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://lijingcheng.github.io/blog/2016/06/03/iosduo-xian-cheng-kai-fa/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="风行的博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">风行的博客</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss email">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
    <li><a href="mailto:bj_lijingcheng@163.com" rel="subscribe-email" title="subscribe via email">邮箱</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="lijingcheng.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">归档</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">iOS多线程开发</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-06-03T15:07:00+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2016</span></span> <span class='time'>3:07 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><img class="left" src="http://7x00ed.com1.z0.glb.clouddn.com/thread.png" width="200" height="200"  >
<strong>多线程 - <em>合理的线程分配能够提高程序的执行效率和资源利用率。</em></strong></p>

<p>GCD基于C API，Operation Queue是在GCD基础上实现的OC API，效率上较GCD会差一点点，但代码可读性和易用性较高，简单的任务可用GCD去实现，复杂一些的还是推荐使用Operation Queue来处理。微小的性能提升远不如写出可维护性高的代码来的实在。</p>

<!-- more -->


<h1>一些概念</h1>

<ul>
<li>进程和线程

<ul>
<li>进程是一个可执行程序，至少有一个线程，也可以包含多个线程</li>
<li>线程在进程中负责执行任务，每个进程至少有一个线程（主线程）</li>
</ul>
</li>
<li>主线程和子线程

<ul>
<li>主线程是随着进程的创建而创建的，主线程结束，其他线程也会结束</li>
<li>子线程由其他线程创建，一般子线程退出不会影响主线程</li>
</ul>
</li>
<li>同步和异步

<ul>
<li>同步任务在执行过程中会阻塞当前线程，直到任务执行完毕</li>
<li>异步任务在执行过程中不会阻塞当前线程</li>
</ul>
</li>
<li>串行队列和并行队列

<ul>
<li>串行队列中装载的线程是按进队列顺序一个一个执行</li>
<li>并行队列中装载的线程可以一起执行，可以通过设置最大并发数，限制同时最多执行几个线程</li>
</ul>
</li>
<li>并发和并行

<ul>
<li>并发在多核设备上是真正意义上的多任务同时运行，而在单核设备上是以分时共享的方式同时执行多个任务，需要先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程，因为这个过程很快所以会给我们并发执行的错觉</li>
<li>并行是真正意义上的多任务同时运行</li>
</ul>
</li>
<li>优先级和优先级反转

<ul>
<li>正常情况下优先级高的任务会比优先级低的先执行</li>
<li>优先级反转指程序在运行时，低优先级的任务由于某种原因不能释放掉锁，所以阻塞了高优先级的任务，而其他不需要该共享资源的低优先级任务会在高优先级任务之前执行，从而反转了任务的优先级。设置任务的优先级会让本来就复杂的并行编程变得更加复杂和不可预见，所以建议只使用默认优先级。</li>
</ul>
</li>
<li>生产者和消费者模式：是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。我们还可以使用多个线程来生产数据，同样可以使用多个消费线程来消费数据。而更复杂的情况是，消费者消费的数据，有可能需要继续处理，于是消费者处理完数据之后，它又要作为生产者把数据放在新的队列里，交给其他消费者继续处理。</li>
<li>线程同步是为了防止多个线程抢夺同一个资源造成的数据安全问题所采取的一种措施

<ul>
<li>锁：在同一时刻，只允许一个线程访问某个特定资源

<ul>
<li>NSLock：最基本的锁，通过lock和unlock加锁解锁，@synchronize会自动加锁解锁，但性能稍差</li>
<li>NSRecursiveLock：递归锁，可以在一个线程中反复获取锁不会造成死锁，可用在循环或递归操作中</li>
<li>NSConditionLock：条件锁，为加锁/解锁设置条件</li>
</ul>
</li>
<li>信号量：和锁很像，区别在于它可以控制同时访问同一资源的线程个数</li>
<li>串行队列：一个一个执行就避免了同步问题</li>
</ul>
</li>
<li>死锁：当多个线程在相互等待对方结束时，就会发生死锁，在下面的例子中，大多数时候swap方法都能正常运行，但是当两个线程使用相反的值来同时调用swap时，程序就会很可能由于死锁而被终止。线程1获得了 X 的一个锁，线程2获得了 Y 的一个锁。接着它们会同时等待另外一把锁，但是永远都不会获得。所以我们要尽量减少线程间资源共享，并确保共享的资源尽量简单。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void swap(A, B)
</span><span class='line'>{
</span><span class='line'>    lock(A);
</span><span class='line'>    lock(B);
</span><span class='line'>    
</span><span class='line'>    ...
</span><span class='line'>    
</span><span class='line'>    unlock(B);
</span><span class='line'>    unlock(A);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>swap(X, Y); // 线程1
</span><span class='line'>swap(Y, X); // 线程2</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<h1>NSThread</h1>

<p>使用NSThread创建并操作线程在使用上相对简单一些，但是需要我们自己去管理线程的生命周期。所以总的来说易用性上不如GCD，功能上不如Operation Queues。</p>

<p><strong><em>创建并启动线程</em></strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSThread</span> <span class="o">*</span><span class="kr">thread</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSThread</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">run</span><span class="p">:)</span> <span class="nl">object</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="kr">thread</span> <span class="n">start</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong><em>线程通讯</em></strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelectorOnMainThread:withObject:waitUntilDone:modes:</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelectorOnMainThread:withObject:waitUntilDone:</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelector:onThread:withObject:waitUntilDone:modes:</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelector:onThread:withObject:waitUntilDone:</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// perform方法只对拥有runloop的线程有效，如果创建的线程没有添加runloop，perform的selector将无法执行</span>
</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<h1>GCD（Grand Central Dispatch）</h1>

<p>GCD是苹果为多核的并行计算提出的解决方案，它会自动地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程）。同时它基于C语言，使用Block方式，使用起来更加方便灵活。</p>

<p><strong><em>最常用的使用方式</em></strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>     <span class="c1">// 异步耗时操作</span>
</span><span class='line'>     <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>          <span class="c1">// 由于UIKit中大部分类都不是线程安全的，所以需要在主队列中处理UI</span>
</span><span class='line'>     <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>GCD有5个不同队列：主队列，3个不同优先级的全局队列，以及一个优先级更低的后台队列（用于I/O），我们还可以自己创建队列。通常不建议给队列设置优先级，因为多任务在访问共享资源时，可能会造成优先级反转问题。</p></li>
<li><p>获取主队列：主队列是串行队列，所以比较适合处理共享资源、更新UI等事情</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_main_queue</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>获取不同优先级的全局队列：全局队列是并行队列，支持数百个线程执行</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_HIGH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_LOW</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>如果经常需要在后台队列上执行开销庞大的操作，可通过"dispatch_queue_create"函数创建新队列，它接收两个参数，第一个是标识符，可以在Instruments或lldb调试程序时查看队列名字，第二个参数用来表示创建的队列是串行还是并行，"DISPATCH_QUEUE_SERIAL"或"NULL"表示串行，"DISPATCH_QUEUE_CONCURRENT"表示并行。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">queueLabel</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;%@.%p.queue1&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nb">self</span> <span class="k">class</span><span class="p">],</span> <span class="nb">self</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">([</span><span class="n">queueLabel</span> <span class="n">UTF8String</span><span class="p">],</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">([</span><span class="n">queueLabel</span> <span class="n">UTF8String</span><span class="p">],</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>创建任务并交给队列处理</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 异步任务</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 同步任务</span>
</span><span class='line'><span class="n">dispatch_sync</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>同步任务很容易造成死锁，主要发生在串行队列中，并且同步任务所在队列为当前队列</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// dispatch_sync会立即阻塞主线程，然后把Block中的任务放到主队列中，主队列会将任务取出放到主线程中执行，</span>
</span><span class='line'><span class="c1">// 但主线程这个时候已经被阻塞了，所以Block中的任务就不能完成，而dispatch_sync也会一直阻塞主线程，</span>
</span><span class='line'><span class="c1">// 从而造成死锁现象，导致主线程一直卡死。</span>
</span><span class='line'><span class="n">dispatch_sync</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 同上</span>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;queue1&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="p">...</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>NSTimer在使用时会受runlop影响而导致延迟触发，当有更精准的计时需求时，可用GCD的计时器</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_source_t</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">dispatch_source_create</span><span class="p">(</span><span class="n">DISPATCH_SOURCE_TYPE_TIMER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</span><span class='line'><span class="n">dispatch_source_set_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="n">dispatch_walltime</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="c1">// 每秒触发一次</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_source_set_event_handler</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(...)</span> <span class="p">{</span>
</span><span class='line'>              <span class="n">dispatch_source_cancel</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span> <span class="c1">// 停止</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>      <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_resume</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span> <span class="c1">// 启动</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>dispatch_once可以控制block中的代码只被执行一次，通常用于创建单例，如果需要完整的单例，不被人alloc还需要进一步处理</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span> <span class="nf">sharedInstance</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">pred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">static</span> <span class="n">ClassName</span> <span class="o">*</span><span class="n">sharedObject</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pred</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">sharedObject</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">sharedObject</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>延迟处理，类似于"performSelector:withObject:afterDelay:&ldquo;，可指定时间和处理队列</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_after</span><span class="p">(</span><span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="mi">1</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">)),</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>当使用foreach遍历数组遇到效率问题时，可以考虑用dispatch_apply进行快速迭代，dispatch_apply是dispatch_sync和Dispatch Group的关联API，所以它会阻塞当前线程</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_apply</span><span class="p">(</span><span class="n">array</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%zu&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span> <span class="c1">// 由于任务在并发队列中，所以index为乱序</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;done&quot;</span><span class="p">);</span> <span class="c1">// 由于当前线程被阻塞，所以迭代结束后，此句才会执行</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>iOS8开始支持取消任务</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">serialQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;queue1&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">dispatch_block_t</span> <span class="n">firstBlock</span> <span class="o">=</span> <span class="n">dispatch_block_create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="kt">dispatch_block_t</span> <span class="n">secondBlock</span> <span class="o">=</span> <span class="n">dispatch_block_create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">serialQueue</span><span class="p">,</span> <span class="n">firstBlock</span><span class="p">);</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">serialQueue</span><span class="p">,</span> <span class="n">secondBlock</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_block_cancel</span><span class="p">(</span><span class="n">secondBlock</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>多任务并发，都完成后触发另一个任务，可通过队列组实现，例如同时下载2张图片，都下载完成后再将他们拼接起来</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
</span><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 任务1</span>
</span><span class='line'><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 下载资源1</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 任务2</span>
</span><span class='line'><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 下载资源2</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 任务1和任务2都完成后会自动通知</span>
</span><span class='line'><span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 处理资源1和资源2</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>dispatch_barrier_async在执行任务时会确保队列在此过程不会执行其它任务，可以在适当时候用来解决同步问题，它只在自己创建的队列上有这种作用，在全局并发队列和串行队列上，效果和dispatch_sync一样</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="s">&quot;queue1&quot;</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 在&quot;dispatch_barrier_async&quot;前面的任务执行结束后才执行，后面的任务等它执行完成后才会执行</span>
</span><span class='line'><span class="n">dispatch_barrier_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<ul>
<li>利用"dispatch_semaphore_t"信号量限制任务并发数，"dispatch_semaphore_wait"函数会消耗一次这个可用数，如果可用数已满则开始等待，"dispatch_semaphore_signal"函数每次执行都会将该可用计数加1，以此来表明已经释放了资源，如果此刻有因为等待可用资源而被阻塞的任务，系统会从等待的队列中解锁一个任务来执行。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">dispatch_semaphore_t</span> <span class="n">semaphore</span> <span class="o">=</span> <span class="n">dispatch_semaphore_create</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="c1">// 只有一个停车位</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">semaphore</span><span class="p">,</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">))))</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;不等了，开走&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;第一辆车来了，有位置直接停&quot;</span><span class="p">);</span> <span class="c1">// 1</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">semaphore</span><span class="p">,</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">))))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;不等了，开走&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;第二辆车,等到有位置后停车&quot;</span><span class="p">);</span> <span class="c1">// 3</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;第一辆车开走，这时第二辆车准备停车&quot;</span><span class="p">);</span> <span class="c1">// 2</span>
</span><span class='line'>    <span class="n">dispatch_semaphore_signal</span><span class="p">(</span><span class="n">semaphore</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">semaphore</span><span class="p">,</span> <span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">))))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;第三辆车不等了，开走&quot;</span><span class="p">);</span> <span class="c1">// 4</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;有位置，停车&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;第二辆车开走，第三辆车没有继续等&quot;</span><span class="p">);</span> <span class="c1">// 5</span>
</span><span class='line'>    <span class="n">dispatch_semaphore_signal</span><span class="p">(</span><span class="n">semaphore</span><span class="p">);</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p><br></p>

<h1>Operation Queues</h1>

<p>GCD提供了更加底层的控制，而操作队列则在GCD之上实现了一些方便的功能，这些功能对于我们来说通常是最好最安全的选择，使用时需要将任务封装到一个"NSOperation"对象中，再将它添加到"NSOperationQueue"，系统会将"NSOperationQueue"中的"NSOperation"取出并放到线程上执行。</p>

<ul>
<li>&ldquo;NSOperationQueue"默认是串行队列，可通过设置"maxConcurrentOperationCount"实现并发</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 获取主队列</span>
</span><span class='line'><span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">mainQueue</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSOperationQueue</span> <span class="n">mainQueue</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 创建队列</span>
</span><span class='line'><span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>&ldquo;NSOperation"不能够直接使用，可通过它的两个子类来封装任务，或者自定义Operation

<ul>
<li>NSInvocationOperation：通过SEL方式添加任务</li>
<li>NSBlockOperation：通过Block方式添加任务</li>
<li>自定义Operation：需要继承"NSOperation"类，并实现"main()&ldquo;方法
<br></li>
</ul>
</li>
<li>&ldquo;NSOperation"有一个非常实用的功能，可以添加和解除依赖。但要注意，不能相互依赖，否则会造成死锁，例如A依赖B，B依赖A。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">operation1</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>   <span class="c1">// 下载资源1</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">operation2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 下载资源2</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">operation3</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 处理资源1和资源2</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">operation3</span> <span class="nl">addDependency</span><span class="p">:</span><span class="n">operation1</span><span class="p">];</span>      <span class="c1">//任务三依赖任务一</span>
</span><span class='line'><span class="p">[</span><span class="n">operation3</span> <span class="nl">addDependency</span><span class="p">:</span><span class="n">operation2</span><span class="p">];</span>      <span class="c1">//任务三依赖任务二</span>
</span><span class='line'>
</span><span class='line'><span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">mainQueue</span><span class="p">]</span> <span class="nl">addOperations</span><span class="p">:</span><span class="l">@[</span><span class="n">operation3</span><span class="p">,</span> <span class="n">operation2</span><span class="p">,</span> <span class="n">operation1</span><span class="l">]</span> <span class="nl">waitUntilFinished</span><span class="p">:</span><span class="nb">NO</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>



</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">风行</span></span>

      




<time class='entry-date' datetime='2016-06-03T15:07:00+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2016</span></span> <span class='time'>3:07 pm</span></time>
      


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/09/21/objective-c-runtimekai-fa/" title="Previous Post: Objective-C Runtime开发">&laquo; Objective-C Runtime开发</a>
      
      
        <a class="basic-alignment right" href="/blog/2016/07/12/iosnei-cun-guan-li/" title="Next Post: iOS内存管理">iOS内存管理 &raquo;</a>
      
    </p>
  </footer>
</article>
</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="最新">
    
      <li class="post">
        <a href="/blog/2016/09/05/ios-appde-zu-jian-hua-she-ji/">iOS APP的组件化设计</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/09/ioskai-fa-tips/">iOS开发tips</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/09/man-chang-de-dai-ma-zhong-gou-zhi-lu/">代码重构</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/03/liao-jie-block/">了解block</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/12/iosnei-cun-guan-li/">iOS内存管理</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub</h1>
  <a href="https://github.com/lijingcheng">@lijingcheng</a> on GitHub
</section>



<section>
  <h1>Weibo</h1>
  <a href="https://weibo.com/lijingcheng1984">@lijingcheng1984</a> on Weibo
</section>



<section>
  <h1>Weixin</h1>
  <a href="http://7x00ed.com1.z0.glb.clouddn.com/qrcode.png">@bj_lijingcheng</a> on Weixin
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - 风行 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  
</body>
</html>
