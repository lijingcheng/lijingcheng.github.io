
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>iOS 应用的开发设计 - 风行的博客</title>
  <meta name="author" content="风行">

  
  <meta name="description" content="一个 app 从设计到发布应用商店会经历需求设计、UI设计、架构设计、开发、优化、测试等流程，每个环节做的好与坏都会影响到整个 app 的质量，作为开发人员，不仅要对需求以及 UI 的合理性进行评审，还要保证提供给测试的代码是经过自测并且覆盖了相关测试用例，更重要的是要做好架构设计、 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://lijingcheng.github.io/blog/2016/09/05/ios-appde-zu-jian-hua-she-ji/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="风行的博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">风行的博客</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss email">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
    <li><a href="mailto:bj_lijingcheng@163.com" rel="subscribe-email" title="subscribe via email">邮箱</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="lijingcheng.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">归档</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">iOS 应用的开发设计</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-09-05T18:40:19+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>6:40 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>一个 app 从设计到发布应用商店会经历需求设计、UI设计、架构设计、开发、优化、测试等流程，每个环节做的好与坏都会影响到整个 app 的质量，作为开发人员，不仅要对需求以及 UI 的合理性进行评审，还要保证提供给测试的代码是经过自测并且覆盖了相关测试用例，更重要的是要做好架构设计、开发以及优化这三个环节。</p>

<!-- more -->


<h1>架构设计</h1>

<p>架构设计可以以业务为驱动，按照最适合自己的方式去设计，设计思路和方法尽量统一，同类型问题用同样方式去解决，下面几点是我认为比较重要的：</p>

<ul>
<li><p>关注分离<br/>
将系统分解为多个模块并各司其职，纵向分层，横向拆分业务。</p></li>
<li><p>高内聚<br/>
一个模块只完成一个功能，并合理有度的进行封装。</p></li>
<li><p>松耦合<br/>
依赖关系越少越好，尽量不横向依赖，不跨层访问。继承是紧耦合的一种操作，它通常与多态一起存在，如果仅仅是为了代码重用而做的继承还不如用组合。</p></li>
<li><p>适度设计<br/>
对业务方该限制的地方要进行限制，该灵活的地方也要给业务方创造灵活实现的条件，架构的设计要保持一定量的超前性而做到易扩展，但不要设计过度，避免多做无用功而增加框架复杂度。好的架构是随着时间而更新的，而不是一开始就设计好了一切。</p></li>
<li><p>技术选型<br/>
不要仅是为了体验新技术而改变现有架构，等别人把坑踩平后再根据团队及业务情况考虑是否使用，技术本身没有什么好不好，只有适合不适合。</p></li>
</ul>


<p><br></p>

<h1>响应式编程</h1>

<p>响应式编程是一种面向数据及其变化响应的编程方式，它能够将数据、UI事件和异步操作更方便的进行序列化处理，相比传统编程方式来说，它可以使逻辑相关的代码能够紧凑的聚在一起，它通过信号机制来实现，用信号来记录值的变化，并通过信号绑定的方式来响应变化，下面这个例子很好的描述了响应式编程的作用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = 2 // signal
</span><span class='line'>b = 2 // signal
</span><span class='line'>c = a + b // signal binding c = 4 
</span><span class='line'>b = 3 // c = 5</span></code></pre></td></tr></table></div></figure>


<p>目前我们在 Swift 项目中选择使用 RxSwift + MVVM 的方式进行开发，使用 RxSwift 需要掌握以下几个概念：</p>

<ul>
<li><p>Observable（被观察者）：相当于一个事件序列，它会主动向订阅者发送新产生的事件内容，包括 onNext、onError、onCompleted()</p></li>
<li><p>Subscribe（订阅者）：订阅后便可以根据事件产生的数据进行操作</p></li>
<li><p>Scheduler（调度器）：可分别通过 subscribeOn 和 observeOn 指定 Observable 或 Subscribe 在哪个线程上执行，默认是当前线程。</p></li>
<li><p>Operator（<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree.html">操作符</a>）：RxSwift 提供了很多操作符，合理运用便会极大提高开发效率</p></li>
<li><p>Subject：既可以作为 Observable 发送事件也可以作为 Subscribe 监听事件，它包括以下几种：</p>

<ul>
<li>PublishSubject：订阅者只会接收到订阅操作之后的事件，也就是所说的热信号。</li>
<li>ReplaySubject：订阅者会接受到订阅之前的事件（可根据 bufferSize 指定数量）以及订阅之后的事件，类似于冷信号。</li>
<li>BehaviorSubject：订阅之后首先会接收到最近一次发送的事件，如果最近没有发送，那么发送一个初始事件。</li>
<li>AsyncSubject：订阅者只有在 Observable 发送 onCompleted() 时才能够收到它之前发送的最后一个事件，即使是在这之后的新订阅者也能够收到。</li>
</ul>
</li>
</ul>


<h1>组件化开发</h1>

<p>随着 app 功能和体积的增长，也带来了一些问题</p>

<ul>
<li>编译速度缓慢</li>
<li>commit 代码经常要 merge</li>
<li>业务代码混在一起、开发功能类似的新项目时需要从头搭建</li>
</ul>


<h2>拆分组件</h2>

<ul>
<li>每个组件对应一个 project，身为组件的同时还能够独立运行和打测试包</li>
<li>大点的项目除了按框架分层拆分还可以按业务模块拆分，需要把握好拆分粒度</li>
<li>小项目按框架分层拆分就可以了</li>
</ul>


<h2>组件之间的依赖关系</h2>

<ul>
<li>业务模块依赖于框架</li>
<li>业务模块之间避免横向依赖（可适当的有些重复代码或存放重复资源）</li>
<li>禁止框架依赖业务模块</li>
</ul>


<h2>组件化实施</h2>

<p>通过 CocoaPods 来实现组件化</p>

<ul>
<li>Podfile：定义组件以及第三方库的依赖关系</li>
<li>Podspec：定义组件的依赖库、编译设置、以及需要打包的资源及代码，资源包括 xib、国际化文件、assets 等</li>
</ul>


<h2>组件维护</h2>

<p>需要调试其它组件代码时可通过本地 link 方式去组装项目，也可以直接去 Pods 目录下修改，但要及时将修改好的代码迁移出来，否则代码会有丢失的危险，当组件变更后需要修改 podspec 中的版本号，然后通过 <code>pod repo push</code> 命令更新仓库，最后依赖方要按指定版本号更新，并且在使用 <code>pod update</code> 时不要加 <code>—-no-repo-update</code></p>

<h2>组件中的资源访问</h2>

<p>首先要在代码中正确使用 open、public、private，另外访问资源需要指定 bundle，例：<code>UIImage(named, bundle)</code>，有种简单的办法就是使用 R.Swift 提供的功能来访问资源，在使用时首先要添加下面角本到 Run Script，其中第二行角本的主要目的是替换 R.generate.swift 中关于 bundle 的设置，主要目的是让组件内写的 R.image 这种代码能够在别的组件中也正常使用，R.Swift 不支持跨组件访问资源，自行修改的话成本太大</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$PODS_ROOT/R.swift/rswift" generate "$SRCROOT" --accessLevel public
</span><span class='line'>sed -i '' -e "s/Bundle(for: R.Class.self)/Bundle.core/g" “$SRCROOT/</span></code></pre></td></tr></table></div></figure>


<p>Bundle.core 内容如下，每个组件都要去扩展 Bundle 类，添加自己的 bundle 名称</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>extension Bundle {
</span><span class='line'>    public static var core: Bundle {
</span><span class='line'>        let bundleName = "ProjectCore"
</span><span class='line'>        
</span><span class='line'>        // BaseViewModel 需要定义成 public
</span><span class='line'>        if let path = Bundle(for: BaseViewModel.self).path(forResource: bundleName, ofType: "bundle") {
</span><span class='line'>            let bundle = Bundle(path: path)!
</span><span class='line'>            bundle.name = bundleName // name 是自已扩展的属性，相关代码不再列出
</span><span class='line'>            return bundle
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        return Bundle.main
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>组件之间的路由跳转</h2>

<p>网上有很多关于这方面的文章，这里不再多说，只介绍两个小功能</p>

<ul>
<li><p>打开页面时指定是否需要登录，然后将原本想要跳转的页面信息及参数传递给登录页，当登录成功后直接跳转到该页面，并将登录页本身从导航堆栈中移除</p></li>
<li><p>返回页面时除原来的三种方式外，增加锚点方式返回，例如在购买商品页面填加锚点，然后当页面流转到购买成功时，可将导航堆栈反转过来，pop 到最近的一个锚点页面或指定锚点页面</p></li>
</ul>


<h2>组件的多环境打包</h2>

<p>App 运行环境通常有测试环境、预上线环境、正常环境三种，这里分别用 QA、STG、PRD 表示，有些公司还会有企业开发者账号，用来自己分发项目更方便的去做测试工作，下面针对这种情况做多环境打包设置</p>

<ul>
<li>通过 xcconfig 方式在原先的 debug、release 上扩展出 staging、enterprisePRD、production，切换环境时只要在 Scheme 中的 Build Configration 中设置一下就可以了（对于 xcconfig 这里不做详细介绍）</li>
<li>上面列出的 debug 和 release 对应 QA，enterprisePRD 和 production 对应 PRD，其中 production 作为正式打包上线的设置项</li>
<li>xcconfig 文件中可针对不同环境设置不同的 app 名字，还可以对 enterprisePRD 设置不同的微信Id 或其它内容</li>
</ul>


<h1>优化</h1>

<h2>数据安全</h2>

<p>我们从 AppStore 下载的 app 其实都已经由苹果加壳，要砸壳后才能有办法看到汇编形式的源代码，如果我们要自己再加一层壳，可以对关键代码的方法名做一些混淆，以增加别人分析代码的复杂度，不过这对于大多数 app 来说不太值得去做，我们可以把精力放在其他更易做并且更有效率的地方，例如：</p>

<ul>
<li>不将敏感数据直接存储在沙盒里</li>
<li>使用 Https 保证数据传输安全</li>
<li>调用接口时对敏感数据进行加密</li>
</ul>


<p>加密数据通常有两种方式</p>

<ul>
<li>对称加密：文件加密和解密使用相同的密钥，AES 相对其他对称加密方式来说更安全些。</li>
<li>非对称加密：需要公钥和私钥，用公钥对数据进行加密，只有对应的私钥才能解密；如果用私钥对数据进行加密，那么只有对应的公钥才能解密。可以用 RSA 来做非对称加密，相对对称加密来说非对称加密速度较慢，但非常安全，据说还没被破解过。</li>
</ul>


<p>对敏感数据进行加密通常选择对称加密，这时如何使用密钥则是一件非常重要的事，不管是 app 在代码中写死密钥还是简单的通过接口获取密钥都不安全，下面介绍一种相对更安全的方式：</p>

<ul>
<li>首先由客户端向服务端发起获取钥匙的请求</li>
<li>服务端生成公钥<code>pk1</code>和私钥<code>pk2</code>，然后将公钥<code>pk1</code>发送给客户端（假设此时黑客已经获取到了公钥<code>pk1</code>）</li>
<li>客户端这时首先生成公钥<code>pk3</code>和私钥<code>pk4</code>，然后将公钥<code>pk3</code>通过服务端返回的公钥<code>pk1</code>加密并发送给服务端（假设此时黑客截获加密后的<code>pk3</code>，虽然知道这是由<code>pk1</code>加密的，但是他不知道与其对应的私钥<code>pk2</code>，所以无法对客户端发送的公钥进行解密）</li>
<li>服务端收到加密后的<code>pk3</code>后可以通过私钥<code>pk2</code>解密，并使用<code>pk3</code>对生成的对称加密密钥<code>xxx</code>进行加密并发送给客户端（黑客这时因为不知道公钥<code>pk3</code>是什么，所以得不到对称加密的密钥）</li>
<li>客户端收到数据后，可以用自己的私钥<code>pk4</code>解密并得到对称加密用的密钥<code>xxx</code>，客户端将密钥<code>xxx</code>存储在内存中，接下来两端就可以使用<code>xxx</code>作为 key 来加密数据并进行安全的数据传输了。</li>
</ul>


<h2>启动时间</h2>

<p>可以通过 Instruments 的 Time Profiler 工具来查看耗费时间，也可以通过在 Xcode 中修改项目的 scheme，在 Run -> Auguments 增加环境变量 DYLD_PRINT_STATISTICS 并设置为 1，然后观察控制台打出的 log 来查看</p>

<ul>
<li>pre-main 阶段系统会由 dyld（the dynamic link editor）加载相关动态链接库，然后再初始化 runtime 环境，并由 runtime 触发 + load 方法，所以不要在 load 方法里执行耗时任务，否则会影响启动时间，并且用不到的代码文件要及时删除。</li>
<li>检查 didFinishLaunchingWithOptions 方法，将部分操作改为异步执行或延迟处理</li>
</ul>


<h2>App 瘦身</h2>

<ul>
<li>将部分资源文件从工程中移除，改为从接口获取，并且可以通过给数据加版本号，避免每次重复下载。</li>
<li>清理无用的代码文件和资源，不要 @1x 图片，如果用到了 ProtoBuf，可以将 .proto 文件从 Compile Sources 中移除。</li>
<li>压缩图片，目前发现 <a href="tinypng.com">tinypng.com</a> 的压缩效果最好，而且是无损的。</li>
<li>小图标可以使用 iconfont 替代，大图可以用 pdf 替代</li>
<li>启动图界面用 LaunchScreen.storyboard，不要用多张 Default 图。</li>
<li>用 .xcassets 来管理图片，Xcode 能够把里边的所有 png 图片压缩成 .car 文件。并且 iOS9 之后，如果是用 .xcassets 管理图片，AppStore 会根据不同设备准备不同的安装包，每个包内只有对应尺寸的图片，例如 iPhone6 下载 app 时，包里就只有 @2x 图。</li>
<li>放弃 iPhone5s 之前发布的 32 位手机</li>
<li>如果是 Swift 项目，优先考虑使用静态库</li>
</ul>


<h2>流量</h2>

<ul>
<li>合理使用本地缓存数据并及时更新缓存</li>
<li>考虑用 ProtoBuf 替代 JSON，也可以仅是个别数据量大的接口改为 ProtoBuf 格式数据</li>
<li>需要轮询的接口可用 WebSocket 替代</li>
<li>请求的图片格式由 jpg 改为 webp</li>
<li>按 UIImageView 大小取合适大小的图片，不要直接取原图</li>
<li>非关键的业务数据，可以通过合并接口的方式，减少和服务器的交互次数。</li>
<li>请求接口前客户端通过对 request params 做检查来减少不必要的网络请求</li>
<li>可以用 ETag 这种服务端加本地验证的方式处理返回数据，当数据没有更新时不返回数据，而是返回 304</li>
<li>数据量大时要提示用户是否在非 wifi 环境下下载</li>
</ul>


<h2>UI 交互</h2>

<ul>
<li>延迟处理不需要马上展现的视图或操作</li>
<li>不要阻塞主线程，能异步去做的就不要同步。</li>
<li>由于 UIKit 中大部分对象都不是线程安全的，所以 UI 操作都需要放在主线程做串行处理，否则可能会导致未知行为（动画异常、页面错乱、Crash）。</li>
<li>优化表格滑动

<ul>
<li>提前算 Cell 高度并缓存，如果要加载的数据也是要经过处理才展示的也提前处理好</li>
<li>异步绘制，滑动过程中不加载图片</li>
<li>当 Cell 中有很多子视图并且他们要在不同条件下展示时，考虑拆成多个 Cell</li>
<li>不要在 Cell 中频繁生成 NSDateFormatter 对象</li>
</ul>
</li>
<li>通过设置模拟器的 Debug 菜单下的几项设置来查看图层视图是否需要优化

<ul>
<li>Color Blended layers<br/>
大多情况是因为视图的 backgroundColor 与父视图颜色不一致或者是透明的，它会用红色表示有问题的视图，而绿色的表示没问题</li>
<li>Color copied images<br/>
当图片的色彩格式不能被 GPU 处理时，会交由 CPU 处理，应该尽可能避免这种问题</li>
<li>Color misaligned images<br/>
图片大小与控件不一致，会用黄色表示图片被缩放了，用紫色表示像素没对齐</li>
<li>Color offscreen-rendered<br/>
用黄色标示哪些 layer 需要做离屏渲染，多数时候离屏渲染会影响性能，应避免重写 drawRect 方法，避免使用 masksToBounds(设置圆角/模糊效果)、shouldRasterize(光栅化)、shadow(阴影)</li>
</ul>
</li>
</ul>


<p>PS：过早的优化是万恶之源！</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">风行</span></span>

      




<time class='entry-date' datetime='2016-09-05T18:40:19+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>6:40 pm</span></time>
      


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2016/06/09/ioskai-fa-tips/" title="Previous Post: iOS 开发 tips">&laquo; iOS 开发 tips</a>
      
      
        <a class="basic-alignment right" href="/blog/2016/12/05/tong-guo-xcodebuildda-bao-ipabing-shang-chuan-pu-gong-ying/" title="Next Post: 使用 xcodebuild 打包 IPA 并上传蒲公英">使用 xcodebuild 打包 IPA 并上传蒲公英 &raquo;</a>
      
    </p>
  </footer>
</article>
</div>

<aside class="sidebar">
  
    <section>
  <h1>最近更新</h1>
  <ul id="最新">
    
      <li class="post">
        <a href="/blog/2019/04/12/app-kai-fa-xu-yao-liao-jie-de-hou-duan-zhi-shi/">了解一点互联网架构</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/03/28/an-quan-xing-che-zhi-mo-tuo-che-pian/">学习骑摩托〜</a>
      </li>
    
      <li class="post">
        <a href="/blog/2017/10/19/new-driver/">安全行车注意事项</a>
      </li>
    
      <li class="post">
        <a href="/blog/2017/03/17/swift-base/">从 Objective-C 过渡到 Swift</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/12/23/shi-yong-carthage-zuo-yi-lai-guan-li/">使用 Carthage 做依赖管理</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub</h1>
  <a href="https://github.com/lijingcheng">@lijingcheng</a> on GitHub
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2019 - 风行 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  
</body>
</html>
